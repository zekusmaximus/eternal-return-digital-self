{"version":3,"file":"node-view-GFMNrUCl.js","sources":["../../src/store/hooks.ts","../../src/components/Constellation/NodesInstanced.tsx","../../src/components/Constellation/ConnectionsBatched.tsx"],"sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\r\nimport type { AppDispatch } from './index';\r\nimport type { RootState } from './types';\r\n\r\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\r\nexport const useAppDispatch: () => AppDispatch = useDispatch;\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n","import { useDispatch, useSelector } from 'react-redux';\nimport {\n  nodeHovered,\n  nodeUnhovered,\n  selectHoveredNodeId,\n  selectSelectedNodeId,\n  nodeSelected,\n  setViewMode,\n  // Removed incorrect import\n} from '../../store/slices/interfaceSlice';\nimport { navigateToNode } from '../../store/slices/readerSlice';\nimport { visitNode } from '../../store/slices/nodesSlice';\nimport { AppDispatch } from '../../store';\nimport { ConstellationNode, NodePositions } from '../../types';\nimport { forwardRef, useMemo, useRef, useState } from 'react';\nimport { Color, InstancedMesh, ShaderMaterial } from 'three';\nimport * as THREE from 'three';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport type { ThreeEvent } from '@react-three/fiber';\nimport { Text } from '@react-three/drei';\n\n\n// Circuit pattern vertex shader\nconst circuitVertexShader = `\n  varying vec3 vPosition;\n  varying vec3 vNormal;\n  varying vec2 vUv;\n  \n  void main() {\n    vPosition = position;\n    vNormal = normalize(normalMatrix * normal);\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\n// Circuit pattern fragment shader\nconst circuitFragmentShader = `\n  uniform vec3 color;\n  uniform float time;\n  \n  varying vec3 vPosition;\n  varying vec3 vNormal;\n  varying vec2 vUv;\n  \n  // Simple hash function\n  float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n  }\n  \n  void main() {\n    // Basic circuit pattern\n    vec2 gridPos = floor(vPosition.xy * 10.0);\n    float circuit = hash(gridPos) > 0.7 ? 1.0 : 0.0;\n    \n    // Circuit lines\n    vec2 grid = fract(vPosition.xy * 10.0);\n    float line = smoothstep(0.95, 0.98, max(grid.x, grid.y));\n    \n    // Flowing effect on circuit lines\n    float flow = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\n    \n    // Combine effects\n    vec3 finalColor = color * (0.5 + 0.5 * circuit + line * flow);\n    \n    // Add rim lighting\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\n    rim = pow(rim, 3.0);\n    finalColor += color * rim * 0.5;\n    \n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\n\n// Force field vertex shader for hover effect\nconst forceFieldVertexShader = `\n  uniform float time;\n  varying vec3 vPosition;\n  varying vec3 vNormal;\n  \n  void main() {\n    vPosition = position;\n    vNormal = normalize(normalMatrix * normal);\n    \n    // Add subtle pulsating effect\n    float pulse = sin(time * 2.0) * 0.05 + 1.05;\n    vec3 newPosition = position * pulse;\n    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n  }\n`;\n\n// Force field fragment shader for hover effect\nconst forceFieldFragmentShader = `\n  uniform vec3 color;\n  uniform float time;\n  varying vec3 vPosition;\n  varying vec3 vNormal;\n  \n  void main() {\n    // Create flowing wave pattern\n    float wave = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\n    \n    // Rim effect for sphere edge glow\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\n    rim = pow(rim, 3.0);\n    \n    // Transparency based on rim and wave pattern\n    float alpha = rim * 0.7 * wave;\n    \n    // Final color with slight pulsation\n    float pulse = sin(time * 3.0) * 0.2 + 0.8;\n    vec3 finalColor = color * pulse * (0.5 + wave * 0.5);\n    \n    gl_FragColor = vec4(finalColor, alpha);\n  }\n`;\n\ninterface NodesInstancedProps {\n  nodes: ConstellationNode[];\n  nodePositions: NodePositions;\n  connections: { start: string; end: string }[];\n  overrideSelectedNodeId?: string;\n  onNodeClick?: (nodeId: string) => void;\n  clickableNodeIds?: string[];\n  isMinimap?: boolean; // Flag to indicate if this is used in the minimap\n isInitialChoicePhase: boolean;\n triumvirateActive: boolean;\n triumvirateNodes: string[];\n positionSynchronizer: {\n   updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\n   getCurrentPositions: () => { [key: string]: [number, number, number] };\n  };\n}\n\n// Define base colors for each triad - match exact character names from nodesSlice.ts\nconst triadColors = {\n  LastHuman: new Color('#ff6666'), // Reddish\n  Archaeologist: new Color('#66ff66'), // Greenish\n  Algorithm: new Color('#6666ff'), // Bluish\n};\n\n// Create a more permissive lookup that doesn't rely on exact matching\n// Helper to get color for node based on character with proper type safety\nconst getNodeColor = (character: string | undefined): Color => {\n  if (!character) return new Color('#ffffff');\n  \n  // Direct lookup with type safety\n  if (character === 'LastHuman') return triadColors.LastHuman;\n  if (character === 'Archaeologist') return triadColors.Archaeologist;\n  if (character === 'Algorithm') return triadColors.Algorithm;\n  \n  // Case-insensitive lookup as fallback\n  const lowerChar = character.toLowerCase();\n  if (lowerChar.includes('human')) return triadColors.LastHuman;\n  if (lowerChar.includes('arch')) return triadColors.Archaeologist;\n  if (lowerChar.includes('algo')) return triadColors.Algorithm;\n  \n  // Default\n  console.warn(`Unknown character type: ${character}, using default color`);\n  return new Color('#ffffff');\n};\n\n\nexport const NodesInstanced = forwardRef<InstancedMesh, NodesInstancedProps>((props, ref) => {\n  const {\n    nodes,\n    nodePositions,\n    connections,\n    overrideSelectedNodeId,\n    onNodeClick,\n    clickableNodeIds,\n    isInitialChoicePhase,\n    positionSynchronizer,\n    triumvirateActive,\n    triumvirateNodes,\n  } = props;\n  const dispatch = useDispatch<AppDispatch>();\n  const { camera } = useThree();\n  \n  const hoveredNodeId = useSelector(selectHoveredNodeId);\n  const reduxSelectedNodeId = useSelector(selectSelectedNodeId);\n  const selectedNodeId = overrideSelectedNodeId ?? reduxSelectedNodeId;\n\n  const triumvirateNodeSet = useMemo(() => new Set(triumvirateNodes), [triumvirateNodes]);\n  const triumvirateColorMap = useMemo(() => ({\n    'arch-discovery': new Color('#66ff66'), // Green\n    'algo-awakening': new Color('#6666ff'), // Blue\n    'human-discovery': new Color('#ff6666'), // Red\n  }), []);  const connectedNodeIds = useMemo(() => {\n    if (isInitialChoicePhase || triumvirateActive) return triumvirateNodeSet;\n    if (!selectedNodeId) return new Set<string>();\n    const connected = new Set<string>();\n    connections.forEach((c) => {\n      if (c.start === selectedNodeId) connected.add(c.end);\n      if (c.end === selectedNodeId) connected.add(c.start);\n    });\n    return connected;\n  }, [selectedNodeId, connections, triumvirateActive, triumvirateNodeSet, isInitialChoicePhase]);\n\n  // State to track current node positions for positioning groups\n  const [groupPositions, setGroupPositions] = useState<{[key: string]: [number, number, number]}>({});\n\n  // Create refs for accessing objects in the scene\n  const materialRefs = useRef<ShaderMaterial[]>([]);\n  const forceFieldMaterialRefs = useRef<ShaderMaterial[]>([]);\n  const nodeMeshRefs = useRef<THREE.Object3D[]>([]);\n  const forceFieldMeshRefs = useRef<THREE.Object3D[]>([]);\n  const labelTextRefs = useRef<THREE.Object3D[]>([]);\n  const triumvirateTextRefs = useRef<THREE.Object3D[]>([]);\n  \n  // Store original positions for the noise animation\n  const originalPositions = useRef<{[key: string]: [number, number, number]}>({});\n  \n  // Initialize original positions\n  useMemo(() => {\n    nodes.forEach(node => {\n      const position = nodePositions[node.id] || [0, 0, 0];\n      originalPositions.current[node.id] = [...position];\n    });\n  }, [nodes, nodePositions]);\n  \n  \n  // Update shader time uniform and apply noise movement with optimized LOD\n  // Frame counter for throttling updates\n  const frameCount = useRef(0);\n  const lastUpdatePositionsTime = useRef(0);\n  const lastUpdateMaterialsTime = useRef(0);\n  \n  // Enhanced optimization: Using variable update rates based on priority\n  useFrame((state): void => {\n    const time = state.clock.elapsedTime;\n    frameCount.current += 1;\n    \n    // Get synchronized positions from the position synchronizer\n    const currentPositions = positionSynchronizer.updatePositions(time, props.isMinimap);\n      \n    // All nodes are always visible, no need for validation\n    \n    // Time-based throttling for shader updates\n    const shouldUpdateMaterials = time - lastUpdateMaterialsTime.current > 0.05; // 50ms\n    if (shouldUpdateMaterials) {\n      lastUpdateMaterialsTime.current = time;\n      \n      // Update time uniforms on important materials only\n      const importantMaterials = materialRefs.current.filter((_, i) => {\n        const node = nodes[i];\n        return node && (\n          node.id === selectedNodeId ||\n          node.id === hoveredNodeId ||\n          connections.some(c => c.start === node.id || c.end === node.id)\n        );\n      });\n      \n      // Batch updates to reduce overhead\n      importantMaterials.forEach(material => {\n        if (material?.uniforms?.time) {\n          material.uniforms.time.value = time;\n        }\n      });\n      \n      // Update force field materials only for selected/hovered nodes\n      const importantForceFields = forceFieldMaterialRefs.current.filter((_, i) => {\n        const node = nodes[i];\n        return node && (node.id === selectedNodeId || node.id === hoveredNodeId);\n      });\n      \n      importantForceFields.forEach(material => {\n        if (material?.uniforms?.time) {\n          material.uniforms.time.value = time;\n        }\n      });\n    }\n    \n    // SYNC FIX: Ensure we update positions on the same frames as ConnectionsBatched\n    // This is critical for keeping nodes and connections aligned\n    const timeSinceLastPositionUpdate = time - lastUpdatePositionsTime.current;\n    // CRITICAL SYNC FIX: Use same update interval as ConnectionsBatched\n    const UPDATE_INTERVAL = 0.15; // 150ms in seconds\n    const shouldUpdatePositions = timeSinceLastPositionUpdate >= UPDATE_INTERVAL;\n    \n    if (shouldUpdatePositions) {\n      lastUpdatePositionsTime.current = time;\n      \n      // Apply organic movement to nodes using noise - with optimized calculations\n      // And apply pulsing effect for designated starting nodes\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        const nodeMesh = nodeMeshRefs.current[i] as THREE.Mesh; // Cast for scale property\n        \n        if (!nodeMesh) {\n          continue; // Skip if mesh doesn't exist\n        }\n        \n        const origPos = originalPositions.current[node.id];\n        if (!origPos) {\n          continue; // Skip if no original position\n        }\n\n        // Determine if this node is a designated starting node for pulsing logic\n        let isDesignatedStartingNodeForPulse = false;\n        if (isInitialChoicePhase && !props.isMinimap) { // Pulse only in main view during initial phase\n          if (node.contentSource === 'arch-discovery.md' ||\n              node.contentSource === 'algo-awakening.md' ||\n              node.contentSource === 'human-discovery.md') {\n            isDesignatedStartingNodeForPulse = true;\n          }\n        }\n\n        if (isDesignatedStartingNodeForPulse) {\n          const pulseSpeed = 3;\n          const pulseAmount = 0.15; // Scale pulsates between 0.85 and 1.15 approx.\n          const baseScale = 1.0;\n          const targetScale = baseScale + Math.sin(time * pulseSpeed) * pulseAmount;\n          nodeMesh.scale.set(targetScale, targetScale, targetScale);\n        } else {\n          // Ensure non-pulsing nodes (or minimap nodes, or when not in initial phase) have normal scale\n          const baseScale = props.isMinimap ? 0.5 : 1.0;\n          if (nodeMesh.scale.x !== baseScale || nodeMesh.scale.y !== baseScale || nodeMesh.scale.z !== baseScale) {\n            nodeMesh.scale.set(baseScale, baseScale, baseScale);\n          }\n        }\n        \n        // Always update all nodes\n        const shouldUpdate = true;\n        const isImportantNode = node.id === selectedNodeId ||\n                               node.id === hoveredNodeId ||\n                               connectedNodeIds.has(node.id);\n        \n        // Always show the node\n        nodeMesh.visible = true;\n        \n        // Show force field only for important nodes\n        const forceMesh = forceFieldMeshRefs.current[i];\n        if (forceMesh) {\n          forceMesh.visible = isImportantNode;\n        }\n            if (shouldUpdate) {\n          // CRITICAL FIX: Since groups are positioned, mesh stays at origin within group\n          const syncedPos = currentPositions[node.id];\n          \n          if (syncedPos) {\n            // Don't update mesh position - it's handled by group positioning in render\n            // Just ensure the mesh is visible and at origin within its group\n            nodeMesh.position.set(0, 0, 0);\n          } else {\n            // Fallback to original position if synchronized position is not available\n            console.warn(`NodesInstanced: Missing synchronized position for node ${node.id}`);\n            nodeMesh.position.set(0, 0, 0);\n          }\n          \n          // Update force field position only if it exists and node is important\n          const forceMesh = forceFieldMeshRefs.current[i];\n          if (forceMesh && isImportantNode) {\n            forceMesh.visible = true;\n            forceMesh.position.set(0, 0, 0); // Also at origin within group\n          } else if (forceMesh) {\n            forceMesh.visible = false;\n          }        }\n      }\n      \n      // Update text billboard behavior - make text always face camera\n      // Update both label text and triumvirate text to face the camera\n      for (let i = 0; i < nodes.length; i++) {\n        const labelText = labelTextRefs.current[i];\n        const triumvirateText = triumvirateTextRefs.current[i];\n        \n        if (labelText && labelText.visible) {\n          labelText.lookAt(camera.position);\n        }\n        \n        if (triumvirateText && triumvirateText.visible) {\n          triumvirateText.lookAt(camera.position);\n        }\n      }\n      \n      // Update group positions for next render\n      setGroupPositions({ ...currentPositions });\n      \n      // No need to update visible node count since we removed the display\n    }\n  });\n  \n  // Create a dummy instanced mesh to maintain API compatibility with ref\n  // while still using individual meshes for better control\n  return (\n    <group>\n      {/* This invisible instanced mesh is just for ref compatibility */}\n      {ref && (\n        <instancedMesh\n          ref={ref}\n          args={[\n            new THREE.BufferGeometry(),\n            new THREE.MeshBasicMaterial(),\n            0\n          ]}\n          visible={false}\n        />\n      )}\n      {nodes.map((node, index) => {\n        const isSelected = selectedNodeId === node.id;\n        const isConnected = connectedNodeIds.has(node.id);\n        const isHovered = hoveredNodeId === node.id;        let isDesignatedStartingNode = false;\n        let labelText = '';\n        \n        if (isInitialChoicePhase) {\n          if (node.contentSource === 'arch-discovery.md') {\n            isDesignatedStartingNode = true;\n            labelText = 'The Archaeologist';\n          } else if (node.contentSource === 'algo-awakening.md') {\n            isDesignatedStartingNode = true;\n            labelText = 'The Algorithm';\n          } else if (node.contentSource === 'human-discovery.md') {\n            isDesignatedStartingNode = true;\n            labelText = 'The Last Human';\n          }\n        }\n        \n        // Add triumvirate text labels\n        let triumvirateText = '';\n        if (triumvirateActive && triumvirateNodes.includes(node.id)) {\n          if (node.id === 'arch-discovery') {\n            triumvirateText = 'Discovery';\n          } else if (node.id === 'algo-awakening') {\n            triumvirateText = 'Awakening';\n          } else if (node.id === 'human-discovery') {\n            triumvirateText = 'Choice';\n          }\n        }\n        \n        // Calculate node color using our more permissive function\n        const nodeColor = getNodeColor(node.character).clone();\n        \n        // Apply color adjustments based on node state\n        if (isInitialChoicePhase) {\n          if (triumvirateNodeSet.has(node.id)) {\n            const color = triumvirateColorMap[node.id as keyof typeof triumvirateColorMap];\n            if (color) {\n              nodeColor.set(color);\n            }\n          } else {\n            nodeColor.multiplyScalar(0.2); // Dim non-triumvirate nodes\n          }\n        }\n        else if (triumvirateActive) {\n          if (!triumvirateNodeSet.has(node.id)) {\n            nodeColor.multiplyScalar(0.2); // Dim non-triumvirate nodes\n          }\n        } else if (isSelected) {\n          nodeColor.multiplyScalar(1.5); // Lighter shade\n        } else if (isConnected) {\n          nodeColor.multiplyScalar(0.5); // Darker shade\n        } else if (isHovered) {\n          nodeColor.multiplyScalar(1.2); // Slightly lighter for hover\n        } else if (isDesignatedStartingNode) {\n          // Potentially give starting nodes a distinct look even if not selected/hovered,\n          // or this could be handled by the pulsing effect later.\n          // For now, let's ensure they don't get dimmed like 'isConnected' if they are also connected.\n          // Example: nodeColor.multiplyScalar(1.1); // Slightly brighter if it's a starting node\n        }        // The main node group's position is determined by synchronized positions,\n        // and individual elements within this group (like the sphere and text) will be positioned relatively.\n        const groupPosition = groupPositions[node.id] || originalPositions.current[node.id] || [0, 0, 0];\n        \n        return (\n          <group\n            key={node.id}\n            position={groupPosition} // Position group at the node's current position\n            userData={{ nodeId: node.id }} // Add nodeId to userData for connection positioning\n          >\n            {/* Text label for node - only for designated starting nodes in initial choice phase */}\n            {isDesignatedStartingNode && isInitialChoicePhase && !triumvirateActive && !props.isMinimap && labelText && (\n              <Text\n                ref={(text) => {\n                  if (text) {\n                    labelTextRefs.current[index] = text;\n                  }\n                }}\n                position={[0, 2.2, 0]} // Position higher above the node sphere\n                fontSize={0.4} // Larger font size for better visibility\n                color=\"white\"\n                anchorX=\"center\"\n                anchorY=\"middle\"\n                outlineWidth={0.03}\n                outlineColor=\"#000000\"\n                material-depthTest={false} // Ensures text is visible\n                material-transparent={true}\n                fontWeight=\"bold\"\n              >\n                {labelText}\n              </Text>\n            )}\n\n            {/* Triumvirate text labels */}\n            {triumvirateActive && !props.isMinimap && triumvirateText && (\n              <Text\n                ref={(text) => {\n                  if (text) {\n                    triumvirateTextRefs.current[index] = text;\n                  }\n                }}\n                position={[0, 2.2, 0]} // Position above the node sphere (relative to the group)\n                fontSize={0.6} // Larger font size for better visibility\n                color=\"white\"\n                anchorX=\"center\"\n                anchorY=\"middle\"\n                outlineWidth={0.05}\n                outlineColor=\"#000000\"\n                material-depthTest={false} // Ensures text is visible\n                material-transparent={true}\n                fontWeight=\"bold\"\n              >\n                {triumvirateText}\n              </Text>\n            )}\n\n            {/* Force field effect (only visible when hovered or selected) */}\n            {(isHovered || isSelected) && (\n              <mesh\n                ref={(mesh) => {\n                  if (mesh) {\n                    forceFieldMeshRefs.current[index] = mesh;\n                  }\n                }}\n                // Position is now relative to the parent group, so [0,0,0] for the force field center\n                position={[0, 0, 0]}>\n                <sphereGeometry args={[1.4, 16, 16]} />\n                <shaderMaterial\n                  ref={(material) => {\n                    if (material) {\n                      forceFieldMaterialRefs.current[index] = material;\n                    }\n                  }}\n                  vertexShader={forceFieldVertexShader}\n                  fragmentShader={forceFieldFragmentShader}\n                  uniforms={{\n                    color: { value: nodeColor },\n                    time: { value: 0 }\n                  }}\n                  transparent={true}\n                  depthWrite={false}\n                />\n              </mesh>\n            )}\n            \n            {/* Main node mesh */}\n            <mesh\n              ref={(mesh) => {\n                if (mesh) {\n                  nodeMeshRefs.current[index] = mesh;\n                }\n              }}\n              // Position is now relative to the parent group, so [0,0,0] for the node sphere center\n              position={[0, 0, 0]}\n              onClick={(e: ThreeEvent<MouseEvent>) => {\n                if (e.stopPropagation) e.stopPropagation();\n\n                // Emit custom event to hide tooltip when a node is clicked\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\n                window.dispatchEvent(nodeUnhoverEvent);\n\n                if (isInitialChoicePhase) {\n                  if (isDesignatedStartingNode) {\n                    // Dispatch actions in sequence with proper error handling\n                    try {\n                      dispatch(nodeSelected(node.id));\n                      dispatch(visitNode(node.id));\n                      dispatch(setViewMode('reading'));\n                      dispatch(navigateToNode({\n                        nodeId: node.id,\n                        character: node.character,\n                        temporalValue: node.temporalValue,\n                        attractors: node.strangeAttractors,\n                      }));\n                    } catch (error) {\n                      console.error('Navigation error:', error);\n                    }\n                  }\n                  return; // Exit early if in initial choice phase\n                }\n                // Normal click logic (outside initial choice phase)\n                if (onNodeClick) { // This path is typically for MiniConstellation\n                  if (clickableNodeIds && !clickableNodeIds.includes(node.id)) {\n                    return;\n                  }\n                  onNodeClick(node.id);\n                } else { // This path is for the main ConstellationView\n                  if (selectedNodeId === null) { // If no node is selected, any node can be clicked\n                    dispatch(nodeSelected(node.id));\n                    dispatch(visitNode(node.id));\n                    dispatch(setViewMode('reading'));\n                    dispatch(navigateToNode({\n                      nodeId: node.id,\n                      character: node.character,\n                      temporalValue: node.temporalValue,\n                      attractors: node.strangeAttractors,\n                    }));\n                  } else { // If a node is already selected, only connected nodes can be clicked\n                    const isConnectedToCurrentSelected = connections.some(\n                      (c) =>\n                        (c.start === selectedNodeId && c.end === node.id) ||\n                        (c.start === node.id && c.end === selectedNodeId)\n                    );\n                    if (isConnectedToCurrentSelected) {\n                      dispatch(nodeSelected(node.id));\n                      dispatch(visitNode(node.id));\n                      dispatch(setViewMode('reading'));\n                      dispatch(navigateToNode({\n                        nodeId: node.id,\n                        character: node.character,\n                        temporalValue: node.temporalValue,\n                        attractors: node.strangeAttractors,\n                      }));\n                    }\n                  }\n                }\n              }}\n              onPointerOver={(e: ThreeEvent<PointerEvent>) => {\n                if (props.isMinimap) return; // Do not show hover effects in minimap\n                if (e.stopPropagation) e.stopPropagation();\n                if (node.id !== hoveredNodeId) {\n                  dispatch(nodeHovered(node.id));\n                  \n                  // Determine if this node is clickable using the same logic as onClick\n                  let isClickable = false;\n                  \n                  if (triumvirateActive) {\n                    isClickable = triumvirateNodeSet.has(node.id);\n                  } else if (isInitialChoicePhase) {\n                    // In initial choice phase, only designated starting nodes are clickable\n                    isClickable = isDesignatedStartingNode;\n                  } else {\n                    // Normal click logic (outside initial choice phase)\n                    if (onNodeClick) { // This path is typically for MiniConstellation\n                      isClickable = !clickableNodeIds || clickableNodeIds.includes(node.id);\n                    } else { // This path is for the main ConstellationView\n                      if (selectedNodeId === null) { // If no node is selected, any node can be clicked\n                        isClickable = true;\n                      } else { // If a node is already selected, only connected nodes can be clicked\n                        const isConnectedToCurrentSelected = connections.some(\n                          (c) =>\n                            (c.start === selectedNodeId && c.end === node.id) ||\n                            (c.start === node.id && c.end === selectedNodeId)\n                        );\n                        isClickable = isConnectedToCurrentSelected;\n                      }\n                    }\n                  }\n                  \n                  // Emit custom event for tooltip positioning\n                  // Just use client coordinates from the event directly\n                  const nodeHoverEvent = new CustomEvent('node-hover', {\n                    detail: {\n                      position: {\n                        x: e.clientX,\n                        y: e.clientY - 40 // Position tooltip 40px above cursor\n                      },\n                      nodeId: node.id,\n                      isClickable: isClickable\n                    }\n                  });\n                  window.dispatchEvent(nodeHoverEvent);\n                }\n              }}\n              onPointerOut={(e: ThreeEvent<PointerEvent>) => {\n                if (props.isMinimap) return;\n                if (e.stopPropagation) e.stopPropagation();\n                dispatch(nodeUnhovered());\n                \n                // Emit custom event for tooltip hiding\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\n                window.dispatchEvent(nodeUnhoverEvent);\n              }}\n              \n              // Fix for stuck hover: Add pointer leave event\n              onPointerLeave={(e: ThreeEvent<PointerEvent>) => {\n                if (props.isMinimap) return;\n                if (e.stopPropagation) e.stopPropagation();\n                dispatch(nodeUnhovered());\n                \n                // Emit custom event for tooltip hiding\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\n                window.dispatchEvent(nodeUnhoverEvent);\n              }}\n            >\n              {/* Use lower poly geometry for distant nodes */}\n              {/* Performance optimization: Use lower poly geometry for distant nodes */}\n              {!isSelected && !isHovered ? (\n                <octahedronGeometry args={[1.0, 0]} /> // Lower poly for distant nodes - doubled size\n              ) : (\n                <sphereGeometry args={[1.0, 8, 8]} /> // Higher detail for selected/hovered - doubled size\n              )}\n              <shaderMaterial\n                ref={(material) => {\n                  if (material) {\n                    // Store reference to this material\n                    materialRefs.current[index] = material;\n                  }\n                }}\n                vertexShader={circuitVertexShader}\n                fragmentShader={circuitFragmentShader}\n                uniforms={{\n                  color: { value: nodeColor },\n                  time: { value: 0 }\n                }}\n                transparent={true}\n                depthWrite={false}\n              />\n            </mesh>\n          </group>\n        );\n      })}\n      \n      {/* Performance display removed */}\n    </group>\n  );\n});","import React, { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { Connection, NodePositions } from '../../types';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\ninterface ConnectionsBatchedProps {\r\n  connections: Connection[];\r\n  nodePositions: NodePositions;\r\n  selectedNodeId?: string | null;\r\n  hoveredNodeId?: string | null;\r\n  positionSynchronizer: {\r\n    updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n    getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n  isMinimap?: boolean;\r\n  triumvirateActive?: boolean;\r\n  triumvirateNodes?: string[];\r\n}\r\n\r\n// --- Reusable utility objects to prevent reallocation in the render loop ---\r\nconst baseColor = new THREE.Color();\r\nconst pulseColor = new THREE.Color();\r\n\r\nexport const ConnectionsBatched: React.FC<ConnectionsBatchedProps> = (props) => {\r\n    const { connections, nodePositions, selectedNodeId, hoveredNodeId, positionSynchronizer, isMinimap } = props;\r\n\r\n    const lineSegmentsRef = useRef<THREE.LineSegments>(null!);\r\n    const geometryRef = useRef<THREE.BufferGeometry>(null!);\r\n\r\n    // This effect sets up the geometry and its attributes once.\r\n    useEffect(() => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(connections.length * 2 * 3);\r\n        const colors = new Float32Array(connections.length * 2 * 3);\r\n\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        \r\n        if (lineSegmentsRef.current) {\r\n            lineSegmentsRef.current.geometry = geometry;\r\n        }\r\n        geometryRef.current = geometry;\r\n\r\n        return () => {\r\n            geometry.dispose();\r\n        }\r\n    }, [connections.length]);\r\n\r\n    useFrame((state) => {\r\n        if (!geometryRef.current) return;\r\n\r\n        const positionAttribute = geometryRef.current.attributes.position as THREE.BufferAttribute;\r\n        const colorAttribute = geometryRef.current.attributes.color as THREE.BufferAttribute;\r\n        \r\n        // Use dynamic positions for the main view, and static for the minimap\r\n        const currentPositions = isMinimap ? nodePositions : positionSynchronizer.updatePositions(state.clock.elapsedTime);\r\n\r\n        for (let i = 0; i < connections.length; i++) {\r\n            const connection = connections[i];\r\n            const startPos = currentPositions[connection.source];\r\n            const endPos = currentPositions[connection.target];\r\n\r\n            if (startPos && endPos) {\r\n                positionAttribute.setXYZ(i * 2, startPos[0], startPos[1], startPos[2]);\r\n                positionAttribute.setXYZ(i * 2 + 1, endPos[0], endPos[1], endPos[2]);\r\n            }\r\n\r\n            const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n            const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n            const isAvailable = !isSelected && !isHovered && selectedNodeId && (connection.source === selectedNodeId || connection.target === selectedNodeId);\r\n\r\n            let finalColor;\r\n\r\n            if (isSelected) {\r\n                finalColor = baseColor.set(0x00bfff);\r\n            } else if (isHovered) {\r\n                finalColor = baseColor.set(0x88ccff);\r\n            } else if (isAvailable) {\r\n                const pulse = 0.5 + 0.5 * Math.sin(state.clock.elapsedTime * 5);\r\n                finalColor = pulseColor.set(0x4488ff).lerp(baseColor.set(0xffffff), pulse);\r\n            } else {\r\n                finalColor = baseColor.set(0xffffff); // Default to white\r\n            }\r\n            \r\n            colorAttribute.setXYZ(i * 2, finalColor.r, finalColor.g, finalColor.b);\r\n            colorAttribute.setXYZ(i * 2 + 1, finalColor.r, finalColor.g, finalColor.b);\r\n        }\r\n\r\n        positionAttribute.needsUpdate = true;\r\n        // Always update colors for simplicity, as the available check is complex\r\n        colorAttribute.needsUpdate = true;\r\n    });\r\n\r\n    return (\r\n        <lineSegments ref={lineSegmentsRef}>\r\n            {/* The geometry is created and managed in the useEffect/useFrame hooks */}\r\n            <lineBasicMaterial vertexColors={true} toneMapped={false} fog={false} />\r\n        </lineSegments>\r\n    );\r\n};\r\n"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","circuitVertexShader","circuitFragmentShader","forceFieldVertexShader","forceFieldFragmentShader","triadColors","Color","getNodeColor","character","lowerChar","NodesInstanced","forwardRef","props","ref","nodes","nodePositions","connections","overrideSelectedNodeId","onNodeClick","clickableNodeIds","isInitialChoicePhase","positionSynchronizer","triumvirateActive","triumvirateNodes","dispatch","camera","useThree","hoveredNodeId","selectHoveredNodeId","reduxSelectedNodeId","selectSelectedNodeId","selectedNodeId","triumvirateNodeSet","useMemo","triumvirateColorMap","connectedNodeIds","connected","c","groupPositions","setGroupPositions","useState","materialRefs","useRef","forceFieldMaterialRefs","nodeMeshRefs","forceFieldMeshRefs","labelTextRefs","triumvirateTextRefs","originalPositions","node","position","frameCount","lastUpdatePositionsTime","lastUpdateMaterialsTime","useFrame","state","time","currentPositions","_","i","material","_a","nodeMesh","isDesignatedStartingNodeForPulse","targetScale","baseScale","isImportantNode","forceMesh","labelText","triumvirateText","jsx","THREE.BufferGeometry","THREE.MeshBasicMaterial","index","isSelected","isConnected","isHovered","isDesignatedStartingNode","nodeColor","color","groupPosition","jsxs","Text","text","mesh","e","nodeUnhoverEvent","nodeSelected","visitNode","setViewMode","navigateToNode","error","nodeHovered","isClickable","nodeHoverEvent","nodeUnhovered","baseColor","THREE.Color","pulseColor","ConnectionsBatched","isMinimap","lineSegmentsRef","geometryRef","useEffect","geometry","positions","colors","THREE.Float32BufferAttribute","positionAttribute","colorAttribute","connection","startPos","endPos","isAvailable","finalColor","pulse"],"mappings":"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"}