{"version":3,"file":"node-view-CKzL31Pm.js","sources":["../../src/components/Constellation/NodesInstanced.tsx","../../src/components/Constellation/ConnectionsBatched.tsx"],"sourcesContent":["import { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  nodeHovered,\r\n  nodeUnhovered,\r\n  selectHoveredNodeId,\r\n  selectSelectedNodeId,\r\n  nodeSelected,\r\n  setViewMode,\r\n  // Removed incorrect import\r\n} from '../../store/slices/interfaceSlice';\r\nimport { navigateToNode } from '../../store/slices/readerSlice';\r\nimport { visitNode } from '../../store/slices/nodesSlice';\r\nimport { AppDispatch } from '../../store';\r\nimport { ConstellationNode, NodePositions } from '../../types';\r\nimport { forwardRef, useMemo, useRef, useState } from 'react';\r\nimport { Color, InstancedMesh, ShaderMaterial } from 'three';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport { Text } from '@react-three/drei';\r\n\r\n\r\n// Circuit pattern vertex shader\r\nconst circuitVertexShader = `\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\n// Circuit pattern fragment shader\r\nconst circuitFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  \r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  // Simple hash function\r\n  float hash(vec2 p) {\r\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\r\n  }\r\n  \r\n  void main() {\r\n    // Basic circuit pattern\r\n    vec2 gridPos = floor(vPosition.xy * 10.0);\r\n    float circuit = hash(gridPos) > 0.7 ? 1.0 : 0.0;\r\n    \r\n    // Circuit lines\r\n    vec2 grid = fract(vPosition.xy * 10.0);\r\n    float line = smoothstep(0.95, 0.98, max(grid.x, grid.y));\r\n    \r\n    // Flowing effect on circuit lines\r\n    float flow = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Combine effects\r\n    vec3 finalColor = color * (0.5 + 0.5 * circuit + line * flow);\r\n    \r\n    // Add rim lighting\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    finalColor += color * rim * 0.5;\r\n    \r\n    gl_FragColor = vec4(finalColor, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field vertex shader for hover effect\r\nconst forceFieldVertexShader = `\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    \r\n    // Add subtle pulsating effect\r\n    float pulse = sin(time * 2.0) * 0.05 + 1.05;\r\n    vec3 newPosition = position * pulse;\r\n    \r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field fragment shader for hover effect\r\nconst forceFieldFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    // Create flowing wave pattern\r\n    float wave = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Rim effect for sphere edge glow\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    \r\n    // Transparency based on rim and wave pattern\r\n    float alpha = rim * 0.7 * wave;\r\n    \r\n    // Final color with slight pulsation\r\n    float pulse = sin(time * 3.0) * 0.2 + 0.8;\r\n    vec3 finalColor = color * pulse * (0.5 + wave * 0.5);\r\n    \r\n    gl_FragColor = vec4(finalColor, alpha);\r\n  }\r\n`;\r\n\r\ninterface NodesInstancedProps {\r\n  nodes: ConstellationNode[];\r\n  nodePositions: NodePositions;\r\n  connections: { start: string; end: string }[];\r\n  overrideSelectedNodeId?: string;\r\n  onNodeClick?: (nodeId: string) => void;\r\n  clickableNodeIds?: string[];\r\n  isMinimap?: boolean; // Flag to indicate if this is used in the minimap\r\n isInitialChoicePhase: boolean;\r\n triumvirateActive: boolean;\r\n triumvirateNodes: string[];\r\n positionSynchronizer: {\r\n   updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n   getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n}\r\n\r\n// Define base colors for each triad - match exact character names from nodesSlice.ts\r\nconst triadColors = {\r\n  LastHuman: new Color('#ff6666'), // Reddish\r\n  Archaeologist: new Color('#66ff66'), // Greenish\r\n  Algorithm: new Color('#6666ff'), // Bluish\r\n};\r\n\r\n// Create a more permissive lookup that doesn't rely on exact matching\r\n// Helper to get color for node based on character with proper type safety\r\nconst getNodeColor = (character: string | undefined): Color => {\r\n  if (!character) return new Color('#ffffff');\r\n  \r\n  // Direct lookup with type safety\r\n  if (character === 'LastHuman') return triadColors.LastHuman;\r\n  if (character === 'Archaeologist') return triadColors.Archaeologist;\r\n  if (character === 'Algorithm') return triadColors.Algorithm;\r\n  \r\n  // Case-insensitive lookup as fallback\r\n  const lowerChar = character.toLowerCase();\r\n  if (lowerChar.includes('human')) return triadColors.LastHuman;\r\n  if (lowerChar.includes('arch')) return triadColors.Archaeologist;\r\n  if (lowerChar.includes('algo')) return triadColors.Algorithm;\r\n  \r\n  // Default\r\n  console.warn(`Unknown character type: ${character}, using default color`);\r\n  return new Color('#ffffff');\r\n};\r\n\r\n\r\nexport const NodesInstanced = forwardRef<InstancedMesh, NodesInstancedProps>((props, ref) => {\r\n  const {\r\n    nodes,\r\n    nodePositions,\r\n    connections,\r\n    overrideSelectedNodeId,\r\n    onNodeClick,\r\n    clickableNodeIds,\r\n    isInitialChoicePhase,\r\n    positionSynchronizer,\r\n    triumvirateActive,\r\n    triumvirateNodes,\r\n  } = props;\r\n  const dispatch = useDispatch<AppDispatch>();\r\n  \r\n  const hoveredNodeId = useSelector(selectHoveredNodeId);\r\n  const reduxSelectedNodeId = useSelector(selectSelectedNodeId);\r\n  const selectedNodeId = overrideSelectedNodeId ?? reduxSelectedNodeId;\r\n\r\n  const triumvirateNodeSet = useMemo(() => new Set(triumvirateNodes), [triumvirateNodes]);\r\n  const triumvirateColorMap = useMemo(() => ({\r\n    'arch-discovery': new Color('#66ff66'), // Green\r\n    'algo-awakening': new Color('#6666ff'), // Blue\r\n    'human-discovery': new Color('#ff6666'), // Red\r\n  }), []);  const connectedNodeIds = useMemo(() => {\r\n    if (isInitialChoicePhase || triumvirateActive) return triumvirateNodeSet;\r\n    if (!selectedNodeId) return new Set<string>();\r\n    const connected = new Set<string>();\r\n    connections.forEach((c) => {\r\n      if (c.start === selectedNodeId) connected.add(c.end);\r\n      if (c.end === selectedNodeId) connected.add(c.start);\r\n    });\r\n    return connected;\r\n  }, [selectedNodeId, connections, triumvirateActive, triumvirateNodeSet, isInitialChoicePhase]);\r\n\r\n  // State to track current node positions for positioning groups\r\n  const [groupPositions, setGroupPositions] = useState<{[key: string]: [number, number, number]}>({});\r\n\r\n  // Create refs for accessing objects in the scene\r\n  const materialRefs = useRef<ShaderMaterial[]>([]);\r\n  const forceFieldMaterialRefs = useRef<ShaderMaterial[]>([]);\r\n  const nodeMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  const forceFieldMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  \r\n  // Store original positions for the noise animation\r\n  const originalPositions = useRef<{[key: string]: [number, number, number]}>({});\r\n  \r\n  // Initialize original positions\r\n  useMemo(() => {\r\n    nodes.forEach(node => {\r\n      const position = nodePositions[node.id] || [0, 0, 0];\r\n      originalPositions.current[node.id] = [...position];\r\n    });\r\n  }, [nodes, nodePositions]);\r\n  \r\n  \r\n  // Update shader time uniform and apply noise movement with optimized LOD\r\n  // Frame counter for throttling updates\r\n  const frameCount = useRef(0);\r\n  const lastUpdatePositionsTime = useRef(0);\r\n  const lastUpdateMaterialsTime = useRef(0);\r\n  \r\n  // Enhanced optimization: Using variable update rates based on priority\r\n  useFrame((state): void => {\r\n    const time = state.clock.elapsedTime;\r\n    frameCount.current += 1;\r\n    \r\n    // Get synchronized positions from the position synchronizer\r\n    const currentPositions = positionSynchronizer.updatePositions(time, props.isMinimap);\r\n      \r\n    // All nodes are always visible, no need for validation\r\n    \r\n    // Time-based throttling for shader updates\r\n    const shouldUpdateMaterials = time - lastUpdateMaterialsTime.current > 0.05; // 50ms\r\n    if (shouldUpdateMaterials) {\r\n      lastUpdateMaterialsTime.current = time;\r\n      \r\n      // Update time uniforms on important materials only\r\n      const importantMaterials = materialRefs.current.filter((_, i) => {\r\n        const node = nodes[i];\r\n        return node && (\r\n          node.id === selectedNodeId ||\r\n          node.id === hoveredNodeId ||\r\n          connections.some(c => c.start === node.id || c.end === node.id)\r\n        );\r\n      });\r\n      \r\n      // Batch updates to reduce overhead\r\n      importantMaterials.forEach(material => {\r\n        if (material?.uniforms?.time) {\r\n          material.uniforms.time.value = time;\r\n        }\r\n      });\r\n      \r\n      // Update force field materials only for selected/hovered nodes\r\n      const importantForceFields = forceFieldMaterialRefs.current.filter((_, i) => {\r\n        const node = nodes[i];\r\n        return node && (node.id === selectedNodeId || node.id === hoveredNodeId);\r\n      });\r\n      \r\n      importantForceFields.forEach(material => {\r\n        if (material?.uniforms?.time) {\r\n          material.uniforms.time.value = time;\r\n        }\r\n      });\r\n    }\r\n    \r\n    // SYNC FIX: Ensure we update positions on the same frames as ConnectionsBatched\r\n    // This is critical for keeping nodes and connections aligned\r\n    const timeSinceLastPositionUpdate = time - lastUpdatePositionsTime.current;\r\n    // CRITICAL SYNC FIX: Use same update interval as ConnectionsBatched\r\n    const UPDATE_INTERVAL = 0.15; // 150ms in seconds\r\n    const shouldUpdatePositions = timeSinceLastPositionUpdate >= UPDATE_INTERVAL;\r\n    \r\n    if (shouldUpdatePositions) {\r\n      lastUpdatePositionsTime.current = time;\r\n      \r\n      // Apply organic movement to nodes using noise - with optimized calculations\r\n      // And apply pulsing effect for designated starting nodes\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        const nodeMesh = nodeMeshRefs.current[i] as THREE.Mesh; // Cast for scale property\r\n        \r\n        if (!nodeMesh) {\r\n          continue; // Skip if mesh doesn't exist\r\n        }\r\n        \r\n        const origPos = originalPositions.current[node.id];\r\n        if (!origPos) {\r\n          continue; // Skip if no original position\r\n        }\r\n\r\n        // Determine if this node is a designated starting node for pulsing logic\r\n        let isDesignatedStartingNodeForPulse = false;\r\n        if (isInitialChoicePhase && !props.isMinimap) { // Pulse only in main view during initial phase\r\n          if (node.contentSource === 'arch-discovery.md' ||\r\n              node.contentSource === 'algo-awakening.md' ||\r\n              node.contentSource === 'human-discovery.md') {\r\n            isDesignatedStartingNodeForPulse = true;\r\n          }\r\n        }\r\n\r\n        if (isDesignatedStartingNodeForPulse) {\r\n          const pulseSpeed = 3;\r\n          const pulseAmount = 0.15; // Scale pulsates between 0.85 and 1.15 approx.\r\n          const baseScale = 1.0;\r\n          const targetScale = baseScale + Math.sin(time * pulseSpeed) * pulseAmount;\r\n          nodeMesh.scale.set(targetScale, targetScale, targetScale);\r\n        } else {\r\n          // Ensure non-pulsing nodes (or minimap nodes, or when not in initial phase) have normal scale\r\n          const baseScale = props.isMinimap ? 0.5 : 1.0;\r\n          if (nodeMesh.scale.x !== baseScale || nodeMesh.scale.y !== baseScale || nodeMesh.scale.z !== baseScale) {\r\n            nodeMesh.scale.set(baseScale, baseScale, baseScale);\r\n          }\r\n        }\r\n        \r\n        // Always update all nodes\r\n        const shouldUpdate = true;\r\n        const isImportantNode = node.id === selectedNodeId ||\r\n                               node.id === hoveredNodeId ||\r\n                               connectedNodeIds.has(node.id);\r\n        \r\n        // Always show the node\r\n        nodeMesh.visible = true;\r\n        \r\n        // Show force field only for important nodes\r\n        const forceMesh = forceFieldMeshRefs.current[i];\r\n        if (forceMesh) {\r\n          forceMesh.visible = isImportantNode;\r\n        }\r\n            if (shouldUpdate) {\r\n          // CRITICAL FIX: Since groups are positioned, mesh stays at origin within group\r\n          const syncedPos = currentPositions[node.id];\r\n          \r\n          if (syncedPos) {\r\n            // Don't update mesh position - it's handled by group positioning in render\r\n            // Just ensure the mesh is visible and at origin within its group\r\n            nodeMesh.position.set(0, 0, 0);\r\n          } else {\r\n            // Fallback to original position if synchronized position is not available\r\n            console.warn(`NodesInstanced: Missing synchronized position for node ${node.id}`);\r\n            nodeMesh.position.set(0, 0, 0);\r\n          }\r\n          \r\n          // Update force field position only if it exists and node is important\r\n          const forceMesh = forceFieldMeshRefs.current[i];\r\n          if (forceMesh && isImportantNode) {\r\n            forceMesh.visible = true;\r\n            forceMesh.position.set(0, 0, 0); // Also at origin within group\r\n          } else if (forceMesh) {\r\n            forceMesh.visible = false;\r\n          }        }\r\n      }\r\n      \r\n      // Update group positions for next render\r\n      setGroupPositions({ ...currentPositions });\r\n      \r\n      // No need to update visible node count since we removed the display\r\n    }\r\n  });\r\n  \r\n  // Create a dummy instanced mesh to maintain API compatibility with ref\r\n  // while still using individual meshes for better control\r\n  return (\r\n    <group>\r\n      {/* This invisible instanced mesh is just for ref compatibility */}\r\n      {ref && (\r\n        <instancedMesh\r\n          ref={ref}\r\n          args={[\r\n            new THREE.BufferGeometry(),\r\n            new THREE.MeshBasicMaterial(),\r\n            0\r\n          ]}\r\n          visible={false}\r\n        />\r\n      )}\r\n      {nodes.map((node, index) => {\r\n        const isSelected = selectedNodeId === node.id;\r\n        const isConnected = connectedNodeIds.has(node.id);\r\n        const isHovered = hoveredNodeId === node.id;        let isDesignatedStartingNode = false;\r\n        let labelText = '';\r\n        \r\n        if (isInitialChoicePhase) {\r\n          if (node.contentSource === 'arch-discovery.md') {\r\n            isDesignatedStartingNode = true;\r\n            labelText = 'The Archaeologist';\r\n          } else if (node.contentSource === 'algo-awakening.md') {\r\n            isDesignatedStartingNode = true;\r\n            labelText = 'The Algorithm';\r\n          } else if (node.contentSource === 'human-discovery.md') {\r\n            isDesignatedStartingNode = true;\r\n            labelText = 'The Last Human';\r\n          }\r\n        }\r\n        \r\n        // Add triumvirate text labels\r\n        let triumvirateText = '';\r\n        if (triumvirateActive && triumvirateNodes.includes(node.id)) {\r\n          if (node.id === 'arch-discovery') {\r\n            triumvirateText = 'Discovery';\r\n          } else if (node.id === 'algo-awakening') {\r\n            triumvirateText = 'Awakening';\r\n          } else if (node.id === 'human-discovery') {\r\n            triumvirateText = 'Choice';\r\n          }\r\n        }\r\n        \r\n        // Calculate node color using our more permissive function\r\n        const nodeColor = getNodeColor(node.character).clone();\r\n        \r\n        // Apply color adjustments based on node state\r\n        if (isInitialChoicePhase) {\r\n          if (triumvirateNodeSet.has(node.id)) {\r\n            const color = triumvirateColorMap[node.id as keyof typeof triumvirateColorMap];\r\n            if (color) {\r\n              nodeColor.set(color);\r\n            }\r\n          } else {\r\n            nodeColor.multiplyScalar(0.2); // Dim non-triumvirate nodes\r\n          }\r\n        }\r\n        else if (triumvirateActive) {\r\n          if (!triumvirateNodeSet.has(node.id)) {\r\n            nodeColor.multiplyScalar(0.2); // Dim non-triumvirate nodes\r\n          }\r\n        } else if (isSelected) {\r\n          nodeColor.multiplyScalar(1.5); // Lighter shade\r\n        } else if (isConnected) {\r\n          nodeColor.multiplyScalar(0.5); // Darker shade\r\n        } else if (isHovered) {\r\n          nodeColor.multiplyScalar(1.2); // Slightly lighter for hover\r\n        } else if (isDesignatedStartingNode) {\r\n          // Potentially give starting nodes a distinct look even if not selected/hovered,\r\n          // or this could be handled by the pulsing effect later.\r\n          // For now, let's ensure they don't get dimmed like 'isConnected' if they are also connected.\r\n          // This logic might need refinement based on how visual effects are combined.\r\n          // If it's a starting node, we might want its base color to be more prominent.\r\n          // Example: nodeColor.multiplyScalar(1.1); // Slightly brighter if it's a starting node\r\n        }        // The main node group's position is determined by synchronized positions,\r\n        // and individual elements within this group (like the sphere and text) will be positioned relatively.\r\n        const groupPosition = groupPositions[node.id] || originalPositions.current[node.id] || [0, 0, 0];\r\n        \r\n        return (\r\n          <group\r\n            key={node.id}            position={groupPosition} // Position group at the node's current position\r\n            userData={{ nodeId: node.id }} // Add nodeId to userData for connection positioning\r\n          >{isDesignatedStartingNode && isInitialChoicePhase && !triumvirateActive && !props.isMinimap && labelText && node.visitCount === 0 && (\r\n              <Text\r\n                position={[0, 2.2, 0]} // Position higher above the node sphere\r\n                fontSize={0.4} // Larger font size for better visibility\r\n                color=\"white\"\r\n                anchorX=\"center\"\r\n                anchorY=\"middle\"\r\n                outlineWidth={0.03}\r\n                outlineColor=\"#000000\"\r\n                material-depthTest={false} // Ensures text is visible\r\n                material-transparent={true}\r\n                fontWeight=\"bold\"\r\n              >\r\n                {labelText}\r\n              </Text>\r\n            )}            {/* Triumvirate text labels */}\r\n            {triumvirateActive && !props.isMinimap && triumvirateText && (\r\n              <Text\r\n                position={[0, 2.2, 0]} // Position above the node sphere (relative to the group)\r\n                fontSize={0.6} // Larger font size for better visibility\r\n                color=\"white\"\r\n                anchorX=\"center\"\r\n                anchorY=\"middle\"\r\n                outlineWidth={0.05}\r\n                outlineColor=\"#000000\"\r\n                material-depthTest={false} // Ensures text is visible\r\n                material-transparent={true}\r\n                fontWeight=\"bold\"\r\n              >\r\n                {triumvirateText}\r\n              </Text>\r\n            )}\r\n\r\n            {/* Force field effect (only visible when hovered or selected) */}\r\n            {(isHovered || isSelected) && (\r\n              <mesh\r\n                ref={(mesh) => {\r\n                  if (mesh) {\r\n                    forceFieldMeshRefs.current[index] = mesh;\r\n                  }\r\n                }}\r\n                // Position is now relative to the parent group, so [0,0,0] for the force field center\r\n                position={[0, 0, 0]}>\r\n                <sphereGeometry args={[1.4, 16, 16]} />\r\n                <shaderMaterial\r\n                  ref={(material) => {\r\n                    if (material) {\r\n                      forceFieldMaterialRefs.current[index] = material;\r\n                    }\r\n                  }}\r\n                  vertexShader={forceFieldVertexShader}\r\n                  fragmentShader={forceFieldFragmentShader}\r\n                  uniforms={{\r\n                    color: { value: nodeColor },\r\n                    time: { value: 0 }\r\n                  }}\r\n                  transparent={true}\r\n                  depthWrite={false}\r\n                />\r\n              </mesh>\r\n            )}\r\n            \r\n            {/* Main node mesh */}\r\n            <mesh\r\n              ref={(mesh) => {\r\n                if (mesh) {\r\n                  nodeMeshRefs.current[index] = mesh;\r\n                }\r\n              }}\r\n              // Position is now relative to the parent group, so [0,0,0] for the node sphere center\r\n              position={[0, 0, 0]}\r\n              onClick={(e: ThreeEvent<MouseEvent>) => {\r\n                if (e.stopPropagation) e.stopPropagation();\r\n\r\n                // Emit custom event to hide tooltip when a node is clicked\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n\r\n                if (isInitialChoicePhase) {\r\n                  if (isDesignatedStartingNode) {\r\n                    // Dispatch actions in sequence with proper error handling\r\n                    try {\r\n                      dispatch(nodeSelected(node.id));\r\n                      dispatch(visitNode(node.id));\r\n                      dispatch(setViewMode('reading'));\r\n                      dispatch(navigateToNode({\r\n                        nodeId: node.id,\r\n                        character: node.character,\r\n                        temporalValue: node.temporalValue,\r\n                        attractors: node.strangeAttractors,\r\n                      }));\r\n                    } catch (error) {\r\n                      console.error('Navigation error:', error);\r\n                    }\r\n                  }\r\n                  return; // Exit early if in initial choice phase\r\n                }\r\n                // Normal click logic (outside initial choice phase)\r\n                if (onNodeClick) { // This path is typically for MiniConstellation\r\n                  if (clickableNodeIds && !clickableNodeIds.includes(node.id)) {\r\n                    return;\r\n                  }\r\n                  onNodeClick(node.id);\r\n                } else { // This path is for the main ConstellationView\r\n                  if (selectedNodeId === null) { // If no node is selected, any node can be clicked\r\n                    dispatch(nodeSelected(node.id));\r\n                    dispatch(visitNode(node.id));\r\n                    dispatch(setViewMode('reading'));\r\n                    dispatch(navigateToNode({\r\n                      nodeId: node.id,\r\n                      character: node.character,\r\n                      temporalValue: node.temporalValue,\r\n                      attractors: node.strangeAttractors,\r\n                    }));\r\n                  } else { // If a node is already selected, only connected nodes can be clicked\r\n                    const isConnectedToCurrentSelected = connections.some(\r\n                      (c) =>\r\n                        (c.start === selectedNodeId && c.end === node.id) ||\r\n                        (c.start === node.id && c.end === selectedNodeId)\r\n                    );\r\n                    if (isConnectedToCurrentSelected) {\r\n                      dispatch(nodeSelected(node.id));\r\n                      dispatch(visitNode(node.id));\r\n                      dispatch(setViewMode('reading'));\r\n                      dispatch(navigateToNode({\r\n                        nodeId: node.id,\r\n                        character: node.character,\r\n                        temporalValue: node.temporalValue,\r\n                        attractors: node.strangeAttractors,\r\n                      }));\r\n                    }\r\n                  }\r\n                }\r\n              }}\r\n              onPointerOver={(e: ThreeEvent<PointerEvent>) => {\r\n                if (props.isMinimap) return; // Do not show hover effects in minimap\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                if (node.id !== hoveredNodeId) {\r\n                  dispatch(nodeHovered(node.id));\r\n                  \r\n                  // Determine if this node is clickable using the same logic as onClick\r\n                  let isClickable = false;\r\n                  \r\n                  if (triumvirateActive) {\r\n                    isClickable = triumvirateNodeSet.has(node.id);\r\n                  } else if (isInitialChoicePhase) {\r\n                    // In initial choice phase, only designated starting nodes are clickable\r\n                    isClickable = isDesignatedStartingNode;\r\n                  } else {\r\n                    // Normal click logic (outside initial choice phase)\r\n                    if (onNodeClick) { // This path is typically for MiniConstellation\r\n                      isClickable = !clickableNodeIds || clickableNodeIds.includes(node.id);\r\n                    } else { // This path is for the main ConstellationView\r\n                      if (selectedNodeId === null) { // If no node is selected, any node can be clicked\r\n                        isClickable = true;\r\n                      } else { // If a node is already selected, only connected nodes can be clicked\r\n                        const isConnectedToCurrentSelected = connections.some(\r\n                          (c) =>\r\n                            (c.start === selectedNodeId && c.end === node.id) ||\r\n                            (c.start === node.id && c.end === selectedNodeId)\r\n                        );\r\n                        isClickable = isConnectedToCurrentSelected;\r\n                      }\r\n                    }\r\n                  }\r\n                  \r\n                  // Emit custom event for tooltip positioning\r\n                  // Just use client coordinates from the event directly\r\n                  const nodeHoverEvent = new CustomEvent('node-hover', {\r\n                    detail: {\r\n                      position: {\r\n                        x: e.clientX,\r\n                        y: e.clientY - 40 // Position tooltip 40px above cursor\r\n                      },\r\n                      nodeId: node.id,\r\n                      isClickable: isClickable\r\n                    }\r\n                  });\r\n                  window.dispatchEvent(nodeHoverEvent);\r\n                }\r\n              }}\r\n              onPointerOut={(e: ThreeEvent<PointerEvent>) => {\r\n                if (props.isMinimap) return;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                \r\n                // Emit custom event for tooltip hiding\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n              }}\r\n              \r\n              // Fix for stuck hover: Add pointer leave event\r\n              onPointerLeave={(e: ThreeEvent<PointerEvent>) => {\r\n                if (props.isMinimap) return;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                \r\n                // Emit custom event for tooltip hiding\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n              }}\r\n            >\r\n              {/* Use lower poly geometry for distant nodes */}\r\n              {/* Performance optimization: Use lower poly geometry for distant nodes */}\r\n              {!isSelected && !isHovered ? (\r\n                <octahedronGeometry args={[1.0, 0]} /> // Lower poly for distant nodes - doubled size\r\n              ) : (\r\n                <sphereGeometry args={[1.0, 8, 8]} /> // Higher detail for selected/hovered - doubled size\r\n              )}\r\n              <shaderMaterial\r\n                ref={(material) => {\r\n                  if (material) {\r\n                    // Store reference to this material\r\n                    materialRefs.current[index] = material;\r\n                  }\r\n                }}\r\n                vertexShader={circuitVertexShader}\r\n                fragmentShader={circuitFragmentShader}\r\n                uniforms={{\r\n                  color: { value: nodeColor },\r\n                  time: { value: 0 }\r\n                }}\r\n              />\r\n            </mesh>\r\n          </group>\r\n        );\r\n      })}\r\n      \r\n      {/* Performance display removed */}\r\n    </group>\r\n  );\r\n});","import React, { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { Connection, NodePositions } from '../../types';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\ninterface ConnectionsBatchedProps {\r\n  connections: Connection[];\r\n  nodePositions: NodePositions;\r\n  selectedNodeId?: string | null;\r\n  hoveredNodeId?: string | null;\r\n  positionSynchronizer: {\r\n    updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n    getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n  isMinimap?: boolean;\r\n  triumvirateActive?: boolean;\r\n  triumvirateNodes?: string[];\r\n}\r\n\r\n// --- Reusable utility objects to prevent reallocation in the render loop ---\r\nconst baseColor = new THREE.Color();\r\nconst pulseColor = new THREE.Color();\r\n\r\nexport const ConnectionsBatched: React.FC<ConnectionsBatchedProps> = (props) => {\r\n    const { connections, nodePositions, selectedNodeId, hoveredNodeId, positionSynchronizer, isMinimap } = props;\r\n\r\n    const lineSegmentsRef = useRef<THREE.LineSegments>(null!);\r\n    const geometryRef = useRef<THREE.BufferGeometry>(null!);\r\n\r\n    // This effect sets up the geometry and its attributes once.\r\n    useEffect(() => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(connections.length * 2 * 3);\r\n        const colors = new Float32Array(connections.length * 2 * 3);\r\n\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        \r\n        if (lineSegmentsRef.current) {\r\n            lineSegmentsRef.current.geometry = geometry;\r\n        }\r\n        geometryRef.current = geometry;\r\n\r\n        return () => {\r\n            geometry.dispose();\r\n        }\r\n    }, [connections.length]);\r\n\r\n    useFrame((state) => {\r\n        if (!geometryRef.current) return;\r\n\r\n        const positionAttribute = geometryRef.current.attributes.position as THREE.BufferAttribute;\r\n        const colorAttribute = geometryRef.current.attributes.color as THREE.BufferAttribute;\r\n        \r\n        // Use dynamic positions for the main view, and static for the minimap\r\n        const currentPositions = isMinimap ? nodePositions : positionSynchronizer.updatePositions(state.clock.elapsedTime);\r\n\r\n        for (let i = 0; i < connections.length; i++) {\r\n            const connection = connections[i];\r\n            const startPos = currentPositions[connection.source];\r\n            const endPos = currentPositions[connection.target];\r\n\r\n            if (startPos && endPos) {\r\n                positionAttribute.setXYZ(i * 2, startPos[0], startPos[1], startPos[2]);\r\n                positionAttribute.setXYZ(i * 2 + 1, endPos[0], endPos[1], endPos[2]);\r\n            }\r\n\r\n            const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n            const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n            const isAvailable = !isSelected && !isHovered && selectedNodeId && (connection.source === selectedNodeId || connection.target === selectedNodeId);\r\n\r\n            let finalColor;\r\n\r\n            if (isSelected) {\r\n                finalColor = baseColor.set(0x00bfff);\r\n            } else if (isHovered) {\r\n                finalColor = baseColor.set(0x88ccff);\r\n            } else if (isAvailable) {\r\n                const pulse = 0.5 + 0.5 * Math.sin(state.clock.elapsedTime * 5);\r\n                finalColor = pulseColor.set(0x4488ff).lerp(baseColor.set(0xffffff), pulse);\r\n            } else {\r\n                finalColor = baseColor.set(0xffffff); // Default to white\r\n            }\r\n            \r\n            colorAttribute.setXYZ(i * 2, finalColor.r, finalColor.g, finalColor.b);\r\n            colorAttribute.setXYZ(i * 2 + 1, finalColor.r, finalColor.g, finalColor.b);\r\n        }\r\n\r\n        positionAttribute.needsUpdate = true;\r\n        // Always update colors for simplicity, as the available check is complex\r\n        colorAttribute.needsUpdate = true;\r\n    });\r\n\r\n    return (\r\n        <lineSegments ref={lineSegmentsRef}>\r\n            {/* The geometry is created and managed in the useEffect/useFrame hooks */}\r\n            <lineBasicMaterial vertexColors={true} toneMapped={false} fog={false} />\r\n        </lineSegments>\r\n    );\r\n};\r\n"],"names":["circuitVertexShader","circuitFragmentShader","forceFieldVertexShader","forceFieldFragmentShader","triadColors","Color","getNodeColor","character","lowerChar","NodesInstanced","forwardRef","props","ref","nodes","nodePositions","connections","overrideSelectedNodeId","onNodeClick","clickableNodeIds","isInitialChoicePhase","positionSynchronizer","triumvirateActive","triumvirateNodes","dispatch","useDispatch","hoveredNodeId","useSelector","selectHoveredNodeId","reduxSelectedNodeId","selectSelectedNodeId","selectedNodeId","triumvirateNodeSet","useMemo","triumvirateColorMap","connectedNodeIds","connected","c","groupPositions","setGroupPositions","useState","materialRefs","useRef","forceFieldMaterialRefs","nodeMeshRefs","forceFieldMeshRefs","originalPositions","node","position","frameCount","lastUpdatePositionsTime","lastUpdateMaterialsTime","useFrame","state","time","currentPositions","_","i","material","_a","nodeMesh","isDesignatedStartingNodeForPulse","targetScale","baseScale","isImportantNode","forceMesh","jsx","THREE.BufferGeometry","THREE.MeshBasicMaterial","index","isSelected","isConnected","isHovered","isDesignatedStartingNode","labelText","triumvirateText","nodeColor","color","groupPosition","jsxs","Text","mesh","e","nodeUnhoverEvent","nodeSelected","visitNode","setViewMode","navigateToNode","error","nodeHovered","isClickable","nodeHoverEvent","nodeUnhovered","baseColor","THREE.Color","pulseColor","ConnectionsBatched","isMinimap","lineSegmentsRef","geometryRef","useEffect","geometry","positions","colors","THREE.Float32BufferAttribute","positionAttribute","colorAttribute","connection","startPos","endPos","isAvailable","finalColor","pulse"],"mappings":"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"}