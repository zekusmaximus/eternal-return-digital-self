{"version":3,"mappings":"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","names":["useNodeState","nodeId","dispatch","useDispatch","appliedTransformations","setAppliedTransformations","useState","newlyTransformed","setNewlyTransformed","appliedNodesRef","useRef","lastTransformationDispatchRef","currentNodeId","useSelector","selectCurrentNodeId","targetNodeId","node","state","selectNodeById","allNodes","revisitCount","selectNodeRevisitCount","readerState","navigateTo","useCallback","id","nodeData","navigateToNode","visitNode","setViewMode","revealNodeConnection","sourceId","targetId","revealConnection","engageWithAttractor","attractor","engageAttractor","applyNodeTransformation","transformation","applyTransformation","neighbors","useMemo","allTransformations","baseContent","transformations","transformationEngine","t","error","transformedContent","fullyTransformedContent","wrappedContent","transformationService","useEffect","timer","now","nodeKey","toKeep","key","applyJourneyTransformations","patternTransformations","patternBasedRule","evaluateTransformations","context","_a","char","__vitePreload","contentVariantService","n","selectedContent","updateContentVariant","evaluateCondition","condition","isContentCorrupted","content","indicator","finalTextCleanup","text","cleaned","line","TransformationAnimationContainer","children","isNewlyTransformed","containerRef","contentRef","animationState","setAnimationState","transformationCount","setTransformationCount","renderAttempt","setRenderAttempt","measurements","setMeasurements","contentVisible","setContentVisible","prev","useLayoutEffect","measureElement","style","rect","newMeasurements","isVisible","timeoutId","observer","mutations","getAnimationClass","hasReplacements","hasEmphasis","hasExpansions","getTransformationDescription","typeCount","descriptions","hasChangedTransformations","jsxs","jsx"],"ignoreList":[],"sources":["../../src/hooks/useNodeState.ts","../../src/utils/contentSanitizer.ts","../../src/components/NodeView/TransformationAnimationContainer.tsx"],"sourcesContent":["/**\r\n * Custom hook for managing node state and transformations\r\n * Provides utilities for accessing, navigating, and transforming nodes\r\n */\r\n\r\nimport { useCallback, useEffect, useMemo, useState, useRef } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  selectNodeById,\r\n  visitNode,\r\n  revealConnection,\r\n  applyTransformation,\r\n  evaluateTransformations,\r\n  applyJourneyTransformations,\r\n  updateContentVariant\r\n} from '../store/slices/nodesSlice';\r\nimport {\r\n  navigateToNode,\r\n  engageAttractor,\r\n  selectCurrentNodeId,\r\n  selectNodeRevisitCount\r\n} from '../store/slices/readerSlice';\r\nimport { setViewMode } from '../store/slices/interfaceSlice';\r\nimport { StrangeAttractor, TransformationRule, TransformationCondition, TextTransformation } from '../types';\r\nimport { RootState } from '../store/types';\r\nimport { transformationEngine } from '../services/TransformationEngine';\r\nimport { transformationService } from '../services/TransformationService';\r\nimport { Character } from '../types';\r\n\r\n// Import the CSS for transformations\r\nimport '../styles/NarramorphTransformations.css';\r\n\r\n/**\r\n * Custom hook for node state management and transformations\r\n * @param nodeId Optional node ID to focus on\r\n */\r\nexport const useNodeState = (nodeId?: string) => {\r\n  const dispatch = useDispatch();\r\n  // Track applied transformations for transitions\r\n  const [appliedTransformations, setAppliedTransformations] = useState<TextTransformation[]>([]);\r\n  // Track if transformations were just applied for animation\r\n  const [newlyTransformed, setNewlyTransformed] = useState(false);  // Track which nodes have had transformations applied to prevent repeated dispatches\r\n  const appliedNodesRef = useRef<Set<string>>(new Set());\r\n  // Throttle transformation dispatches to prevent excessive calls\r\n  const lastTransformationDispatchRef = useRef<number>(0);\r\n\r\n  // Get current node ID if not provided\r\n  const currentNodeId = useSelector(selectCurrentNodeId);\r\n  const targetNodeId = nodeId || currentNodeId;\r\n\r\n  // Select node data\r\n  const node = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeById(state, targetNodeId) : null\r\n  );\r\n\r\n  // Select all nodes to access any node data\r\n  const allNodes = useSelector((state: RootState) => state.nodes.data);\r\n\r\n  // Get revisit count\r\n  const revisitCount = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeRevisitCount(state, targetNodeId) : 0\r\n  );\r\n\r\n  // Get reader state for transformation evaluation\r\n  // Used in evaluateTransformations and evaluateCondition\r\n  const readerState = useSelector((state: RootState) => state.reader);\r\n  \r\n  // Navigate to a node\r\n  const navigateTo = useCallback((id: string) => {\r\n    const nodeData = allNodes[id];\r\n    \r\n    if (nodeData) {\r\n      // Record navigation in reader path with required properties\r\n      dispatch(navigateToNode({\r\n        nodeId: id,\r\n        character: nodeData.character,\r\n        temporalValue: nodeData.temporalValue,\r\n        attractors: nodeData.strangeAttractors\r\n      }));\r\n      \r\n      // Record visit in node state\r\n      dispatch(visitNode(id));\r\n      \r\n      // Switch to reading view\r\n      dispatch(setViewMode('reading'));\r\n      \r\n      // This would be where we load the node content in a real implementation\r\n      // For now, we'll just log it\r\n      console.log(`Navigating to node: ${id}`);\r\n    } else {\r\n      console.error(`Could not navigate to node: ${id} - node data not found`);\r\n    }\r\n  }, [dispatch, allNodes]);\r\n  \r\n  // Reveal a new connection\r\n  const revealNodeConnection = useCallback((sourceId: string, targetId: string) => {\r\n    dispatch(revealConnection({ nodeId: sourceId, targetId }));\r\n  }, [dispatch]);\r\n  \r\n  // Engage with a strange attractor\r\n  const engageWithAttractor = useCallback((attractor: StrangeAttractor) => {\r\n    dispatch(engageAttractor(attractor));\r\n  }, [dispatch]);\r\n  \r\n  // Apply a transformation to the node's content\r\n  const applyNodeTransformation = useCallback((\r\n    nodeId: string, \r\n    transformation: TransformationRule\r\n  ) => {\r\n    dispatch(applyTransformation({ nodeId, transformation }));\r\n  }, [dispatch]);\r\n  \r\n  // Get neighboring nodes based on revealed connections\r\n  const neighbors = useMemo(() => {\r\n    if (!node) return [];\r\n    return node.revealedConnections;\r\n  }, [node]);  // Calculate all transformations using the new master integration method\r\n  const allTransformations = useMemo(() => {\r\n    // EMERGENCY FIX: Use original content to prevent recursive transformations\r\n    const baseContent = node?.originalContent || node?.currentContent;\r\n    if (!baseContent) return [];\r\n    \r\n    // Use the new master transformation coordination method\r\n    // This automatically handles character bleed, journey patterns, and node rules\r\n    // with proper priority ordering, deduplication, and caching\r\n    try {\r\n      // Pass all nodes from Redux store for better context\r\n      const transformations = transformationEngine.calculateAllTransformations(\r\n        baseContent, // EMERGENCY FIX: Always use original content\r\n        node,\r\n        readerState,\r\n        allNodes\r\n      );\r\n      \r\n      console.log(`[useNodeState] Master transformation integration calculated ${transformations.length} transformations for node ${node.id}:`, {\r\n        characterBleed: transformations.filter(t => t.priority === 'high' && (t.type === 'emphasize' || t.type === 'fragment')).length,\r\n        journeyPatterns: transformations.filter(t => t.priority === 'high' && t.type !== 'emphasize' && t.type !== 'fragment').length,\r\n        nodeRules: transformations.filter(t => t.priority !== 'high').length,\r\n        totalTransformations: transformations.length,\r\n        baseContentLength: baseContent.length,\r\n        usingOriginalContent: !!node?.originalContent\r\n      });\r\n      return transformations;\r\n      \r\n    } catch (error) {\r\n      console.error(`[useNodeState] Error in master transformation calculation for node ${node.id}:`, error);\r\n      return [];\r\n    }\r\n  }, [node, readerState, allNodes]);  // Generate transformed content using the new master integration method\r\n  const transformedContent = useMemo(() => {\r\n    // EMERGENCY FIX: Use original content to prevent recursive transformations\r\n    const baseContent = node?.originalContent || node?.currentContent;\r\n    if (!baseContent) return null;\r\n\r\n    try {\r\n      // Use the new master getTransformedContent method\r\n      // This automatically handles all transformation coordination, caching, and content application\r\n      const fullyTransformedContent = transformationEngine.getTransformedContent(\r\n        { ...node, currentContent: baseContent }, // EMERGENCY FIX: Force use of original content\r\n        readerState,\r\n        allNodes\r\n      );\r\n\r\n      // Add wrapper elements with transition classes if transformations were applied\r\n      if (fullyTransformedContent !== baseContent && allTransformations.length > 0) {\r\n        const wrappedContent = transformationService.wrapTransformedContent(\r\n          fullyTransformedContent,\r\n          allTransformations\r\n        );\r\n        \r\n        console.log(`[useNodeState] Applied transformation wrapping for node ${node.id}:`, {\r\n          originalLength: baseContent.length,\r\n          transformedLength: fullyTransformedContent.length,\r\n          wrappedLength: wrappedContent.length,\r\n          transformationsCount: allTransformations.length,\r\n          usingOriginalContent: !!node?.originalContent\r\n        });\r\n        \r\n        return wrappedContent;\r\n      }\r\n\r\n      return fullyTransformedContent;\r\n      \r\n    } catch (error) {\r\n      console.error(`[useNodeState] Error in master content transformation for node ${node.id}:`, error);\r\n      // EMERGENCY FALLBACK: Return original content on error\r\n      return baseContent;\r\n    }\r\n  }, [node, readerState, allNodes, allTransformations]);// Track transformation changes in a separate effect to prevent infinite loops\r\n  useEffect(() => {\r\n    if (!node || allTransformations.length === 0) return;\r\n\r\n    // Check if transformations actually changed\r\n    const transformationsChanged = JSON.stringify(appliedTransformations) !== JSON.stringify(allTransformations);\r\n    \r\n    if (transformationsChanged) {\r\n      setAppliedTransformations(allTransformations);\r\n      setNewlyTransformed(true);\r\n\r\n      // Enhanced logging for debugging the master integration\r\n      if (process.env.NODE_ENV === 'development') {\r\n        const characterBleedTransformations = allTransformations.filter(t => \r\n          t.priority === 'high' && (t.type === 'emphasize' || t.type === 'fragment')\r\n        );\r\n        const journeyPatternTransformations = allTransformations.filter(t => \r\n          t.priority === 'high' && t.type !== 'emphasize' && t.type !== 'fragment'\r\n        );\r\n        const nodeRuleTransformations = allTransformations.filter(t => \r\n          t.priority !== 'high'\r\n        );\r\n        \r\n        console.log(`[useNodeState] Applied master transformations for node ${node.id}:`, {\r\n          characterBleed: {\r\n            count: characterBleedTransformations.length,\r\n            types: characterBleedTransformations.map(t => t.type),\r\n            selectors: characterBleedTransformations.map(t => t.selector?.substring(0, 20)).filter(Boolean)\r\n          },\r\n          journeyPatterns: {\r\n            count: journeyPatternTransformations.length,\r\n            types: journeyPatternTransformations.map(t => t.type)\r\n          },\r\n          nodeRules: {\r\n            count: nodeRuleTransformations.length,\r\n            types: nodeRuleTransformations.map(t => t.type)\r\n          },\r\n          totalTransformations: allTransformations.length,\r\n          journeyContext: node.journeyContext,\r\n          character: node.character,\r\n          visitCount: node.visitCount\r\n        });\r\n      }\r\n    }\r\n  }, [node, allTransformations, appliedTransformations]);\r\n  \r\n  // Reset newly transformed flag after animation\r\n  useEffect(() => {\r\n    if (newlyTransformed) {\r\n      const timer = setTimeout(() => {\r\n        setNewlyTransformed(false);\r\n      }, 2000); // Match the animation duration\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [newlyTransformed]);  // Enhanced transformation application with master integration support\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId) return;\r\n    \r\n    // Throttle: Only allow transformation dispatches every 500ms\r\n    const now = Date.now();\r\n    if (now - lastTransformationDispatchRef.current < 500) {\r\n      return;\r\n    }\r\n    \r\n    // INFINITE LOOP PREVENTION: Check if content is already transformed\r\n    if (node.currentContent && (\r\n      node.currentContent.includes('data-transform-type') || \r\n      node.currentContent.includes('narramorph-') ||\r\n      node.currentContent.includes('[TransformationService]') ||\r\n      node.currentContent.includes('recursive loop detected') ||\r\n      node.currentContent.includes('temporal displacement')\r\n    )) {\r\n      console.log(`[useNodeState] Content already transformed for node ${targetNodeId}, skipping legacy transformation dispatch`);\r\n      return;\r\n    }\r\n    \r\n    // Create a unique key based on ONLY the navigation state, not content changes\r\n    const nodeKey = `${targetNodeId}-${node.visitCount}`;\r\n    \r\n    // Check if we've already applied transformations for this exact combination\r\n    if (appliedNodesRef.current.has(nodeKey)) {\r\n      console.log(`[useNodeState] Skipping already applied legacy transformations for ${nodeKey}`);\r\n      return;\r\n    }\r\n\r\n    // Only apply legacy transformations when the node actually changes\r\n    console.log(`[useNodeState] Applying legacy transformation dispatch for node ${targetNodeId} (visitCount: ${node.visitCount})`);\r\n    \r\n    // Update the last dispatch timestamp BEFORE dispatching\r\n    lastTransformationDispatchRef.current = now;\r\n    \r\n    // Mark this node+visit combination as processed BEFORE dispatching\r\n    appliedNodesRef.current.add(nodeKey);\r\n    \r\n    // Cleanup old entries to prevent memory leaks\r\n    if (appliedNodesRef.current.size > 50) {\r\n      const entries = Array.from(appliedNodesRef.current);\r\n      const toKeep = entries.slice(-25);\r\n      appliedNodesRef.current.clear();\r\n      toKeep.forEach(key => appliedNodesRef.current.add(key));\r\n    }\r\n\r\n    // Apply journey transformations (for backward compatibility with Redux store)\r\n    // Note: The master integration handles this automatically, but we keep this for store consistency\r\n    dispatch(applyJourneyTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n\r\n    // Apply basic visit-based transformations for backward compatibility\r\n    if (node.visitCount === 1) {\r\n      const basicTransformation: TransformationRule = {\r\n        condition: { visitCount: 1 },\r\n        transformations: [{\r\n          type: 'emphasize',\r\n          selector: 'first-paragraph',\r\n          emphasis: 'italic'\r\n        }]\r\n      };\r\n      applyNodeTransformation(targetNodeId, basicTransformation);\r\n    }\r\n\r\n    // Generate reduced pattern-based transformations to complement master integration\r\n    if (node.visitCount >= 2 && node.visitCount <= 3) {\r\n      const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n        readerState,\r\n        node\r\n      );\r\n      \r\n      if (patternTransformations.length > 0 && patternTransformations.length <= 2) {\r\n        const patternBasedRule: TransformationRule = {\r\n          condition: { visitCount: node.visitCount },\r\n          transformations: patternTransformations.slice(0, 1) // Limit to 1 to avoid conflicts with master integration\r\n        };\r\n        applyNodeTransformation(targetNodeId, patternBasedRule);\r\n      }\r\n    }\r\n\r\n    // Evaluate transformations against current reader state\r\n    dispatch(evaluateTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n  }, [targetNodeId, node, dispatch, applyNodeTransformation, readerState]);\r\n  \r\n  // Re-enable content variant update on visit count or journey change, with a visit cap for stability\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId || !node.enhancedContent) return;\r\n    // Only run if enhancedContent has at least one variant or base content\r\n    const hasContent =\r\n      (node.enhancedContent.base && node.enhancedContent.base.length > 0) ||\r\n      Object.keys(node.enhancedContent.visitCountVariants).length > 0 ||\r\n      Object.keys(node.enhancedContent.sectionVariants).length > 0;\r\n    if (!hasContent) return;\r\n\r\n    // Cap visit count to 5 for content variant selection\r\n    const cappedVisitCount = Math.min(node.visitCount, 5);\r\n\r\n    const context = {\r\n      visitCount: cappedVisitCount,\r\n      lastVisitedCharacter: readerState.path.sequence.length > 1 \r\n        ? allNodes[readerState.path.sequence[readerState.path.sequence.length - 2]]?.character \r\n        : undefined,\r\n      journeyPattern: readerState.path.sequence.slice(-5),\r\n      characterSequence: readerState.path.sequence\r\n        .slice(-5)\r\n        .map(id => allNodes[id]?.character)\r\n        .filter((char): char is Character => char !== undefined),\r\n      attractorsEngaged: readerState.path.attractorsEngaged || {},\r\n      recursiveAwareness: readerState.path.sequence.length > 0 \r\n        ? 1 - (new Set(readerState.path.sequence).size / readerState.path.sequence.length)\r\n        : 0\r\n    };\r\n\r\n    import('../services/ContentVariantService').then(({ contentVariantService }) => {\r\n      const selectedContent = contentVariantService.selectContentVariant(\r\n        node.enhancedContent!,\r\n        context\r\n      );\r\n      // Only dispatch if the content actually changed\r\n      if (selectedContent !== node.currentContent) {\r\n        dispatch(updateContentVariant({ \r\n          nodeId: targetNodeId, \r\n          context,\r\n          selectedContent \r\n        }));\r\n      }\r\n    });\r\n  }, [node, targetNodeId, readerState.path, allNodes, dispatch]);\r\n  \r\n  // Evaluate a condition directly using the transformation engine\r\n  const evaluateCondition = useCallback(\r\n    (condition: TransformationCondition) => {\r\n      if (!node) return false;\r\n      return transformationEngine.evaluateCondition(condition, readerState, node);\r\n    },\r\n    [node, readerState]\r\n  );\r\n  \r\n  // Return the API\r\n  return {\r\n    node,\r\n    navigateTo,\r\n    revealNodeConnection,\r\n    engageWithAttractor,\r\n    applyNodeTransformation,\r\n    evaluateCondition,\r\n    neighbors,\r\n    revisitCount,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  };\r\n};\r\n\r\nexport default useNodeState;","/**\r\n * Content Sanitizer Utility\r\n * \r\n * EMERGENCY FIX: Prevents recursive transformation cascade by cleaning content\r\n * before applying new transformations and sanitizing output for display.\r\n */\r\n\r\n/**\r\n * Cleans content of all transformation markup to return to original text\r\n * This prevents recursive application of transformations to already-transformed content\r\n */\r\nexport function stripTransformationMarkup(content: string): string {\r\n  if (!content) return '';\r\n  \r\n  try {\r\n    let cleanContent = content;\r\n    \r\n    // Remove all span elements with transformation classes\r\n    cleanContent = cleanContent.replace(\r\n      /<span[^>]*class=\"[^\"]*(?:glitch-text|text-transformation|narramorph-|text-emphasis|text-expanded|text-fragmented|text-commented|text-replaced)[^\"]*\"[^>]*>(.*?)<\\/span>/gs,\r\n      '$1'\r\n    );\r\n    \r\n    // Remove data attributes that indicate transformations\r\n    cleanContent = cleanContent.replace(\r\n      /<span[^>]*data-transform-type=\"[^\"]*\"[^>]*>(.*?)<\\/span>/gs,\r\n      '$1'\r\n    );\r\n    \r\n    // Remove perspective shift markers\r\n    cleanContent = cleanContent.replace(\r\n      /perspective shift:\\s*\\w+\\s*→\\s*\\w+/g,\r\n      ''\r\n    );\r\n    \r\n    // Remove system markers and debug text\r\n    cleanContent = cleanContent.replace(\r\n      /\\[(?:PATTERN_DETECTED|ANALYSIS_COMPLETE|DATA_INTEGRITY|TEMPORAL_MARKER)[^[\\]]*\\]/g,\r\n      ''\r\n    );\r\n    \r\n    // Remove malformed spans that indicate corruption\r\n    cleanContent = cleanContent.replace(\r\n      /<<\\*\\*span\\*\\*[^>]*>/g,\r\n      ''\r\n    );\r\n    \r\n    // Remove strikethrough Unicode combining characters\r\n    cleanContent = cleanContent.replace(/̶/g, '');\r\n    \r\n    // Remove empty elements and excessive whitespace\r\n    cleanContent = cleanContent.replace(/<[^>]*><\\/[^>]*>/g, '');\r\n    cleanContent = cleanContent.replace(/\\s+/g, ' ');\r\n    cleanContent = cleanContent.trim();\r\n    \r\n    console.log(`[ContentSanitizer] Cleaned content: ${content.length} → ${cleanContent.length} characters`);\r\n    return cleanContent;\r\n    \r\n  } catch (error) {\r\n    console.error('[ContentSanitizer] Error cleaning content:', error);\r\n    return content; // Return original if cleaning fails\r\n  }\r\n}\r\n\r\n/**\r\n * Validates if content has been corrupted by transformation cascade\r\n */\r\nexport function isContentCorrupted(content: string): boolean {\r\n  if (!content) return true;\r\n  \r\n  const corruptionIndicators = [\r\n    content.includes('[object Object]'),\r\n    content.includes('undefined'),\r\n    content.includes('<span class=\"glitch-text\"><span class=\"glitch-text\">'), // Nested spans\r\n    content.match(/<<\\*\\*span\\*\\*/g), // Malformed HTML\r\n    content.length < 10, // Too short\r\n    content.split('<span').length > 10, // Too many spans\r\n  ];\r\n  \r\n  return corruptionIndicators.some(indicator => indicator);\r\n}\r\n\r\n/**\r\n * Final text cleanup function that removes all technical markers and system commands\r\n * from content before displaying to users. This runs AFTER all transformations\r\n * but BEFORE user display to ensure clean, immersive narrative text.\r\n */\r\nexport function finalTextCleanup(text: string): string {\r\n  if (!text) return '';\r\n  \r\n  try {\r\n    let cleaned = text;\r\n    \r\n    // Remove perspective shift commands (HIGH PRIORITY)\r\n    cleaned = cleaned.replace(/perspective shift:\\s*\\w+\\s*→\\s*\\w+\\.?/gi, '');\r\n    \r\n    // Remove temporal markers (HIGH PRIORITY)\r\n    cleaned = cleaned.replace(/\\[TEMPORAL_MARKER:[^\\]]+\\]/gi, '');\r\n      // Remove strange attractor resonance diagnostics (MEDIUM PRIORITY)\r\n    cleaned = cleaned.replace(/strange attractor resonance:\\s*[.\\d/()]+\\s*\\w*/gi, '');\r\n    \r\n    // Remove other system markers and debug text\r\n    cleaned = cleaned.replace(/\\[(?:PATTERN_DETECTED|ANALYSIS_COMPLETE|DATA_INTEGRITY)[^[\\]]*\\]/gi, '');\r\n    \r\n    // Remove character perspective shift markers\r\n    cleaned = cleaned.replace(/character perspective shift/gi, '');\r\n      // Fix broken word fragments from marker removal (MEDIUM PRIORITY)\r\n    // Remove orphaned characters like \"(stable)s\" becoming \"s\"\r\n    cleaned = cleaned.replace(/\\(stable\\)s\\.?/gi, '');\r\n    cleaned = cleaned.replace(/\\(unstable\\)\\.?/gi, '');\r\n    cleaned = cleaned.replace(/\\([\\w\\s]+\\)[a-z]\\.?/gi, '');    // Clean up spacing issues from marker removals (LOW PRIORITY)\r\n    cleaned = cleaned.replace(/\\s+/g, ' '); // Multiple spaces to single\r\n    cleaned = cleaned.replace(/([a-z])([A-Z])/g, '$1 $2'); // Add space between camelCase words\r\n    cleaned = cleaned.replace(/([a-z])through\\b/gi, '$1 through'); // Fix word concatenation with \"through\"\r\n    cleaned = cleaned.replace(/([a-z])and\\b/gi, '$1 and'); // Fix word concatenation with \"and\"\r\n    cleaned = cleaned.replace(/\\s*\\.\\s*\\./g, '.'); // Double periods\r\n    cleaned = cleaned.replace(/\\s*,\\s*,/g, ','); // Double commas\r\n    cleaned = cleaned.replace(/\\s*;\\s*;/g, ';'); // Double semicolons\r\n    \r\n    // Clean orphaned punctuation - fix spacing before punctuation\r\n    cleaned = cleaned.replace(/\\s+([.,;!?])/g, '$1');\r\n    \r\n    // Remove empty lines caused by removed markers\r\n    cleaned = cleaned.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\r\n    \r\n    // Remove leading/trailing whitespace from lines\r\n    cleaned = cleaned.split('\\n').map(line => line.trim()).join('\\n');\r\n    \r\n    // Final trim\r\n    cleaned = cleaned.trim();\r\n    \r\n    console.log(`[ContentSanitizer] Final text cleanup: ${text.length} → ${cleaned.length} characters`);\r\n    \r\n    return cleaned;\r\n    \r\n  } catch (error) {\r\n    console.error('[ContentSanitizer] Error in final text cleanup:', error);\r\n    return text; // Return original if cleanup fails\r\n  }\r\n}\r\n\r\n/**\r\n * Sanitizes final output for display by removing any remaining markup leakage\r\n * @deprecated Use finalTextCleanup instead for comprehensive cleaning\r\n */\r\nexport function sanitizeDisplayContent(content: string): string {\r\n  if (!content) return '';\r\n  \r\n  try {\r\n    let sanitized = content;\r\n    \r\n    // Remove any remaining transformation markers\r\n    sanitized = sanitized.replace(/\\*#\\s*/g, '');\r\n    \r\n    // Clean up multiple consecutive spaces\r\n    sanitized = sanitized.replace(/\\s{2,}/g, ' ');\r\n    \r\n    // Remove leading/trailing whitespace from lines\r\n    sanitized = sanitized.split('\\n').map(line => line.trim()).join('\\n');\r\n    \r\n    // Remove empty lines caused by removed markers\r\n    sanitized = sanitized.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\r\n    \r\n    return sanitized.trim();\r\n    \r\n  } catch (error) {\r\n    console.error('[ContentSanitizer] Error sanitizing display content:', error);\r\n    return content;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a unique transformation ID for tracking applied transformations\r\n */\r\nexport function generateTransformationId(transformation: {\r\n  type: string;\r\n  selector?: string;\r\n  priority?: string;\r\n}): string {\r\n  return `${transformation.type}-${transformation.selector?.substring(0, 20) || 'unknown'}-${transformation.priority || 'medium'}`;\r\n}\r\n\r\n/**\r\n * Checks if a transformation has already been applied to content\r\n */\r\nexport function hasTransformationBeenApplied(\r\n  appliedIds: string[],\r\n  transformationId: string\r\n): boolean {\r\n  return appliedIds.includes(transformationId);\r\n}\r\n","/**\r\n * TransformationAnimationContainer Component\r\n * \r\n * Provides enhanced transition animations when content transforms between states.\r\n * This component wraps around transformed content and adds visual context\r\n * to help users understand the transformation process.\r\n */\r\n\r\nimport React, { useEffect, useRef, useState, useLayoutEffect } from 'react';\r\nimport { TextTransformation } from '../../types';\r\n\r\n// For debugging DOM measurements and layout issues\r\ninterface ElementMeasurements {\r\n  width: number;\r\n  height: number;\r\n  visibility: string;\r\n  display: string;\r\n  opacity: string;\r\n  position: string;\r\n  zIndex: string;\r\n  overflow: string;\r\n}\r\n\r\ninterface TransformationAnimationContainerProps {\r\n  children: React.ReactNode;\r\n  transformations: TextTransformation[];\r\n  isNewlyTransformed: boolean;\r\n  nodeId: string;\r\n}\r\n\r\nconst TransformationAnimationContainer: React.FC<TransformationAnimationContainerProps> = ({\r\n  children,\r\n  transformations,\r\n  isNewlyTransformed,\r\n  nodeId\r\n}): React.ReactElement => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [animationState, setAnimationState] = useState<'idle' | 'entering' | 'active'>('idle');\r\n  const [transformationCount, setTransformationCount] = useState(transformations.length);\r\n  const [renderAttempt, setRenderAttempt] = useState(0);\r\n  \r\n  // Track DOM measurements for debugging\r\n  const [measurements, setMeasurements] = useState<ElementMeasurements | null>(null);\r\n  const [contentVisible, setContentVisible] = useState(true);\r\n  \r\n  // Force a re-render after mount to ensure visibility\r\n  useEffect(() => {\r\n    // After mount, force a re-render to ensure proper layout\r\n    // Limit to max 3 attempts to prevent infinite loops\r\n    if (renderAttempt < 3) {\r\n      const timer = setTimeout(() => {\r\n        setRenderAttempt(prev => prev + 1);\r\n        console.log(`[AnimationContainer] Forced re-render for node: ${nodeId}, attempt: ${renderAttempt + 1}`);\r\n      }, 100);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [nodeId, renderAttempt]);\r\n  \r\n  // When transformations change, update the animation state\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      setAnimationState('entering');\r\n      \r\n      // After the animation completes, set to active state\r\n      const timer = setTimeout(() => {\r\n        setAnimationState('active');\r\n      }, 1000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isNewlyTransformed, transformations]);\r\n  \r\n  // When node changes or transformation count changes, reset animation state\r\n  useEffect(() => {\r\n    setAnimationState('idle');\r\n    setTransformationCount(transformations.length);\r\n    \r\n    // Debug log for node changes\r\n    console.log(`[AnimationContainer] Node changed to: ${nodeId}, transformations: ${transformations.length}`);\r\n  }, [nodeId, transformations.length]);\r\n  \r\n  // Monitor and log DOM measurements for debugging visibility issues\r\n  useLayoutEffect(() => {\r\n    if (!containerRef.current) return;\r\n    \r\n    // Function to measure DOM element properties\r\n    const measureElement = () => {\r\n      if (!containerRef.current) return;\r\n      \r\n      const style = window.getComputedStyle(containerRef.current);\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      \r\n      const newMeasurements: ElementMeasurements = {\r\n        width: rect.width,\r\n        height: rect.height,\r\n        visibility: style.visibility,\r\n        display: style.display,\r\n        opacity: style.opacity,\r\n        position: style.position,\r\n        zIndex: style.zIndex,\r\n        overflow: style.overflow\r\n      };\r\n      \r\n      setMeasurements(newMeasurements);\r\n      \r\n      // Check if content is visible in DOM\r\n      const isVisible = rect.width > 0 &&\r\n                        rect.height > 0 &&\r\n                        style.visibility !== 'hidden' &&\r\n                        style.display !== 'none' &&\r\n                        parseFloat(style.opacity) > 0;\r\n                        \r\n      setContentVisible(isVisible);\r\n      \r\n      // Log significant changes to visibility\r\n      if (contentVisible !== isVisible) {\r\n        console.log(`[AnimationContainer] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`, {\r\n          nodeId,\r\n          transformations: transformations.length,\r\n          animationState,\r\n          measurements: newMeasurements\r\n        });\r\n      }\r\n    };\r\n    \r\n    // Measure immediately\r\n    measureElement();\r\n    \r\n    // Measure after animations might be complete\r\n    const timer = setTimeout(measureElement, 1100);\r\n    \r\n    // Set up mutation observer to track DOM changes - with debouncing\r\n    let timeoutId: number | null = null;\r\n    const observer = new MutationObserver((mutations) => {\r\n      // Only log significant mutations to reduce noise\r\n      if (mutations.length > 2) {\r\n        console.log(`[AnimationContainer] DOM mutations detected: ${mutations.length}`);\r\n      }\r\n      \r\n      // Debounce measurements to prevent infinite loops\r\n      if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      \r\n      timeoutId = window.setTimeout(() => {\r\n        measureElement();\r\n        timeoutId = null;\r\n      }, 500);\r\n    });\r\n    \r\n    observer.observe(containerRef.current, {\r\n      attributes: true,\r\n      childList: true,\r\n      subtree: false // Reduced to false to prevent excessive notifications\r\n    });\r\n    \r\n    return () => {\r\n      clearTimeout(timer);\r\n      observer.disconnect();\r\n    };\r\n  }, [nodeId, transformations, animationState, contentVisible]);\r\n  \r\n  // Determine which animation effect to apply based on transformation types\r\n  const getAnimationClass = () => {\r\n    if (animationState === 'idle') return '';\r\n    \r\n    const hasReplacements = transformations.some(t => t.type === 'replace');\r\n    const hasEmphasis = transformations.some(t => t.type === 'emphasize');\r\n    const hasExpansions = transformations.some(t => t.type === 'expand');\r\n    \r\n    if (animationState === 'entering') {\r\n      if (hasReplacements) return 'narramorph-container-replace-active';\r\n      if (hasEmphasis) return 'narramorph-container-emphasis-active';\r\n      if (hasExpansions) return 'narramorph-container-expand-active';\r\n      return 'narramorph-container-transform-active';\r\n    }\r\n    \r\n    return 'narramorph-container-active';\r\n  };\r\n  \r\n  // Get a description of transformation activity\r\n  const getTransformationDescription = () => {\r\n    if (transformations.length === 0) return '';\r\n    \r\n    const typeCount: Record<string, number> = {};\r\n    transformations.forEach(t => {\r\n      typeCount[t.type] = (typeCount[t.type] || 0) + 1;\r\n    });\r\n    \r\n    // Generate a description based on the types of transformations\r\n    const descriptions = [];\r\n    \r\n    if (typeCount['replace']) {\r\n      descriptions.push(`${typeCount['replace']} replacements`);\r\n    }\r\n    \r\n    if (typeCount['emphasize']) {\r\n      descriptions.push(`${typeCount['emphasize']} emphasis`);\r\n    }\r\n    \r\n    if (typeCount['expand']) {\r\n      descriptions.push(`${typeCount['expand']} expansions`);\r\n    }\r\n    \r\n    if (typeCount['fragment']) {\r\n      descriptions.push(`${typeCount['fragment']} fragmentations`);\r\n    }\r\n    \r\n    if (typeCount['metaComment']) {\r\n      descriptions.push(`${typeCount['metaComment']} comments`);\r\n    }\r\n    \r\n    return descriptions.join(', ');\r\n  };\r\n  \r\n  // Check if number of transformations has changed\r\n  const hasChangedTransformations = transformations.length !== transformationCount;\r\n  \r\n  // Log when animations are triggered\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      console.log(`[AnimationContainer] Animation started for node: ${nodeId}`, {\r\n        transformations: transformations.length,\r\n        animationState,\r\n        contentVisible\r\n      });\r\n    }\r\n  }, [isNewlyTransformed, nodeId, transformations.length, animationState, contentVisible]);\r\n  \r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`narramorph-animation-container ${getAnimationClass()}`}\r\n      data-transformation-count={transformations.length}\r\n      data-newly-transformed={isNewlyTransformed}\r\n      data-animation-state={animationState}\r\n      data-visible={contentVisible}\r\n      data-render-attempt={renderAttempt}\r\n      style={{\r\n        overflow: 'visible',\r\n        minHeight: '150px',\r\n        position: 'relative', // Ensure positioning context\r\n        visibility: 'visible',\r\n        display: 'block',\r\n        opacity: 1\r\n      }}\r\n    >\r\n      {/* Visual indicator for active transformations */}\r\n      {transformations.length > 0 && (\r\n        <div \r\n          className={`narramorph-transformation-indicator ${isNewlyTransformed ? 'active' : ''}`}\r\n          title={getTransformationDescription()}\r\n        >\r\n          <span className=\"transformation-count\">{transformations.length}</span>\r\n          {hasChangedTransformations && (\r\n            <span className=\"transformation-change-indicator\">\r\n              {transformations.length > transformationCount ? '+' : ''}\r\n              {transformations.length - transformationCount}\r\n            </span>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content with transformations */}\r\n      <div\r\n        ref={contentRef}\r\n        className=\"narramorph-animation-content\"\r\n        style={{\r\n          position: 'relative',\r\n          visibility: 'visible',\r\n          display: 'block',\r\n          opacity: 1,\r\n          minHeight: '100px'\r\n        }}\r\n      >\r\n        {renderAttempt === 0 ? (\r\n          <div className=\"animation-placeholder\" style={{ padding: '20px', textAlign: 'center' }}>\r\n            <p>Preparing narrative...</p>\r\n          </div>\r\n        ) : (\r\n          children\r\n        )}\r\n      </div>\r\n      \r\n      {/* Debug info overlay - only in development */}\r\n      {process.env.NODE_ENV === 'development' && measurements && (\r\n        <div\r\n          className=\"animation-debug-info\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: 0,\r\n            right: 0,\r\n            background: 'rgba(0,0,0,0.7)',\r\n            color: '#fff',\r\n            padding: '3px',\r\n            fontSize: '9px',\r\n            zIndex: 1000,\r\n            pointerEvents: 'none'\r\n          }}\r\n        >\r\n          <div>{`${Math.round(measurements.width)}x${Math.round(measurements.height)}`}</div>\r\n          <div>{`Vis:${measurements.visibility.charAt(0)}|Dis:${measurements.display.charAt(0)}`}</div>\r\n          <div>{`Op:${parseFloat(measurements.opacity).toFixed(1)}|Z:${measurements.zIndex}`}</div>\r\n          <div>{`T:${transformations.length}|S:${animationState.charAt(0)}`}</div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TransformationAnimationContainer;"],"file":"assets/narramorph-BlMiJuN1.js"}