{"version":3,"file":"node-view-CX8ZmfD4.js","sources":["../../src/components/Constellation/NodesInstanced.tsx","../../src/components/Constellation/ConnectionsBatched.tsx"],"sourcesContent":[" import { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  nodeHovered,\r\n  nodeUnhovered,\r\n  selectHoveredNodeId,\r\n  selectSelectedNodeId,\r\n  nodeSelected,\r\n  setViewMode,\r\n  // Removed incorrect import\r\n} from '../../store/slices/interfaceSlice';\r\nimport { navigateToNode } from '../../store/slices/readerSlice';\r\nimport { visitNode } from '../../store/slices/nodesSlice';\r\nimport { AppDispatch } from '../../store';\r\nimport { ConstellationNode, NodePositions } from '../../types';\r\nimport { forwardRef, useMemo, useRef } from 'react';\r\nimport { Color, InstancedMesh, ShaderMaterial } from 'three';\r\nimport * as THREE from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport { Text } from '@react-three/drei';\r\n\r\n\r\n// Circuit pattern vertex shader\r\nconst circuitVertexShader = `\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\n// Circuit pattern fragment shader\r\nconst circuitFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  \r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  // Simple hash function\r\n  float hash(vec2 p) {\r\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\r\n  }\r\n  \r\n  void main() {\r\n    // Basic circuit pattern\r\n    vec2 gridPos = floor(vPosition.xy * 10.0);\r\n    float circuit = hash(gridPos) > 0.7 ? 1.0 : 0.0;\r\n    \r\n    // Circuit lines\r\n    vec2 grid = fract(vPosition.xy * 10.0);\r\n    float line = smoothstep(0.95, 0.98, max(grid.x, grid.y));\r\n    \r\n    // Flowing effect on circuit lines\r\n    float flow = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Combine effects\r\n    vec3 finalColor = color * (0.5 + 0.5 * circuit + line * flow);\r\n    \r\n    // Add rim lighting\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    finalColor += color * rim * 0.5;\r\n    \r\n    gl_FragColor = vec4(finalColor, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field vertex shader for hover effect\r\nconst forceFieldVertexShader = `\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    \r\n    // Add subtle pulsating effect\r\n    float pulse = sin(time * 2.0) * 0.05 + 1.05;\r\n    vec3 newPosition = position * pulse;\r\n    \r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field fragment shader for hover effect\r\nconst forceFieldFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    // Create flowing wave pattern\r\n    float wave = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Rim effect for sphere edge glow\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    \r\n    // Transparency based on rim and wave pattern\r\n    float alpha = rim * 0.7 * wave;\r\n    \r\n    // Final color with slight pulsation\r\n    float pulse = sin(time * 3.0) * 0.2 + 0.8;\r\n    vec3 finalColor = color * pulse * (0.5 + wave * 0.5);\r\n    \r\n    gl_FragColor = vec4(finalColor, alpha);\r\n  }\r\n`;\r\n\r\ninterface NodesInstancedProps {\r\n  nodes: ConstellationNode[];\r\n  nodePositions: NodePositions;\r\n  connections: { start: string; end: string }[];\r\n  overrideSelectedNodeId?: string;\r\n  onNodeClick?: (nodeId: string) => void;\r\n  clickableNodeIds?: string[];\r\n  isMinimap?: boolean; // Flag to indicate if this is used in the minimap\r\n  isInitialChoicePhase: boolean;\r\n  positionSynchronizer: {\r\n    updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n    getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n}\r\n\r\n// Define base colors for each triad - match exact character names from nodesSlice.ts\r\nconst triadColors = {\r\n  LastHuman: new Color('#ff6666'), // Reddish\r\n  Archaeologist: new Color('#66ff66'), // Greenish\r\n  Algorithm: new Color('#6666ff'), // Bluish\r\n};\r\n\r\n// Create a more permissive lookup that doesn't rely on exact matching\r\n// Helper to get color for node based on character with proper type safety\r\nconst getNodeColor = (character: string | undefined): Color => {\r\n  if (!character) return new Color('#ffffff');\r\n  \r\n  // Direct lookup with type safety\r\n  if (character === 'LastHuman') return triadColors.LastHuman;\r\n  if (character === 'Archaeologist') return triadColors.Archaeologist;\r\n  if (character === 'Algorithm') return triadColors.Algorithm;\r\n  \r\n  // Case-insensitive lookup as fallback\r\n  const lowerChar = character.toLowerCase();\r\n  if (lowerChar.includes('human')) return triadColors.LastHuman;\r\n  if (lowerChar.includes('arch')) return triadColors.Archaeologist;\r\n  if (lowerChar.includes('algo')) return triadColors.Algorithm;\r\n  \r\n  // Default\r\n  console.warn(`Unknown character type: ${character}, using default color`);\r\n  return new Color('#ffffff');\r\n};\r\n\r\n\r\nexport const NodesInstanced = forwardRef<InstancedMesh, NodesInstancedProps>((props, ref) => {\r\n  const {\r\n    nodes,\r\n    nodePositions,\r\n    connections,\r\n    overrideSelectedNodeId,\r\n    onNodeClick,\r\n    clickableNodeIds,\r\n    isInitialChoicePhase,\r\n    positionSynchronizer,\r\n  } = props;\r\n  const dispatch = useDispatch<AppDispatch>();\r\n  \r\n  const hoveredNodeId = useSelector(selectHoveredNodeId);\r\n  const reduxSelectedNodeId = useSelector(selectSelectedNodeId);\r\n  const selectedNodeId = overrideSelectedNodeId ?? reduxSelectedNodeId;\r\n  \r\n  \r\n  const connectedNodeIds = useMemo(() => {\r\n    if (!selectedNodeId) return new Set<string>();\r\n    const connected = new Set<string>();\r\n    connections.forEach((c) => {\r\n      if (c.start === selectedNodeId) connected.add(c.end);\r\n      if (c.end === selectedNodeId) connected.add(c.start);\r\n    });\r\n    return connected;\r\n  }, [selectedNodeId, connections]);\r\n\r\n  // Create refs for accessing objects in the scene\r\n  const materialRefs = useRef<ShaderMaterial[]>([]);\r\n  const forceFieldMaterialRefs = useRef<ShaderMaterial[]>([]);\r\n  const nodeMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  const forceFieldMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  \r\n  // Store original positions for the noise animation\r\n  const originalPositions = useRef<{[key: string]: [number, number, number]}>({});\r\n  \r\n  // Initialize original positions\r\n  useMemo(() => {\r\n    nodes.forEach(node => {\r\n      const position = nodePositions[node.id] || [0, 0, 0];\r\n      originalPositions.current[node.id] = [...position];\r\n    });\r\n  }, [nodes, nodePositions]);\r\n  \r\n  \r\n  // Update shader time uniform and apply noise movement with optimized LOD\r\n  // Frame counter for throttling updates\r\n  const frameCount = useRef(0);\r\n  const lastUpdatePositionsTime = useRef(0);\r\n  const lastUpdateMaterialsTime = useRef(0);\r\n  \r\n  // Enhanced optimization: Using variable update rates based on priority\r\n  useFrame((state): void => {\r\n    const time = state.clock.elapsedTime;\r\n    frameCount.current += 1;\r\n    \r\n    // Get synchronized positions from the position synchronizer\r\n    const currentPositions = positionSynchronizer.updatePositions(time, props.isMinimap);\r\n      \r\n    // All nodes are always visible, no need for validation\r\n    \r\n    // Time-based throttling for shader updates\r\n    const shouldUpdateMaterials = time - lastUpdateMaterialsTime.current > 0.05; // 50ms\r\n    if (shouldUpdateMaterials) {\r\n      lastUpdateMaterialsTime.current = time;\r\n      \r\n      // Update time uniforms on important materials only\r\n      const importantMaterials = materialRefs.current.filter((_, i) => {\r\n        const node = nodes[i];\r\n        return node && (\r\n          node.id === selectedNodeId ||\r\n          node.id === hoveredNodeId ||\r\n          connections.some(c => c.start === node.id || c.end === node.id)\r\n        );\r\n      });\r\n      \r\n      // Batch updates to reduce overhead\r\n      importantMaterials.forEach(material => {\r\n        if (material?.uniforms?.time) {\r\n          material.uniforms.time.value = time;\r\n        }\r\n      });\r\n      \r\n      // Update force field materials only for selected/hovered nodes\r\n      const importantForceFields = forceFieldMaterialRefs.current.filter((_, i) => {\r\n        const node = nodes[i];\r\n        return node && (node.id === selectedNodeId || node.id === hoveredNodeId);\r\n      });\r\n      \r\n      importantForceFields.forEach(material => {\r\n        if (material?.uniforms?.time) {\r\n          material.uniforms.time.value = time;\r\n        }\r\n      });\r\n    }\r\n    \r\n    // SYNC FIX: Ensure we update positions on the same frames as ConnectionsBatched\r\n    // This is critical for keeping nodes and connections aligned\r\n    const timeSinceLastPositionUpdate = time - lastUpdatePositionsTime.current;\r\n    // CRITICAL SYNC FIX: Use same update interval as ConnectionsBatched\r\n    const UPDATE_INTERVAL = 0.15; // 150ms in seconds\r\n    const shouldUpdatePositions = timeSinceLastPositionUpdate >= UPDATE_INTERVAL;\r\n    \r\n    if (shouldUpdatePositions) {\r\n      lastUpdatePositionsTime.current = time;\r\n      \r\n      // Apply organic movement to nodes using noise - with optimized calculations\r\n      // And apply pulsing effect for designated starting nodes\r\n      for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        const nodeMesh = nodeMeshRefs.current[i] as THREE.Mesh; // Cast for scale property\r\n        \r\n        if (!nodeMesh) {\r\n          continue; // Skip if mesh doesn't exist\r\n        }\r\n        \r\n        const origPos = originalPositions.current[node.id];\r\n        if (!origPos) {\r\n          continue; // Skip if no original position\r\n        }\r\n\r\n        // Determine if this node is a designated starting node for pulsing logic\r\n        let isDesignatedStartingNodeForPulse = false;\r\n        if (isInitialChoicePhase && !props.isMinimap) { // Pulse only in main view during initial phase\r\n          if (node.contentSource === 'arch-discovery.md' ||\r\n              node.contentSource === 'algo-awakening.md' ||\r\n              node.contentSource === 'human-discovery.md') {\r\n            isDesignatedStartingNodeForPulse = true;\r\n          }\r\n        }\r\n\r\n        if (isDesignatedStartingNodeForPulse) {\r\n          const pulseSpeed = 3;\r\n          const pulseAmount = 0.15; // Scale pulsates between 0.85 and 1.15 approx.\r\n          const baseScale = 1.0;\r\n          const targetScale = baseScale + Math.sin(time * pulseSpeed) * pulseAmount;\r\n          nodeMesh.scale.set(targetScale, targetScale, targetScale);\r\n        } else {\r\n          // Ensure non-pulsing nodes (or minimap nodes, or when not in initial phase) have normal scale\r\n          if (nodeMesh.scale.x !== 1.0 || nodeMesh.scale.y !== 1.0 || nodeMesh.scale.z !== 1.0) {\r\n            nodeMesh.scale.set(1.0, 1.0, 1.0);\r\n          }\r\n        }\r\n        \r\n        // Always update all nodes\r\n        const shouldUpdate = true;\r\n        const isImportantNode = node.id === selectedNodeId ||\r\n                               node.id === hoveredNodeId ||\r\n                               connectedNodeIds.has(node.id);\r\n        \r\n        // Always show the node\r\n        nodeMesh.visible = true;\r\n        \r\n        // Show force field only for important nodes\r\n        const forceMesh = forceFieldMeshRefs.current[i];\r\n        if (forceMesh) {\r\n          forceMesh.visible = isImportantNode;\r\n        }\r\n          \r\n        if (shouldUpdate) {\r\n          // CRITICAL FIX: Use synchronized positions from the position synchronizer\r\n          const syncedPos = currentPositions[node.id];\r\n          \r\n          if (syncedPos) {\r\n            // Use the synchronized position directly - NO additional noise calculation\r\n            nodeMesh.position.set(syncedPos[0], syncedPos[1], syncedPos[2]);\r\n          } else {\r\n            // Fallback to original position if synchronized position is not available\r\n            console.warn(`NodesInstanced: Missing synchronized position for node ${node.id}`);\r\n            nodeMesh.position.set(origPos[0], origPos[1], origPos[2]);\r\n          }\r\n          \r\n          // Update force field position only if it exists and node is important\r\n          const forceMesh = forceFieldMeshRefs.current[i];\r\n          if (forceMesh && isImportantNode) {\r\n            forceMesh.visible = true;\r\n            forceMesh.position.copy(nodeMesh.position);\r\n          } else if (forceMesh) {\r\n            forceMesh.visible = false;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // No need to update visible node count since we removed the display\r\n    }\r\n  });\r\n  \r\n  // Create a dummy instanced mesh to maintain API compatibility with ref\r\n  // while still using individual meshes for better control\r\n  return (\r\n    <group>\r\n      {/* This invisible instanced mesh is just for ref compatibility */}\r\n      {ref && (\r\n        <instancedMesh\r\n          ref={ref}\r\n          args={[\r\n            new THREE.BufferGeometry(),\r\n            new THREE.MeshBasicMaterial(),\r\n            0\r\n          ]}\r\n          visible={false}\r\n        />\r\n      )}\r\n      {nodes.map((node, index) => {\r\n        const isSelected = selectedNodeId === node.id;\r\n        const isConnected = connectedNodeIds.has(node.id);\r\n        const isHovered = hoveredNodeId === node.id;\r\n\r\n        let isDesignatedStartingNode = false;\r\n        let labelText = '';\r\n\r\n        if (isInitialChoicePhase) {\r\n          if (node.contentSource === 'arch-discovery.md') {\r\n            isDesignatedStartingNode = true;\r\n            labelText = 'Choice';\r\n          } else if (node.contentSource === 'algo-awakening.md') {\r\n            isDesignatedStartingNode = true;\r\n            labelText = 'Awakening';\r\n          } else if (node.contentSource === 'human-discovery.md') {\r\n            isDesignatedStartingNode = true;\r\n            labelText = 'Discovery';\r\n          }\r\n        }\r\n        \r\n        // Calculate node color using our more permissive function\r\n        const nodeColor = getNodeColor(node.character).clone();\r\n        \r\n        // Apply color adjustments based on node state\r\n        if (isSelected) {\r\n          nodeColor.multiplyScalar(1.5); // Lighter shade\r\n        } else if (isConnected) {\r\n          nodeColor.multiplyScalar(0.5); // Darker shade\r\n        } else if (isHovered) {\r\n          nodeColor.multiplyScalar(1.2); // Slightly lighter for hover\r\n        } else if (isDesignatedStartingNode) {\r\n          // Potentially give starting nodes a distinct look even if not selected/hovered,\r\n          // or this could be handled by the pulsing effect later.\r\n          // For now, let's ensure they don't get dimmed like 'isConnected' if they are also connected.\r\n          // This logic might need refinement based on how visual effects are combined.\r\n          // If it's a starting node, we might want its base color to be more prominent.\r\n          // Example: nodeColor.multiplyScalar(1.1); // Slightly brighter if it's a starting node\r\n        }\r\n        \r\n        // The main node group's position is determined by nodePositions,\r\n        // but individual elements within this group (like the sphere and text) will be positioned relatively.\r\n        return (\r\n          <group\r\n            key={node.id}\r\n            position={[0, 0, 0]} // CRITICAL FIX: Group stays at origin, mesh handles all positioning\r\n            userData={{ nodeId: node.id }} // Add nodeId to userData for connection positioning\r\n          >\r\n            {isDesignatedStartingNode && isInitialChoicePhase && !props.isMinimap && labelText && (\r\n              <Text\r\n                position={[0, 1.6, 0]} // Position above the larger node sphere\r\n                fontSize={0.35} // Slightly increased font size\r\n                color=\"white\"\r\n                anchorX=\"center\"\r\n                anchorY=\"middle\"\r\n                outlineWidth={0.02}\r\n                outlineColor=\"#000000\"\r\n                material-depthTest={false} // Ensures text is visible\r\n                material-transparent={true}\r\n              >\r\n                {labelText}\r\n              </Text>\r\n            )}\r\n\r\n            {/* Force field effect (only visible when hovered or selected) */}\r\n            {(isHovered || isSelected) && (\r\n              <mesh\r\n                ref={(mesh) => {\r\n                  if (mesh) {\r\n                    forceFieldMeshRefs.current[index] = mesh;\r\n                  }\r\n                }}\r\n                // Position is now relative to the parent group, so [0,0,0] for the force field center\r\n                position={[0, 0, 0]}>\r\n                <sphereGeometry args={[1.4, 16, 16]} />\r\n                <shaderMaterial\r\n                  ref={(material) => {\r\n                    if (material) {\r\n                      forceFieldMaterialRefs.current[index] = material;\r\n                    }\r\n                  }}\r\n                  vertexShader={forceFieldVertexShader}\r\n                  fragmentShader={forceFieldFragmentShader}\r\n                  uniforms={{\r\n                    color: { value: nodeColor },\r\n                    time: { value: 0 }\r\n                  }}\r\n                  transparent={true}\r\n                  depthWrite={false}\r\n                />\r\n              </mesh>\r\n            )}\r\n            \r\n            {/* Main node mesh */}\r\n            <mesh\r\n              ref={(mesh) => {\r\n                if (mesh) {\r\n                  nodeMeshRefs.current[index] = mesh;\r\n                }\r\n              }}\r\n              // Position is now relative to the parent group, so [0,0,0] for the node sphere center\r\n              position={[0, 0, 0]}\r\n              onClick={(e: ThreeEvent<MouseEvent>) => {\r\n                if (e.stopPropagation) e.stopPropagation();\r\n\r\n                // Emit custom event to hide tooltip when a node is clicked\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n\r\n                if (isInitialChoicePhase) {\r\n                  if (isDesignatedStartingNode) {\r\n                    // Dispatch actions in sequence with proper error handling\r\n                    try {\r\n                      dispatch(nodeSelected(node.id));\r\n                      dispatch(visitNode(node.id));\r\n                      dispatch(setViewMode('reading'));\r\n                      dispatch(navigateToNode({\r\n                        nodeId: node.id,\r\n                        character: node.character,\r\n                        temporalValue: node.temporalValue,\r\n                        attractors: node.strangeAttractors,\r\n                      }));\r\n                    } catch (error) {\r\n                      console.error('Navigation error:', error);\r\n                    }\r\n                  }\r\n                  return; // Exit early if in initial choice phase\r\n                }\r\n                // Normal click logic (outside initial choice phase)\r\n                if (onNodeClick) { // This path is typically for MiniConstellation\r\n                  if (clickableNodeIds && !clickableNodeIds.includes(node.id)) {\r\n                    return;\r\n                  }\r\n                  onNodeClick(node.id);\r\n                } else { // This path is for the main ConstellationView\r\n                  if (selectedNodeId === null) { // If no node is selected, any node can be clicked\r\n                    dispatch(nodeSelected(node.id));\r\n                    dispatch(visitNode(node.id));\r\n                    dispatch(setViewMode('reading'));\r\n                    dispatch(navigateToNode({\r\n                      nodeId: node.id,\r\n                      character: node.character,\r\n                      temporalValue: node.temporalValue,\r\n                      attractors: node.strangeAttractors,\r\n                    }));\r\n                  } else { // If a node is already selected, only connected nodes can be clicked\r\n                    const isConnectedToCurrentSelected = connections.some(\r\n                      (c) =>\r\n                        (c.start === selectedNodeId && c.end === node.id) ||\r\n                        (c.start === node.id && c.end === selectedNodeId)\r\n                    );\r\n                    if (isConnectedToCurrentSelected) {\r\n                      dispatch(nodeSelected(node.id));\r\n                      dispatch(visitNode(node.id));\r\n                      dispatch(setViewMode('reading'));\r\n                      dispatch(navigateToNode({\r\n                        nodeId: node.id,\r\n                        character: node.character,\r\n                        temporalValue: node.temporalValue,\r\n                        attractors: node.strangeAttractors,\r\n                      }));\r\n                    }\r\n                  }\r\n                }\r\n              }}\r\n              onPointerOver={(e: ThreeEvent<PointerEvent>) => {\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                if (node.id !== hoveredNodeId) {\r\n                  dispatch(nodeHovered(node.id));\r\n                  \r\n                  // Emit custom event for tooltip positioning\r\n                  // Just use client coordinates from the event directly\r\n                  const nodeHoverEvent = new CustomEvent('node-hover', {\r\n                    detail: {\r\n                      position: {\r\n                        x: e.clientX,\r\n                        y: e.clientY - 40 // Position tooltip 40px above cursor\r\n                      },\r\n                      nodeId: node.id\r\n                    }\r\n                  });\r\n                  window.dispatchEvent(nodeHoverEvent);\r\n                }\r\n              }}\r\n              onPointerOut={(e: ThreeEvent<PointerEvent>) => {\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                \r\n                // Emit custom event for tooltip hiding\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n              }}\r\n              \r\n              // Fix for stuck hover: Add pointer leave event\r\n              onPointerLeave={(e: ThreeEvent<PointerEvent>) => {\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                \r\n                // Emit custom event for tooltip hiding\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n              }}\r\n            >\r\n              {/* Use lower poly geometry for distant nodes */}\r\n              {/* Performance optimization: Use lower poly geometry for distant nodes */}\r\n              {!isSelected && !isHovered ? (\r\n                <octahedronGeometry args={[1.0, 0]} /> // Lower poly for distant nodes - doubled size\r\n              ) : (\r\n                <sphereGeometry args={[1.0, 8, 8]} /> // Higher detail for selected/hovered - doubled size\r\n              )}\r\n              <shaderMaterial\r\n                ref={(material) => {\r\n                  if (material) {\r\n                    // Store reference to this material\r\n                    materialRefs.current[index] = material;\r\n                  }\r\n                }}\r\n                vertexShader={circuitVertexShader}\r\n                fragmentShader={circuitFragmentShader}\r\n                uniforms={{\r\n                  color: { value: nodeColor },\r\n                  time: { value: 0 }\r\n                }}\r\n              />\r\n            </mesh>\r\n          </group>\r\n        );\r\n      })}\r\n      \r\n      {/* Performance display removed */}\r\n    </group>\r\n  );\r\n});","import React, { forwardRef, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { BufferGeometry, InstancedMesh, DoubleSide } from 'three';\r\nimport { Connection, NodePositions } from '../../types';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\ninterface ConnectionsBatchedProps {\r\n  connections: Connection[];\r\n  nodePositions: NodePositions;\r\n  selectedNodeId?: string | null;\r\n  hoveredNodeId?: string | null;\r\n  positionSynchronizer: {\r\n    updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n    getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n}\r\n\r\n// Connection line shader code for glowing effects\r\nconst connectionVertexShader = `\r\n  // Using the built-in 'color' attribute instead of redefining it\r\n  uniform float time;\r\n  varying vec3 vColor;\r\n  varying float vPosition;\r\n  \r\n  void main() {\r\n    vColor = color;\r\n    vPosition = position.y;\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n    gl_Position = projectedPosition;\r\n  }\r\n`;\r\n\r\nconst connectionFragmentShader = `\r\n  uniform float time;\r\n  varying vec3 vColor;\r\n  varying float vPosition;\r\n  \r\n  void main() {\r\n    // Create flowing effect along the connection\r\n    float flow = sin(vPosition * 10.0 + time * 3.0) * 0.5 + 0.5;\r\n    \r\n    // Create pulsating glow effect\r\n    float pulse = sin(time * 2.0) * 0.2 + 0.8;\r\n    \r\n    // Combine effects\r\n    vec3 finalColor = vColor * (1.0 + flow * 0.3) * pulse;\r\n    \r\n    // Add subtle variation based on time\r\n    finalColor += vec3(sin(time * 0.2) * 0.05, sin(time * 0.3) * 0.05, sin(time * 0.4) * 0.05);\r\n    \r\n    gl_FragColor = vec4(finalColor, 0.9);\r\n  }\r\n`;\r\n\r\n// Using forwardRef for API compatibility\r\nconst ConnectionsBatched = forwardRef<InstancedMesh, ConnectionsBatchedProps>(\r\n  (props, ref) => {\r\n  const { connections, nodePositions, selectedNodeId, hoveredNodeId, positionSynchronizer } = props;\r\n  \r\n  // We use our own lineSegmentsRef since we're actually using LineSegments, not InstancedMesh\r\n  const lineSegmentsRef = useRef<THREE.LineSegments>(null!);\r\n  \r\n  // Acknowledge forwarded ref with null - we don't actually use an InstancedMesh\r\n  React.useImperativeHandle(ref, () => null!);\r\n  const geometryRef = useRef<BufferGeometry>(null!);\r\n  \r\n  // Create a reference for the custom shader material\r\n  const connectionMaterialRef = useRef<THREE.ShaderMaterial>(null);\r\n\r\n  const { positions, colors, lineCount } = useMemo(() => {\r\n    const positions = new Float32Array(connections.length * 2 * 3);\r\n    const colors = new Float32Array(connections.length * 2 * 3);\r\n    let lineCount = 0;\r\n\r\n    for (const connection of connections) {\r\n      const startNodePos = nodePositions[connection.source];\r\n      const endNodePos = nodePositions[connection.target];\r\n\r\n      if (startNodePos && endNodePos) {\r\n        // Calculate direction vector from source to target node\r\n        const directionVector = new THREE.Vector3(\r\n          endNodePos[0] - startNodePos[0],\r\n          endNodePos[1] - startNodePos[1],\r\n          endNodePos[2] - startNodePos[2]\r\n        ).normalize();\r\n        \r\n        // Define node radius (matching sphere geometry radius in NodesInstanced.tsx)\r\n        const nodeRadius = 0.5;\r\n        \r\n        // Adjust connection endpoints to node boundaries instead of centers\r\n        const adjustedStartPos = [\r\n          startNodePos[0] + directionVector.x * nodeRadius,\r\n          startNodePos[1] + directionVector.y * nodeRadius,\r\n          startNodePos[2] + directionVector.z * nodeRadius\r\n        ];\r\n        \r\n        const adjustedEndPos = [\r\n          endNodePos[0] - directionVector.x * nodeRadius,\r\n          endNodePos[1] - directionVector.y * nodeRadius,\r\n          endNodePos[2] - directionVector.z * nodeRadius\r\n        ];\r\n        \r\n        // Use the adjusted positions for connections\r\n        positions.set(adjustedStartPos, lineCount * 6);\r\n        positions.set(adjustedEndPos, lineCount * 6 + 3);\r\n\r\n        // Access values from props directly\r\n        const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n        const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n        \r\n        // Enhanced color logic\r\n        let color;\r\n        if (isSelected) {\r\n          color = new THREE.Color(0x00bfff); // Bright blue for selected\r\n        } else if (isHovered) {\r\n          color = new THREE.Color(0x88ccff); // Light blue for hovered\r\n        } else {\r\n          color = new THREE.Color(0x444444); // Default dark gray\r\n        }\r\n        \r\n        colors.set([color.r, color.g, color.b], lineCount * 6);\r\n        colors.set([color.r, color.g, color.b], lineCount * 6 + 3);\r\n\r\n        lineCount++;\r\n      }\r\n    }\r\n    return { positions, colors, lineCount };\r\n  }, [connections, nodePositions, selectedNodeId, hoveredNodeId]); // Add missing dependencies\r\n\r\n  // Memoize geometry initialization to prevent unnecessary updates\r\n  useEffect(() => {\r\n    const geometry = geometryRef.current;\r\n    if (!geometry) return;\r\n\r\n    // Only initialize if attributes don't exist or have different lengths\r\n    const currentPositions = geometry.attributes.position?.array;\r\n    const currentColors = geometry.attributes.color?.array;\r\n    \r\n    if (!currentPositions || \r\n        !currentColors || \r\n        currentPositions.length !== positions.length || \r\n        currentColors.length !== colors.length) {\r\n      \r\n      try {\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        geometry.setDrawRange(0, lineCount * 2);\r\n      } catch (error) {\r\n        console.error(\"Error initializing geometry attributes:\", error);\r\n      }\r\n    }\r\n\r\n    // Always update the data\r\n    const positionAttribute = geometry.attributes.position as THREE.Float32BufferAttribute;\r\n    const colorAttribute = geometry.attributes.color as THREE.Float32BufferAttribute;\r\n    \r\n    if (positionAttribute && colorAttribute) {\r\n      positionAttribute.array.set(positions);\r\n      colorAttribute.array.set(colors);\r\n      positionAttribute.needsUpdate = true;\r\n      colorAttribute.needsUpdate = true;\r\n    }\r\n  }, [positions, colors, lineCount]);\r\n\r\n  // Time tracking for synchronized updates\r\n  const lastUpdateTime = useRef(0);\r\n  const UPDATE_INTERVAL = 0.15; // 150ms in seconds - matching NodesInstanced\r\n\r\n  useFrame((state) => {\r\n    const currentTime = state.clock.elapsedTime;\r\n    const timeSinceLastUpdate = currentTime - lastUpdateTime.current;\r\n    \r\n    // Skip if refs are not ready\r\n    if (!geometryRef.current || !geometryRef.current.attributes.position || !geometryRef.current.attributes.color) {\r\n      return;\r\n    }\r\n    \r\n    // Update shader time uniform\r\n    if (connectionMaterialRef.current) {\r\n      connectionMaterialRef.current.uniforms.time.value = state.clock.elapsedTime;\r\n    }\r\n    \r\n    // Get synchronized positions from the synchronizer\r\n    const syncedPositions = positionSynchronizer.updatePositions(currentTime);\r\n    \r\n    // CRITICAL SYNC FIX: Update positions and colors at synchronized intervals\r\n    const shouldUpdatePositions = timeSinceLastUpdate >= UPDATE_INTERVAL;\r\n    const shouldUpdateColors = timeSinceLastUpdate >= UPDATE_INTERVAL / 3; // Update colors more frequently\r\n    \r\n    // Track last update time for position updates\r\n    if (shouldUpdatePositions) {\r\n      lastUpdateTime.current = currentTime;\r\n    }\r\n    \r\n    try {\r\n      const positionAttribute = geometryRef.current.attributes.position as THREE.BufferAttribute;\r\n      const colorAttribute = geometryRef.current.attributes.color as THREE.BufferAttribute;\r\n      \r\n      let positionsUpdated = false;\r\n      let colorsUpdated = false;\r\n      \r\n      // Use synchronized positions from the position synchronizer\r\n      for (let i = 0; i < connections.length; i++) {\r\n        const connection = connections[i];\r\n        \r\n        // Get synchronized positions for both nodes\r\n        const startPos = syncedPositions[connection.source];\r\n        const endPos = syncedPositions[connection.target];\r\n        \r\n        if (!startPos || !endPos) {\r\n          console.warn(`ConnectionsBatched: Missing synchronized position for connection ${connection.source} -> ${connection.target}`);\r\n          continue;\r\n        }\r\n        \r\n        // Calculate direction vector\r\n        const directionVector = new THREE.Vector3(\r\n          endPos[0] - startPos[0],\r\n          endPos[1] - startPos[1],\r\n          endPos[2] - startPos[2]\r\n        ).normalize();\r\n        \r\n        // Define node radius (matching NodesInstanced sphere radius)\r\n        const nodeRadius = 0.5;\r\n        \r\n        // Adjust connection endpoints to node boundaries\r\n        const adjustedStartPos = new THREE.Vector3(\r\n          startPos[0] + directionVector.x * nodeRadius,\r\n          startPos[1] + directionVector.y * nodeRadius,\r\n          startPos[2] + directionVector.z * nodeRadius\r\n        );\r\n        \r\n        const adjustedEndPos = new THREE.Vector3(\r\n          endPos[0] - directionVector.x * nodeRadius,\r\n          endPos[1] - directionVector.y * nodeRadius,\r\n          endPos[2] - directionVector.z * nodeRadius\r\n        );\r\n        \r\n        if (shouldUpdatePositions) {\r\n          positionAttribute.setXYZ(i * 2, adjustedStartPos.x, adjustedStartPos.y, adjustedStartPos.z);\r\n          positionAttribute.setXYZ(i * 2 + 1, adjustedEndPos.x, adjustedEndPos.y, adjustedEndPos.z);\r\n          positionsUpdated = true;\r\n        }\r\n        \r\n        // Check if this connection needs color update\r\n        const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n        const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n        \r\n        // Track if this is a high-priority connection that needs immediate updates\r\n        const isHighPriorityConnection = isSelected || isHovered;\r\n        \r\n        // Always update colors for selected/hovered connections, otherwise throttle\r\n        if (isHighPriorityConnection || shouldUpdateColors) {\r\n          let color;\r\n          if (isSelected) {\r\n            // Simplified color animation for selected connections\r\n            const pulse = Math.sin(state.clock.elapsedTime * 2) * 0.1 + 0.9;\r\n            color = new THREE.Color(0x00bfff).multiplyScalar(pulse);\r\n          } else if (isHovered) {\r\n            color = new THREE.Color(0x88ccff);\r\n          } else {\r\n            color = new THREE.Color(0x444444);\r\n          }\r\n          \r\n          colorAttribute.setXYZ(i * 2, color.r, color.g, color.b);\r\n          colorAttribute.setXYZ(i * 2 + 1, color.r, color.g, color.b);\r\n          colorsUpdated = true;\r\n        }\r\n      }\r\n      \r\n      // Only mark attributes as needing update if they changed\r\n      if (positionsUpdated) {\r\n        positionAttribute.needsUpdate = true;\r\n      }\r\n      if (colorsUpdated) {\r\n        colorAttribute.needsUpdate = true;\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error updating connection positions and colors:\", error);\r\n    }\r\n  });\r\n\r\n  // Create the shader material with enhanced visibility\r\n  useEffect(() => {\r\n    if (geometryRef.current) {\r\n      const material = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          time: { value: 0 }\r\n        },\r\n        vertexShader: connectionVertexShader,\r\n        fragmentShader: connectionFragmentShader,\r\n        vertexColors: true,\r\n        transparent: true,\r\n        side: DoubleSide,\r\n        depthWrite: false,\r\n        // Ensure lines are always rendered on top\r\n        depthTest: true,\r\n        // Increase line brightness for better visibility\r\n        opacity: 1.0\r\n      });\r\n      \r\n      if (lineSegmentsRef.current) {\r\n        lineSegmentsRef.current.material = material;\r\n        connectionMaterialRef.current = material;\r\n        // Ensure connections are visible regardless of frustum culling\r\n        lineSegmentsRef.current.frustumCulled = false;\r\n        // Set render order to ensure connections render after nodes\r\n        lineSegmentsRef.current.renderOrder = 10;\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Enhanced connection management to ensure proper rendering\r\n  useEffect(() => {\r\n    if (geometryRef.current && lineCount > 0) {\r\n      geometryRef.current.setDrawRange(0, lineCount * 2);\r\n      \r\n      // Log connection counts to help with debugging\r\n      console.log(`Setting draw range for ${lineCount} connections (${lineCount * 2} vertices)`);\r\n      \r\n      // Force immediate update to ensure connections are visible\r\n      if (geometryRef.current.attributes.position) {\r\n        geometryRef.current.attributes.position.needsUpdate = true;\r\n      }\r\n      if (geometryRef.current.attributes.color) {\r\n        geometryRef.current.attributes.color.needsUpdate = true;\r\n      }\r\n    }\r\n  }, [lineCount]);\r\n\r\n  return (\r\n    <lineSegments ref={lineSegmentsRef} frustumCulled={false}>\r\n      <bufferGeometry ref={geometryRef} />\r\n    </lineSegments>\r\n  );\r\n});\r\n\r\nexport { ConnectionsBatched };\r\n"],"names":["circuitVertexShader","circuitFragmentShader","forceFieldVertexShader","forceFieldFragmentShader","triadColors","Color","getNodeColor","character","lowerChar","NodesInstanced","forwardRef","props","ref","nodes","nodePositions","connections","overrideSelectedNodeId","onNodeClick","clickableNodeIds","isInitialChoicePhase","positionSynchronizer","dispatch","useDispatch","hoveredNodeId","useSelector","selectHoveredNodeId","reduxSelectedNodeId","selectSelectedNodeId","selectedNodeId","connectedNodeIds","useMemo","connected","c","materialRefs","useRef","forceFieldMaterialRefs","nodeMeshRefs","forceFieldMeshRefs","originalPositions","node","position","frameCount","lastUpdatePositionsTime","lastUpdateMaterialsTime","useFrame","state","time","currentPositions","_","i","material","_a","nodeMesh","origPos","isDesignatedStartingNodeForPulse","targetScale","isImportantNode","forceMesh","syncedPos","jsx","THREE.BufferGeometry","THREE.MeshBasicMaterial","index","isSelected","isConnected","isHovered","isDesignatedStartingNode","labelText","nodeColor","jsxs","Text","mesh","e","nodeUnhoverEvent","nodeSelected","visitNode","setViewMode","navigateToNode","error","nodeHovered","nodeHoverEvent","nodeUnhovered","connectionVertexShader","connectionFragmentShader","ConnectionsBatched","lineSegmentsRef","React","geometryRef","connectionMaterialRef","positions","colors","lineCount","connection","startNodePos","endNodePos","directionVector","THREE.Vector3","nodeRadius","adjustedStartPos","adjustedEndPos","color","THREE.Color","useEffect","geometry","currentColors","_b","THREE.Float32BufferAttribute","positionAttribute","colorAttribute","lastUpdateTime","UPDATE_INTERVAL","currentTime","timeSinceLastUpdate","syncedPositions","shouldUpdatePositions","shouldUpdateColors","positionsUpdated","colorsUpdated","startPos","endPos","pulse","THREE.ShaderMaterial","DoubleSide"],"mappings":"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"}