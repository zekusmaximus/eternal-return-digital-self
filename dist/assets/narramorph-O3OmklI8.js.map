{"version":3,"file":"narramorph-O3OmklI8.js","sources":["../../src/hooks/useNodeState.ts","../../src/components/NodeView/TransformationAnimationContainer.tsx"],"sourcesContent":["/**\r\n * Custom hook for managing node state and transformations\r\n * Provides utilities for accessing, navigating, and transforming nodes\r\n */\r\n\r\nimport { useCallback, useEffect, useMemo, useState, useRef } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  selectNodeById,\r\n  visitNode,\r\n  revealConnection,\r\n  applyTransformation,\r\n  evaluateTransformations,\r\n  applyJourneyTransformations\r\n} from '../store/slices/nodesSlice';\r\nimport {\r\n  navigateToNode,\r\n  engageAttractor,\r\n  selectCurrentNodeId,\r\n  selectNodeRevisitCount\r\n} from '../store/slices/readerSlice';\r\nimport { setViewMode } from '../store/slices/interfaceSlice';\r\nimport { StrangeAttractor, TransformationRule, TransformationCondition, TextTransformation } from '../types';\r\nimport { RootState } from '../store/types';\r\nimport { transformationEngine } from '../services/TransformationEngine';\r\nimport { transformationService } from '../services/TransformationService';\r\n\r\n// Import the CSS for transformations\r\nimport '../styles/NarramorphTransformations.css';\r\n\r\n/**\r\n * Custom hook for node state management and transformations\r\n * @param nodeId Optional node ID to focus on\r\n */\r\nexport const useNodeState = (nodeId?: string) => {\r\n  const dispatch = useDispatch();\r\n  // Track applied transformations for transitions\r\n  const [appliedTransformations, setAppliedTransformations] = useState<TextTransformation[]>([]);\r\n  // Track if transformations were just applied for animation\r\n  const [newlyTransformed, setNewlyTransformed] = useState(false);  // Track which nodes have had transformations applied to prevent repeated dispatches\r\n  const appliedNodesRef = useRef<Set<string>>(new Set());\r\n  // Throttle transformation dispatches to prevent excessive calls\r\n  const lastTransformationDispatchRef = useRef<number>(0);\r\n\r\n  // Get current node ID if not provided\r\n  const currentNodeId = useSelector(selectCurrentNodeId);\r\n  const targetNodeId = nodeId || currentNodeId;\r\n\r\n  // Select node data\r\n  const node = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeById(state, targetNodeId) : null\r\n  );\r\n\r\n  // Select all nodes to access any node data\r\n  const allNodes = useSelector((state: RootState) => state.nodes.data);\r\n\r\n  // Get revisit count\r\n  const revisitCount = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeRevisitCount(state, targetNodeId) : 0\r\n  );\r\n\r\n  // Get reader state for transformation evaluation\r\n  // Used in evaluateTransformations and evaluateCondition\r\n  const readerState = useSelector((state: RootState) => state.reader);\r\n  \r\n  // Navigate to a node\r\n  const navigateTo = useCallback((id: string) => {\r\n    const nodeData = allNodes[id];\r\n    \r\n    if (nodeData) {\r\n      // Record navigation in reader path with required properties\r\n      dispatch(navigateToNode({\r\n        nodeId: id,\r\n        character: nodeData.character,\r\n        temporalValue: nodeData.temporalValue,\r\n        attractors: nodeData.strangeAttractors\r\n      }));\r\n      \r\n      // Record visit in node state\r\n      dispatch(visitNode(id));\r\n      \r\n      // Switch to reading view\r\n      dispatch(setViewMode('reading'));\r\n      \r\n      // This would be where we load the node content in a real implementation\r\n      // For now, we'll just log it\r\n      console.log(`Navigating to node: ${id}`);\r\n    } else {\r\n      console.error(`Could not navigate to node: ${id} - node data not found`);\r\n    }\r\n  }, [dispatch, allNodes]);\r\n  \r\n  // Reveal a new connection\r\n  const revealNodeConnection = useCallback((sourceId: string, targetId: string) => {\r\n    dispatch(revealConnection({ nodeId: sourceId, targetId }));\r\n  }, [dispatch]);\r\n  \r\n  // Engage with a strange attractor\r\n  const engageWithAttractor = useCallback((attractor: StrangeAttractor) => {\r\n    dispatch(engageAttractor(attractor));\r\n  }, [dispatch]);\r\n  \r\n  // Apply a transformation to the node's content\r\n  const applyNodeTransformation = useCallback((\r\n    nodeId: string, \r\n    transformation: TransformationRule\r\n  ) => {\r\n    dispatch(applyTransformation({ nodeId, transformation }));\r\n  }, [dispatch]);\r\n  \r\n  // Get neighboring nodes based on revealed connections\r\n  const neighbors = useMemo(() => {\r\n    if (!node) return [];\r\n    return node.revealedConnections;\r\n  }, [node]);  // Calculate all transformations using the new master integration method\r\n  const allTransformations = useMemo(() => {\r\n    if (!node?.currentContent) return [];\r\n    \r\n    // Use the new master transformation coordination method\r\n    // This automatically handles character bleed, journey patterns, and node rules\r\n    // with proper priority ordering, deduplication, and caching\r\n    try {\r\n      const allNodeStates = {}; // Could be passed from parent component if available\r\n      const transformations = transformationEngine.calculateAllTransformations(\r\n        node.currentContent,\r\n        node,\r\n        readerState,\r\n        allNodeStates\r\n      );\r\n      \r\n      console.log(`[useNodeState] Master transformation integration calculated ${transformations.length} transformations for node ${node.id}`);\r\n      return transformations;\r\n      \r\n    } catch (error) {\r\n      console.error(`[useNodeState] Error in master transformation calculation for node ${node.id}:`, error);\r\n      return [];\r\n    }\r\n  }, [node, readerState]);\r\n  // Generate transformed content using the new master integration method\r\n  const transformedContent = useMemo(() => {\r\n    if (!node?.currentContent) return node?.currentContent || null;\r\n\r\n    try {\r\n      // Use the new master getTransformedContent method\r\n      // This automatically handles all transformation coordination, caching, and content application\r\n      const allNodeStates = {}; // Could be passed from parent component if available\r\n      const fullyTransformedContent = transformationEngine.getTransformedContent(\r\n        node,\r\n        readerState,\r\n        allNodeStates\r\n      );\r\n\r\n      // Add wrapper elements with transition classes if transformations were applied\r\n      if (fullyTransformedContent !== node.currentContent && allTransformations.length > 0) {\r\n        const wrappedContent = transformationService.wrapTransformedContent(\r\n          fullyTransformedContent,\r\n          allTransformations\r\n        );\r\n        return wrappedContent;\r\n      }\r\n\r\n      return fullyTransformedContent;\r\n      \r\n    } catch (error) {\r\n      console.error(`[useNodeState] Error in master content transformation for node ${node.id}:`, error);\r\n      return node?.currentContent || null;\r\n    }\r\n  }, [node, readerState, allTransformations]);\r\n\r\n  // Track transformation changes in a separate effect to prevent infinite loops\r\n  useEffect(() => {\r\n    if (!node || allTransformations.length === 0) return;\r\n\r\n    // Check if transformations actually changed\r\n    const transformationsChanged = JSON.stringify(appliedTransformations) !== JSON.stringify(allTransformations);\r\n    \r\n    if (transformationsChanged) {\r\n      setAppliedTransformations(allTransformations);\r\n      setNewlyTransformed(true);\r\n\r\n      // Log transformation details for debugging\r\n      if (process.env.NODE_ENV === 'development') {\r\n        const journeyTransformations = allTransformations.filter(t => t.priority === 'high');\r\n        console.log(`[useNodeState] Applied transformations for node ${node.id}:`, {\r\n          journeyTransformations: journeyTransformations.length,\r\n          patternTransformations: allTransformations.filter(t => t.priority !== 'high' && !node.transformations.some(rule => rule.transformations.includes(t))).length,\r\n          ruleTransformations: allTransformations.filter(t => t.priority !== 'high' && node.transformations.some(rule => rule.transformations.includes(t))).length,\r\n          totalTransformations: allTransformations.length,\r\n          hasCharacterBleed: journeyTransformations.some(t => t.type === 'emphasize' || t.type === 'fragment'),\r\n          journeyContext: node.journeyContext\r\n        });\r\n      }\r\n    }\r\n  }, [node, allTransformations, appliedTransformations]);\r\n  \r\n  // Reset newly transformed flag after animation\r\n  useEffect(() => {\r\n    if (newlyTransformed) {\r\n      const timer = setTimeout(() => {\r\n        setNewlyTransformed(false);\r\n      }, 2000); // Match the animation duration\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [newlyTransformed]);  // Apply transformations based on visit count and reader patterns - CRITICAL FIX to prevent infinite loops\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId) return;\r\n    \r\n    // Throttle: Only allow transformation dispatches every 500ms\r\n    const now = Date.now();\r\n    if (now - lastTransformationDispatchRef.current < 500) {\r\n      return;\r\n    }\r\n    \r\n    // INFINITE LOOP PREVENTION: Check if content is already transformed\r\n    if (node.currentContent && (\r\n      node.currentContent.includes('data-transform-type') || \r\n      node.currentContent.includes('narramorph-') ||\r\n      node.currentContent.includes('[TransformationService]') ||\r\n      node.currentContent.includes('recursive loop detected') ||\r\n      node.currentContent.includes('temporal displacement')\r\n    )) {\r\n      console.log(`[useNodeState] Content already transformed for node ${targetNodeId}, skipping to prevent infinite loop`);\r\n      return;\r\n    }\r\n    \r\n    // Create a unique key based on ONLY the navigation state, not content changes\r\n    // This prevents re-triggering when transformations modify the content\r\n    const nodeKey = `${targetNodeId}-${node.visitCount}`;\r\n    \r\n    // Check if we've already applied transformations for this exact combination\r\n    if (appliedNodesRef.current.has(nodeKey)) {\r\n      console.log(`[useNodeState] Skipping already applied transformations for ${nodeKey}`);\r\n      return;\r\n    }    // Only apply transformations when the node actually changes, not when reader state changes\r\n    console.log(`[useNodeState] Applying transformations for node ${targetNodeId} (visitCount: ${node.visitCount})`);\r\n    \r\n    // Update the last dispatch timestamp BEFORE dispatching\r\n    lastTransformationDispatchRef.current = now;\r\n    \r\n    // Mark this node+visit combination as processed BEFORE dispatching to prevent race conditions\r\n    appliedNodesRef.current.add(nodeKey);\r\n    \r\n    // Cleanup old entries to prevent memory leaks (keep only last 50 entries)\r\n    if (appliedNodesRef.current.size > 50) {\r\n      const entries = Array.from(appliedNodesRef.current);\r\n      const toKeep = entries.slice(-25); // Keep last 25 entries\r\n      appliedNodesRef.current.clear();\r\n      toKeep.forEach(key => appliedNodesRef.current.add(key));\r\n    }\r\n\r\n    // Apply journey transformations (character bleed + journey context) - but only once per node\r\n    dispatch(applyJourneyTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n\r\n    // Generate default transformations based on visit count\r\n    if (node.visitCount === 1) {\r\n      const basicTransformation: TransformationRule = {\r\n        condition: {\r\n          visitCount: 1\r\n        },\r\n        transformations: [\r\n          {\r\n            type: 'emphasize',\r\n            selector: 'first-paragraph',\r\n            emphasis: 'italic'\r\n          }\r\n        ]\r\n      };\r\n      \r\n      applyNodeTransformation(targetNodeId, basicTransformation);\r\n    }\r\n\r\n    // Generate pattern-based transformations (with reduced frequency to prevent loops)\r\n    if (node.visitCount >= 2 && node.visitCount <= 5) { // Limit pattern generation to early visits\r\n      const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n        readerState,\r\n        node\r\n      );\r\n      \r\n      // Apply these transformations only if they're not too many\r\n      if (patternTransformations.length > 0 && patternTransformations.length <= 3) {\r\n        const patternBasedRule: TransformationRule = {\r\n          condition: { visitCount: node.visitCount },\r\n          transformations: patternTransformations\r\n        };\r\n        \r\n        applyNodeTransformation(targetNodeId, patternBasedRule);\r\n      }\r\n    }\r\n\r\n    // Evaluate transformations against current reader state (with throttling)\r\n    dispatch(evaluateTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n  }, [targetNodeId, node, dispatch, applyNodeTransformation, readerState]); // Fixed dependencies  // TEMPORARILY DISABLED: Update content variants when reader state changes\r\n  // This effect was causing content to disappear due to re-selection loops\r\n  // TODO: Re-enable with proper dependency management\r\n  /*\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId || !node.enhancedContent) return;\r\n\r\n    // Create selection context and update content variant if needed\r\n    try {\r\n      const context = {\r\n        visitCount: node.visitCount,\r\n        lastVisitedCharacter: readerState.path.sequence.length > 1 \r\n          ? allNodes[readerState.path.sequence[readerState.path.sequence.length - 2]]?.character \r\n          : undefined,\r\n        journeyPattern: readerState.path.sequence.slice(-5),\r\n        characterSequence: readerState.path.sequence\r\n          .slice(-5)\r\n          .map(id => allNodes[id]?.character)\r\n          .filter((char): char is Character => char !== undefined),\r\n        attractorsEngaged: readerState.path.attractorsEngaged || {},\r\n        recursiveAwareness: readerState.path.sequence.length > 0 \r\n          ? 1 - (new Set(readerState.path.sequence).size / readerState.path.sequence.length)\r\n          : 0\r\n      };\r\n\r\n      // Import dynamically to avoid circular dependencies\r\n      import('../services/ContentVariantService').then(({ contentVariantService }) => {\r\n        const selectedContent = contentVariantService.selectContentVariant(\r\n          node.enhancedContent!,\r\n          context\r\n        );\r\n\r\n        // Only dispatch if the content actually changed\r\n        if (selectedContent !== node.currentContent) {\r\n          dispatch(updateContentVariant({ \r\n            nodeId: targetNodeId, \r\n            context,\r\n            selectedContent \r\n          }));\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.warn(`[useNodeState] Error updating content variant for node ${targetNodeId}:`, error);\r\n    }\r\n  }, [node, targetNodeId, readerState.path, allNodes, dispatch]);\r\n  */\r\n  \r\n  // Evaluate a condition directly using the transformation engine\r\n  const evaluateCondition = useCallback(\r\n    (condition: TransformationCondition) => {\r\n      if (!node) return false;\r\n      return transformationEngine.evaluateCondition(condition, readerState, node);\r\n    },\r\n    [node, readerState]\r\n  );\r\n  \r\n  // Return the API\r\n  return {\r\n    node,\r\n    navigateTo,\r\n    revealNodeConnection,\r\n    engageWithAttractor,\r\n    applyNodeTransformation,\r\n    evaluateCondition,\r\n    neighbors,\r\n    revisitCount,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  };\r\n};\r\n\r\nexport default useNodeState;","/**\r\n * TransformationAnimationContainer Component\r\n * \r\n * Provides enhanced transition animations when content transforms between states.\r\n * This component wraps around transformed content and adds visual context\r\n * to help users understand the transformation process.\r\n */\r\n\r\nimport React, { useEffect, useRef, useState, useLayoutEffect } from 'react';\r\nimport { TextTransformation } from '../../types';\r\n\r\n// For debugging DOM measurements and layout issues\r\ninterface ElementMeasurements {\r\n  width: number;\r\n  height: number;\r\n  visibility: string;\r\n  display: string;\r\n  opacity: string;\r\n  position: string;\r\n  zIndex: string;\r\n  overflow: string;\r\n}\r\n\r\ninterface TransformationAnimationContainerProps {\r\n  children: React.ReactNode;\r\n  transformations: TextTransformation[];\r\n  isNewlyTransformed: boolean;\r\n  nodeId: string;\r\n}\r\n\r\nconst TransformationAnimationContainer: React.FC<TransformationAnimationContainerProps> = ({\r\n  children,\r\n  transformations,\r\n  isNewlyTransformed,\r\n  nodeId\r\n}): React.ReactElement => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [animationState, setAnimationState] = useState<'idle' | 'entering' | 'active'>('idle');\r\n  const [transformationCount, setTransformationCount] = useState(transformations.length);\r\n  const [renderAttempt, setRenderAttempt] = useState(0);\r\n  \r\n  // Track DOM measurements for debugging\r\n  const [measurements, setMeasurements] = useState<ElementMeasurements | null>(null);\r\n  const [contentVisible, setContentVisible] = useState(true);\r\n  \r\n  // Force a re-render after mount to ensure visibility\r\n  useEffect(() => {\r\n    // After mount, force a re-render to ensure proper layout\r\n    // Limit to max 3 attempts to prevent infinite loops\r\n    if (renderAttempt < 3) {\r\n      const timer = setTimeout(() => {\r\n        setRenderAttempt(prev => prev + 1);\r\n        console.log(`[AnimationContainer] Forced re-render for node: ${nodeId}, attempt: ${renderAttempt + 1}`);\r\n      }, 100);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [nodeId, renderAttempt]);\r\n  \r\n  // When transformations change, update the animation state\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      setAnimationState('entering');\r\n      \r\n      // After the animation completes, set to active state\r\n      const timer = setTimeout(() => {\r\n        setAnimationState('active');\r\n      }, 1000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isNewlyTransformed, transformations]);\r\n  \r\n  // When node changes or transformation count changes, reset animation state\r\n  useEffect(() => {\r\n    setAnimationState('idle');\r\n    setTransformationCount(transformations.length);\r\n    \r\n    // Debug log for node changes\r\n    console.log(`[AnimationContainer] Node changed to: ${nodeId}, transformations: ${transformations.length}`);\r\n  }, [nodeId, transformations.length]);\r\n  \r\n  // Monitor and log DOM measurements for debugging visibility issues\r\n  useLayoutEffect(() => {\r\n    if (!containerRef.current) return;\r\n    \r\n    // Function to measure DOM element properties\r\n    const measureElement = () => {\r\n      if (!containerRef.current) return;\r\n      \r\n      const style = window.getComputedStyle(containerRef.current);\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      \r\n      const newMeasurements: ElementMeasurements = {\r\n        width: rect.width,\r\n        height: rect.height,\r\n        visibility: style.visibility,\r\n        display: style.display,\r\n        opacity: style.opacity,\r\n        position: style.position,\r\n        zIndex: style.zIndex,\r\n        overflow: style.overflow\r\n      };\r\n      \r\n      setMeasurements(newMeasurements);\r\n      \r\n      // Check if content is visible in DOM\r\n      const isVisible = rect.width > 0 &&\r\n                        rect.height > 0 &&\r\n                        style.visibility !== 'hidden' &&\r\n                        style.display !== 'none' &&\r\n                        parseFloat(style.opacity) > 0;\r\n                        \r\n      setContentVisible(isVisible);\r\n      \r\n      // Log significant changes to visibility\r\n      if (contentVisible !== isVisible) {\r\n        console.log(`[AnimationContainer] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`, {\r\n          nodeId,\r\n          transformations: transformations.length,\r\n          animationState,\r\n          measurements: newMeasurements\r\n        });\r\n      }\r\n    };\r\n    \r\n    // Measure immediately\r\n    measureElement();\r\n    \r\n    // Measure after animations might be complete\r\n    const timer = setTimeout(measureElement, 1100);\r\n    \r\n    // Set up mutation observer to track DOM changes - with debouncing\r\n    let timeoutId: number | null = null;\r\n    const observer = new MutationObserver((mutations) => {\r\n      // Only log significant mutations to reduce noise\r\n      if (mutations.length > 2) {\r\n        console.log(`[AnimationContainer] DOM mutations detected: ${mutations.length}`);\r\n      }\r\n      \r\n      // Debounce measurements to prevent infinite loops\r\n      if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      \r\n      timeoutId = window.setTimeout(() => {\r\n        measureElement();\r\n        timeoutId = null;\r\n      }, 500);\r\n    });\r\n    \r\n    observer.observe(containerRef.current, {\r\n      attributes: true,\r\n      childList: true,\r\n      subtree: false // Reduced to false to prevent excessive notifications\r\n    });\r\n    \r\n    return () => {\r\n      clearTimeout(timer);\r\n      observer.disconnect();\r\n    };\r\n  }, [nodeId, transformations, animationState, contentVisible]);\r\n  \r\n  // Determine which animation effect to apply based on transformation types\r\n  const getAnimationClass = () => {\r\n    if (animationState === 'idle') return '';\r\n    \r\n    const hasReplacements = transformations.some(t => t.type === 'replace');\r\n    const hasEmphasis = transformations.some(t => t.type === 'emphasize');\r\n    const hasExpansions = transformations.some(t => t.type === 'expand');\r\n    \r\n    if (animationState === 'entering') {\r\n      if (hasReplacements) return 'narramorph-container-replace-active';\r\n      if (hasEmphasis) return 'narramorph-container-emphasis-active';\r\n      if (hasExpansions) return 'narramorph-container-expand-active';\r\n      return 'narramorph-container-transform-active';\r\n    }\r\n    \r\n    return 'narramorph-container-active';\r\n  };\r\n  \r\n  // Get a description of transformation activity\r\n  const getTransformationDescription = () => {\r\n    if (transformations.length === 0) return '';\r\n    \r\n    const typeCount: Record<string, number> = {};\r\n    transformations.forEach(t => {\r\n      typeCount[t.type] = (typeCount[t.type] || 0) + 1;\r\n    });\r\n    \r\n    // Generate a description based on the types of transformations\r\n    const descriptions = [];\r\n    \r\n    if (typeCount['replace']) {\r\n      descriptions.push(`${typeCount['replace']} replacements`);\r\n    }\r\n    \r\n    if (typeCount['emphasize']) {\r\n      descriptions.push(`${typeCount['emphasize']} emphasis`);\r\n    }\r\n    \r\n    if (typeCount['expand']) {\r\n      descriptions.push(`${typeCount['expand']} expansions`);\r\n    }\r\n    \r\n    if (typeCount['fragment']) {\r\n      descriptions.push(`${typeCount['fragment']} fragmentations`);\r\n    }\r\n    \r\n    if (typeCount['metaComment']) {\r\n      descriptions.push(`${typeCount['metaComment']} comments`);\r\n    }\r\n    \r\n    return descriptions.join(', ');\r\n  };\r\n  \r\n  // Check if number of transformations has changed\r\n  const hasChangedTransformations = transformations.length !== transformationCount;\r\n  \r\n  // Log when animations are triggered\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      console.log(`[AnimationContainer] Animation started for node: ${nodeId}`, {\r\n        transformations: transformations.length,\r\n        animationState,\r\n        contentVisible\r\n      });\r\n    }\r\n  }, [isNewlyTransformed, nodeId, transformations.length, animationState, contentVisible]);\r\n  \r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`narramorph-animation-container ${getAnimationClass()}`}\r\n      data-transformation-count={transformations.length}\r\n      data-newly-transformed={isNewlyTransformed}\r\n      data-animation-state={animationState}\r\n      data-visible={contentVisible}\r\n      data-render-attempt={renderAttempt}\r\n      style={{\r\n        overflow: 'visible',\r\n        minHeight: '150px',\r\n        position: 'relative', // Ensure positioning context\r\n        visibility: 'visible',\r\n        display: 'block',\r\n        opacity: 1\r\n      }}\r\n    >\r\n      {/* Visual indicator for active transformations */}\r\n      {transformations.length > 0 && (\r\n        <div \r\n          className={`narramorph-transformation-indicator ${isNewlyTransformed ? 'active' : ''}`}\r\n          title={getTransformationDescription()}\r\n        >\r\n          <span className=\"transformation-count\">{transformations.length}</span>\r\n          {hasChangedTransformations && (\r\n            <span className=\"transformation-change-indicator\">\r\n              {transformations.length > transformationCount ? '+' : ''}\r\n              {transformations.length - transformationCount}\r\n            </span>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content with transformations */}\r\n      <div\r\n        ref={contentRef}\r\n        className=\"narramorph-animation-content\"\r\n        style={{\r\n          position: 'relative',\r\n          visibility: 'visible',\r\n          display: 'block',\r\n          opacity: 1,\r\n          minHeight: '100px'\r\n        }}\r\n      >\r\n        {renderAttempt === 0 ? (\r\n          <div className=\"animation-placeholder\" style={{ padding: '20px', textAlign: 'center' }}>\r\n            <p>Preparing narrative...</p>\r\n          </div>\r\n        ) : (\r\n          children\r\n        )}\r\n      </div>\r\n      \r\n      {/* Debug info overlay - only in development */}\r\n      {process.env.NODE_ENV === 'development' && measurements && (\r\n        <div\r\n          className=\"animation-debug-info\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: 0,\r\n            right: 0,\r\n            background: 'rgba(0,0,0,0.7)',\r\n            color: '#fff',\r\n            padding: '3px',\r\n            fontSize: '9px',\r\n            zIndex: 1000,\r\n            pointerEvents: 'none'\r\n          }}\r\n        >\r\n          <div>{`${Math.round(measurements.width)}x${Math.round(measurements.height)}`}</div>\r\n          <div>{`Vis:${measurements.visibility.charAt(0)}|Dis:${measurements.display.charAt(0)}`}</div>\r\n          <div>{`Op:${parseFloat(measurements.opacity).toFixed(1)}|Z:${measurements.zIndex}`}</div>\r\n          <div>{`T:${transformations.length}|S:${animationState.charAt(0)}`}</div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TransformationAnimationContainer;"],"names":["useNodeState","nodeId","dispatch","useDispatch","appliedTransformations","setAppliedTransformations","useState","newlyTransformed","setNewlyTransformed","appliedNodesRef","useRef","lastTransformationDispatchRef","currentNodeId","useSelector","selectCurrentNodeId","targetNodeId","node","state","selectNodeById","allNodes","revisitCount","selectNodeRevisitCount","readerState","navigateTo","useCallback","id","nodeData","navigateToNode","visitNode","setViewMode","revealNodeConnection","sourceId","targetId","revealConnection","engageWithAttractor","attractor","engageAttractor","applyNodeTransformation","transformation","applyTransformation","neighbors","useMemo","allTransformations","allNodeStates","transformations","transformationEngine","error","transformedContent","fullyTransformedContent","transformationService","useEffect","timer","now","nodeKey","toKeep","key","applyJourneyTransformations","patternTransformations","patternBasedRule","evaluateTransformations","evaluateCondition","condition","TransformationAnimationContainer","children","isNewlyTransformed","containerRef","contentRef","animationState","setAnimationState","transformationCount","setTransformationCount","renderAttempt","setRenderAttempt","measurements","setMeasurements","contentVisible","setContentVisible","prev","useLayoutEffect","measureElement","style","rect","newMeasurements","isVisible","timeoutId","observer","mutations","getAnimationClass","hasReplacements","hasEmphasis","hasExpansions","getTransformationDescription","typeCount","t","descriptions","hasChangedTransformations","jsxs","jsx"],"mappings":"2OAkCa,MAAAA,EAAgBC,GAAoB,CAC/C,MAAMC,EAAWC,EAAY,EAEvB,CAACC,EAAwBC,CAAyB,EAAIC,EAAAA,SAA+B,CAAA,CAAE,EAEvF,CAACC,EAAkBC,CAAmB,EAAIF,EAAAA,SAAS,EAAK,EACxDG,EAAkBC,EAAAA,OAAwB,IAAA,GAAK,EAE/CC,EAAgCD,SAAe,CAAC,EAGhDE,EAAgBC,EAAYC,CAAmB,EAC/CC,EAAed,GAAUW,EAGzBI,EAAOH,EAAaI,GACxBF,EAAeG,EAAeD,EAAOF,CAAY,EAAI,IACvD,EAGMI,EAAWN,EAAaI,GAAqBA,EAAM,MAAM,IAAI,EAG7DG,EAAeP,EAAaI,GAChCF,EAAeM,EAAuBJ,EAAOF,CAAY,EAAI,CAC/D,EAIMO,EAAcT,EAAaI,GAAqBA,EAAM,MAAM,EAG5DM,EAAaC,cAAaC,GAAe,CACvC,MAAAC,EAAWP,EAASM,CAAE,EAExBC,GAEFxB,EAASyB,EAAe,CACtB,OAAQF,EACR,UAAWC,EAAS,UACpB,cAAeA,EAAS,cACxB,WAAYA,EAAS,iBAAA,CACtB,CAAC,EAGOxB,EAAA0B,EAAUH,CAAE,CAAC,EAGbvB,EAAA2B,EAAY,SAAS,CAAC,EAIvB,QAAA,IAAI,uBAAuBJ,CAAE,EAAE,GAE/B,QAAA,MAAM,+BAA+BA,CAAE,wBAAwB,CACzE,EACC,CAACvB,EAAUiB,CAAQ,CAAC,EAGjBW,EAAuBN,EAAAA,YAAY,CAACO,EAAkBC,IAAqB,CAC/E9B,EAAS+B,EAAiB,CAAE,OAAQF,EAAU,SAAAC,CAAU,CAAA,CAAC,CAAA,EACxD,CAAC9B,CAAQ,CAAC,EAGPgC,EAAsBV,cAAaW,GAAgC,CAC9DjC,EAAAkC,EAAgBD,CAAS,CAAC,CAAA,EAClC,CAACjC,CAAQ,CAAC,EAGPmC,EAA0Bb,EAAAA,YAAY,CAC1CvB,EACAqC,IACG,CACHpC,EAASqC,EAAoB,CAAE,OAAAtC,EAAQ,eAAAqC,CAAgB,CAAA,CAAC,CAAA,EACvD,CAACpC,CAAQ,CAAC,EAGPsC,EAAYC,EAAAA,QAAQ,IACnBzB,EACEA,EAAK,oBADM,CAAC,EAElB,CAACA,CAAI,CAAC,EACH0B,EAAqBD,EAAAA,QAAQ,IAAM,CACvC,GAAI,EAACzB,GAAA,MAAAA,EAAM,gBAAgB,MAAO,CAAC,EAK/B,GAAA,CACF,MAAM2B,EAAgB,CAAC,EACjBC,EAAkBC,EAAqB,4BAC3C7B,EAAK,eACLA,EACAM,EACAqB,CACF,EAEA,eAAQ,IAAI,+DAA+DC,EAAgB,MAAM,6BAA6B5B,EAAK,EAAE,EAAE,EAChI4B,QAEAE,EAAO,CACd,eAAQ,MAAM,sEAAsE9B,EAAK,EAAE,IAAK8B,CAAK,EAC9F,CAAC,CAAA,CACV,EACC,CAAC9B,EAAMM,CAAW,CAAC,EAEhByB,EAAqBN,EAAAA,QAAQ,IAAM,CACvC,GAAI,EAACzB,GAAA,MAAAA,EAAM,gBAAgB,OAAOA,GAAA,YAAAA,EAAM,iBAAkB,KAEtD,GAAA,CAGF,MAAM2B,EAAgB,CAAC,EACjBK,EAA0BH,EAAqB,sBACnD7B,EACAM,EACAqB,CACF,EAGA,OAAIK,IAA4BhC,EAAK,gBAAkB0B,EAAmB,OAAS,EAC1DO,EAAsB,uBAC3CD,EACAN,CACF,EAIKM,QAEAF,EAAO,CACd,eAAQ,MAAM,kEAAkE9B,EAAK,EAAE,IAAK8B,CAAK,GAC1F9B,GAAA,YAAAA,EAAM,iBAAkB,IAAA,CAEhC,EAAA,CAACA,EAAMM,EAAaoB,CAAkB,CAAC,EAG1CQ,EAAAA,UAAU,IAAM,CACd,GAAI,CAAClC,GAAQ0B,EAAmB,SAAW,EAAG,OAGf,KAAK,UAAUtC,CAAsB,IAAM,KAAK,UAAUsC,CAAkB,IAGzGrC,EAA0BqC,CAAkB,EAC5ClC,EAAoB,EAAI,EAezB,EAAA,CAACQ,EAAM0B,EAAoBtC,CAAsB,CAAC,EAGrD8C,EAAAA,UAAU,IAAM,CACd,GAAI3C,EAAkB,CACd,MAAA4C,EAAQ,WAAW,IAAM,CAC7B3C,EAAoB,EAAK,GACxB,GAAI,EAEA,MAAA,IAAM,aAAa2C,CAAK,CAAA,CACjC,EACC,CAAC5C,CAAgB,CAAC,EACrB2C,EAAAA,UAAU,IAAM,CACV,GAAA,CAAClC,GAAQ,CAACD,EAAc,OAGtB,MAAAqC,EAAM,KAAK,IAAI,EACjB,GAAAA,EAAMzC,EAA8B,QAAU,IAChD,OAIE,GAAAK,EAAK,iBACPA,EAAK,eAAe,SAAS,qBAAqB,GAClDA,EAAK,eAAe,SAAS,aAAa,GAC1CA,EAAK,eAAe,SAAS,yBAAyB,GACtDA,EAAK,eAAe,SAAS,yBAAyB,GACtDA,EAAK,eAAe,SAAS,uBAAuB,GACnD,CACO,QAAA,IAAI,uDAAuDD,CAAY,qCAAqC,EACpH,MAAA,CAKF,MAAMsC,EAAU,GAAGtC,CAAY,IAAIC,EAAK,UAAU,GAGlD,GAAIP,EAAgB,QAAQ,IAAI4C,CAAO,EAAG,CAChC,QAAA,IAAI,+DAA+DA,CAAO,EAAE,EACpF,MAAA,CAWE,GATJ,QAAQ,IAAI,oDAAoDtC,CAAY,iBAAiBC,EAAK,UAAU,GAAG,EAG/GL,EAA8B,QAAUyC,EAGxB3C,EAAA,QAAQ,IAAI4C,CAAO,EAG/B5C,EAAgB,QAAQ,KAAO,GAAI,CAE/B,MAAA6C,EADU,MAAM,KAAK7C,EAAgB,OAAO,EAC3B,MAAM,GAAG,EAChCA,EAAgB,QAAQ,MAAM,EAC9B6C,EAAO,QAAeC,GAAA9C,EAAgB,QAAQ,IAAI8C,CAAG,CAAC,CAAA,CA4BxD,GAxBArD,EAASsD,EAA4B,CACnC,OAAQzC,EACR,YAAAO,CAAA,CACD,CAAC,EAGEN,EAAK,aAAe,GActBqB,EAAwBtB,EAbwB,CAC9C,UAAW,CACT,WAAY,CACd,EACA,gBAAiB,CACf,CACE,KAAM,YACN,SAAU,kBACV,SAAU,QAAA,CACZ,CAEJ,CAEyD,EAIvDC,EAAK,YAAc,GAAKA,EAAK,YAAc,EAAG,CAChD,MAAMyC,EAAyBR,EAAsB,kCACnD3B,EACAN,CACF,EAGA,GAAIyC,EAAuB,OAAS,GAAKA,EAAuB,QAAU,EAAG,CAC3E,MAAMC,EAAuC,CAC3C,UAAW,CAAE,WAAY1C,EAAK,UAAW,EACzC,gBAAiByC,CACnB,EAEApB,EAAwBtB,EAAc2C,CAAgB,CAAA,CACxD,CAIFxD,EAASyD,EAAwB,CAC/B,OAAQ5C,EACR,YAAAO,CAAA,CACD,CAAC,CAAA,EACD,CAACP,EAAcC,EAAMd,EAAUmC,EAAyBf,CAAW,CAAC,EAgDvE,MAAMsC,EAAoBpC,EAAA,YACvBqC,GACM7C,EACE6B,EAAqB,kBAAkBgB,EAAWvC,EAAaN,CAAI,EADxD,GAGpB,CAACA,EAAMM,CAAW,CACpB,EAGO,MAAA,CACL,KAAAN,EACA,WAAAO,EACA,qBAAAO,EACA,oBAAAI,EACA,wBAAAG,EACA,kBAAAuB,EACA,UAAApB,EACA,aAAApB,EACA,mBAAA2B,EACA,iBAAAxC,EACA,uBAAAH,CACF,CACF,EClVM0D,EAAoF,CAAC,CACzF,SAAAC,EACA,gBAAAnB,EACA,mBAAAoB,EACA,OAAA/D,CACF,IAA0B,CAClB,MAAAgE,EAAevD,SAAuB,IAAI,EAC1CwD,EAAaxD,SAAuB,IAAI,EACxC,CAACyD,EAAgBC,CAAiB,EAAI9D,EAAAA,SAAyC,MAAM,EACrF,CAAC+D,EAAqBC,CAAsB,EAAIhE,EAAAA,SAASsC,EAAgB,MAAM,EAC/E,CAAC2B,EAAeC,CAAgB,EAAIlE,EAAAA,SAAS,CAAC,EAG9C,CAACmE,EAAcC,CAAe,EAAIpE,EAAAA,SAAqC,IAAI,EAC3E,CAACqE,EAAgBC,CAAiB,EAAItE,EAAAA,SAAS,EAAI,EAGzD4C,EAAAA,UAAU,IAAM,CAGd,GAAIqB,EAAgB,EAAG,CACf,MAAApB,EAAQ,WAAW,IAAM,CACZqB,EAAAK,GAAQA,EAAO,CAAC,EACjC,QAAQ,IAAI,mDAAmD5E,CAAM,cAAcsE,EAAgB,CAAC,EAAE,GACrG,GAAG,EAEC,MAAA,IAAM,aAAapB,CAAK,CAAA,CACjC,EACC,CAAClD,EAAQsE,CAAa,CAAC,EAG1BrB,EAAAA,UAAU,IAAM,CACd,GAAIc,EAAoB,CACtBI,EAAkB,UAAU,EAGtB,MAAAjB,EAAQ,WAAW,IAAM,CAC7BiB,EAAkB,QAAQ,GACzB,GAAI,EAEA,MAAA,IAAM,aAAajB,CAAK,CAAA,CACjC,EACC,CAACa,EAAoBpB,CAAe,CAAC,EAGxCM,EAAAA,UAAU,IAAM,CACdkB,EAAkB,MAAM,EACxBE,EAAuB1B,EAAgB,MAAM,EAG7C,QAAQ,IAAI,yCAAyC3C,CAAM,sBAAsB2C,EAAgB,MAAM,EAAE,CACxG,EAAA,CAAC3C,EAAQ2C,EAAgB,MAAM,CAAC,EAGnCkC,EAAAA,gBAAgB,IAAM,CAChB,GAAA,CAACb,EAAa,QAAS,OAG3B,MAAMc,EAAiB,IAAM,CACvB,GAAA,CAACd,EAAa,QAAS,OAE3B,MAAMe,EAAQ,OAAO,iBAAiBf,EAAa,OAAO,EACpDgB,EAAOhB,EAAa,QAAQ,sBAAsB,EAElDiB,EAAuC,CAC3C,MAAOD,EAAK,MACZ,OAAQA,EAAK,OACb,WAAYD,EAAM,WAClB,QAASA,EAAM,QACf,QAASA,EAAM,QACf,SAAUA,EAAM,SAChB,OAAQA,EAAM,OACd,SAAUA,EAAM,QAClB,EAEAN,EAAgBQ,CAAe,EAG/B,MAAMC,EAAYF,EAAK,MAAQ,GACbA,EAAK,OAAS,GACdD,EAAM,aAAe,UACrBA,EAAM,UAAY,QAClB,WAAWA,EAAM,OAAO,EAAI,EAE9CJ,EAAkBO,CAAS,EAGvBR,IAAmBQ,GACrB,QAAQ,IAAI,uDAAuDA,EAAY,UAAY,QAAQ,GAAI,CACrG,OAAAlF,EACA,gBAAiB2C,EAAgB,OACjC,eAAAuB,EACA,aAAce,CAAA,CACf,CAEL,EAGeH,EAAA,EAGT,MAAA5B,EAAQ,WAAW4B,EAAgB,IAAI,EAG7C,IAAIK,EAA2B,KAC/B,MAAMC,EAAW,IAAI,iBAAkBC,GAAc,CAE/CA,EAAU,OAAS,GACrB,QAAQ,IAAI,gDAAgDA,EAAU,MAAM,EAAE,EAI5EF,GACF,aAAaA,CAAS,EAGZA,EAAA,OAAO,WAAW,IAAM,CACnBL,EAAA,EACHK,EAAA,MACX,GAAG,CAAA,CACP,EAEQ,OAAAC,EAAA,QAAQpB,EAAa,QAAS,CACrC,WAAY,GACZ,UAAW,GACX,QAAS,EAAA,CACV,EAEM,IAAM,CACX,aAAad,CAAK,EAClBkC,EAAS,WAAW,CACtB,GACC,CAACpF,EAAQ2C,EAAiBuB,EAAgBQ,CAAc,CAAC,EAG5D,MAAMY,EAAoB,IAAM,CAC1B,GAAApB,IAAmB,OAAe,MAAA,GAEtC,MAAMqB,EAAkB5C,EAAgB,KAAU,GAAA,EAAE,OAAS,SAAS,EAChE6C,EAAc7C,EAAgB,KAAU,GAAA,EAAE,OAAS,WAAW,EAC9D8C,EAAgB9C,EAAgB,KAAU,GAAA,EAAE,OAAS,QAAQ,EAEnE,OAAIuB,IAAmB,WACjBqB,EAAwB,sCACxBC,EAAoB,uCACpBC,EAAsB,qCACnB,wCAGF,6BACT,EAGMC,EAA+B,IAAM,CACrC,GAAA/C,EAAgB,SAAW,EAAU,MAAA,GAEzC,MAAMgD,EAAoC,CAAC,EAC3BhD,EAAA,QAAaiD,GAAA,CAC3BD,EAAUC,EAAE,IAAI,GAAKD,EAAUC,EAAE,IAAI,GAAK,GAAK,CAAA,CAChD,EAGD,MAAMC,EAAe,CAAC,EAElB,OAAAF,EAAU,SACZE,EAAa,KAAK,GAAGF,EAAU,OAAU,eAAe,EAGtDA,EAAU,WACZE,EAAa,KAAK,GAAGF,EAAU,SAAY,WAAW,EAGpDA,EAAU,QACZE,EAAa,KAAK,GAAGF,EAAU,MAAS,aAAa,EAGnDA,EAAU,UACZE,EAAa,KAAK,GAAGF,EAAU,QAAW,iBAAiB,EAGzDA,EAAU,aACZE,EAAa,KAAK,GAAGF,EAAU,WAAc,WAAW,EAGnDE,EAAa,KAAK,IAAI,CAC/B,EAGMC,EAA4BnD,EAAgB,SAAWyB,EAG7DnB,OAAAA,EAAAA,UAAU,IAAM,CACVc,GACM,QAAA,IAAI,oDAAoD/D,CAAM,GAAI,CACxE,gBAAiB2C,EAAgB,OACjC,eAAAuB,EACA,eAAAQ,CAAA,CACD,CACH,EACC,CAACX,EAAoB/D,EAAQ2C,EAAgB,OAAQuB,EAAgBQ,CAAc,CAAC,EAGrFqB,EAAA,KAAC,MAAA,CACC,IAAK/B,EACL,UAAW,kCAAkCsB,EAAA,CAAmB,GAChE,4BAA2B3C,EAAgB,OAC3C,yBAAwBoB,EACxB,uBAAsBG,EACtB,eAAcQ,EACd,sBAAqBJ,EACrB,MAAO,CACL,SAAU,UACV,UAAW,QACX,SAAU,WACV,WAAY,UACZ,QAAS,QACT,QAAS,CACX,EAGC,SAAA,CAAA3B,EAAgB,OAAS,GACxBoD,EAAA,KAAC,MAAA,CACC,UAAW,uCAAuChC,EAAqB,SAAW,EAAE,GACpF,MAAO2B,EAA6B,EAEpC,SAAA,CAAAM,EAAA,IAAC,OAAK,CAAA,UAAU,uBAAwB,SAAArD,EAAgB,OAAO,EAC9DmD,GACEC,EAAA,KAAA,OAAK,CAAA,UAAU,kCACb,SAAA,CAAgBpD,EAAA,OAASyB,EAAsB,IAAM,GACrDzB,EAAgB,OAASyB,CAAA,CAC5B,CAAA,CAAA,CAAA,CAEJ,EAIF4B,EAAA,IAAC,MAAA,CACC,IAAK/B,EACL,UAAU,+BACV,MAAO,CACL,SAAU,WACV,WAAY,UACZ,QAAS,QACT,QAAS,EACT,UAAW,OACb,EAEC,aAAkB,EAChB+B,MAAA,MAAI,CAAA,UAAU,wBAAwB,MAAO,CAAE,QAAS,OAAQ,UAAW,UAC1E,eAAC,IAAE,CAAA,SAAA,yBAAsB,EAC3B,EAEAlC,CAAA,CAEJ,EAGC,EAAA,CAmBC,CAEJ,CAEJ"}