{"version":3,"file":"narramorph-P_FFBqAj.js","sources":["../../src/services/PathAnalyzer.ts","../../src/services/TransformationService.ts","../../src/hooks/useNodeState.ts","../../src/components/NodeView/TransformationAnimationContainer.tsx"],"sourcesContent":["/**\r\n * PathAnalyzer Service\r\n * \r\n * Analyzes reader path data to identify meaningful patterns in how readers navigate\r\n * through the Narramorph narrative system. This service connects reader behavior\r\n * to the TransformationEngine to enable dynamic content adaptation.\r\n */\r\n\r\nimport {\r\n  ReadingPath,\r\n  StrangeAttractor,\r\n  Character,\r\n  TemporalLabel,\r\n  NodeState\r\n} from '../types';\r\nimport { ReaderState } from '../store/slices/readerSlice';\r\n\r\n/**\r\n * Represents a detected pattern in the reader's path\r\n */\r\nexport interface ReadingPattern {\r\n  type: 'sequence' | 'character' | 'temporal' | 'thematic' | 'rhythm';\r\n  strength: number; // 0-1 indicating pattern strength/confidence\r\n  description: string;\r\n  relatedNodes?: string[];\r\n  relatedCharacters?: Character[];\r\n  relatedTemporalLayers?: TemporalLabel[];\r\n  relatedAttractors?: StrangeAttractor[];\r\n}\r\n\r\n/**\r\n * Represents the reader's engagement with strange attractors\r\n */\r\nexport interface AttractorEngagement {\r\n  attractor: StrangeAttractor;\r\n  engagementScore: number; // 0-100\r\n  totalEngagements: number;\r\n  relatedNodes: string[];\r\n  trend: 'rising' | 'falling' | 'stable';\r\n}\r\n\r\n/**\r\n * Represents a transformation condition with metadata about its source\r\n */\r\nexport interface PatternBasedCondition {\r\n  type: 'visitPattern' | 'characterFocus' | 'temporalFocus' | 'readingRhythm' | 'attractorAffinity' | 'attractorEngagement';\r\n  condition: {\r\n    visitPattern?: string[];\r\n    characters?: Character[];\r\n    temporalPosition?: TemporalLabel;\r\n    // Time-based properties removed (2025-06-08)\r\n    strangeAttractorsEngaged?: StrangeAttractor[];\r\n  };\r\n  strength: number;\r\n}\r\n\r\n/**\r\n * Service class for analyzing reader path patterns\r\n */\r\nexport class PathAnalyzer {\r\n  // Minimum sequence length to consider for pattern analysis\r\n  private readonly MIN_SEQUENCE_LENGTH = 2;\r\n  \r\n  // Threshold for considering a sequence repeated (how many times it must occur)\r\n  private readonly SEQUENCE_REPETITION_THRESHOLD = 2;\r\n  \r\n  // Threshold for detecting character focus (what percentage of visits)\r\n  private readonly CHARACTER_FOCUS_THRESHOLD = 0.4; // 40%\r\n  \r\n  // Threshold for detecting temporal layer focus\r\n  private readonly TEMPORAL_FOCUS_THRESHOLD = 0.4; // 40%\r\n  \r\n  // Using imported constants for transitions and engagements from readerSlice.ts\r\n  // These thresholds define fast transitions and deep engagements\r\n\r\n  /**\r\n   * Analyzes the reader's path to identify patterns\r\n   * @param readerState Current reader state\r\n   * @param nodes Map of node IDs to node states\r\n   * @returns Array of detected patterns\r\n   */\r\n  analyzePathPatterns(\r\n    readerState: ReaderState,\r\n    nodes: Record<string, NodeState>\r\n  ): ReadingPattern[] {\r\n    const patterns: ReadingPattern[] = [];\r\n    \r\n    // Only analyze if we have enough data\r\n    if (readerState.path.sequence.length < this.MIN_SEQUENCE_LENGTH) {\r\n      return patterns;\r\n    }\r\n    \r\n    // 1. Analyze sequence patterns\r\n    patterns.push(...this.identifyRepeatedSequences(readerState.path));\r\n    \r\n    // 2. Analyze character focus patterns\r\n    patterns.push(...this.identifyCharacterFocusPatterns(readerState.path));\r\n    \r\n    // 3. Analyze temporal layer patterns\r\n    patterns.push(...this.identifyTemporalLayerPatterns(readerState.path));\r\n    \r\n    // 4. Reading rhythm patterns (time-based factors removed)\r\n    patterns.push(...this.identifyReadingRhythmPatterns());\r\n    \r\n    // 5. Analyze theme/attractor affinity patterns\r\n    patterns.push(...this.identifyAttractorAffinityPatterns(readerState.path, nodes));\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Identifies repeated sequences in the reader's path\r\n   */\r\n  identifyRepeatedSequences(path: ReadingPath): ReadingPattern[] {\r\n    const patterns: ReadingPattern[] = [];\r\n    const repeatedSequences = path.patternSequences?.repeatedSequences;\r\n    \r\n    if (!repeatedSequences || repeatedSequences.length === 0) {\r\n      return patterns;\r\n    }\r\n    \r\n    // Convert repeated sequences to patterns\r\n    repeatedSequences.forEach((sequence: string[]) => {\r\n      if (sequence.length >= this.MIN_SEQUENCE_LENGTH) {\r\n        // Calculate pattern strength based on sequence length and repetition\r\n        const sequenceLength = sequence.length;\r\n        const maxPossibleLength = Math.floor(path.sequence.length / 2);\r\n        const lengthFactor = sequenceLength / maxPossibleLength;\r\n        \r\n        // Count occurrences of this sequence\r\n        let occurrences = 0;\r\n        for (let i = 0; i <= path.sequence.length - sequenceLength; i++) {\r\n          const potentialMatch = path.sequence.slice(i, i + sequenceLength);\r\n          if (potentialMatch.every((id, idx) => id === sequence[idx])) {\r\n            occurrences++;\r\n          }\r\n        }\r\n        \r\n        // Calculate repetition factor\r\n        const maxPossibleOccurrences = Math.floor(path.sequence.length / sequenceLength);\r\n        const repetitionFactor = Math.min(1, occurrences / maxPossibleOccurrences);\r\n        \r\n        // Calculate overall strength\r\n        const strength = (lengthFactor * 0.4) + (repetitionFactor * 0.6);\r\n        \r\n        // Only add significant patterns\r\n        if (occurrences >= this.SEQUENCE_REPETITION_THRESHOLD) {\r\n          patterns.push({\r\n            type: 'sequence',\r\n            strength,\r\n            description: `Repeated sequence of ${sequenceLength} nodes visited ${occurrences} times`,\r\n            relatedNodes: sequence\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Identifies character focus patterns in the reader's path\r\n   */\r\n  identifyCharacterFocusPatterns(path: ReadingPath): ReadingPattern[] {\r\n    const patterns: ReadingPattern[] = [];\r\n    const characterFocus = path.characterFocus;\r\n    \r\n    if (!characterFocus) {\r\n      return patterns;\r\n    }\r\n    \r\n    const detailedVisits = path.detailedVisits || [];\r\n    const totalVisits = detailedVisits.length;\r\n    if (totalVisits === 0) {\r\n      return patterns;\r\n    }\r\n    \r\n    // Check for character focus\r\n    Object.entries(characterFocus).forEach(([character, count]) => {\r\n      const ratio = count / totalVisits;\r\n      \r\n      if (ratio >= this.CHARACTER_FOCUS_THRESHOLD) {\r\n        // Calculate how much above threshold\r\n        const strengthAboveThreshold = (ratio - this.CHARACTER_FOCUS_THRESHOLD) /\r\n          (1 - this.CHARACTER_FOCUS_THRESHOLD);\r\n        \r\n        // Calculate pattern strength (0.5-1.0 range)\r\n        const strength = 0.5 + (0.5 * strengthAboveThreshold);\r\n        \r\n        patterns.push({\r\n          type: 'character',\r\n          strength,\r\n          description: `Strong focus on ${character} perspective (${Math.round(ratio * 100)}% of visits)`,\r\n          relatedCharacters: [character as Character]\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Analyze character sequences\r\n    const characterSequences = path.patternSequences?.characterSequences;\r\n    if (characterSequences && characterSequences.length > 0) {\r\n      \r\n      const characterSequence = characterSequences[0];\r\n      \r\n      // Look for oscillation patterns (alternating between two characters)\r\n      if (characterSequence.length >= 4) {\r\n        let oscillationCount = 0;\r\n        \r\n        for (let i = 0; i < characterSequence.length - 3; i++) {\r\n          const c1 = characterSequence[i];\r\n          const c2 = characterSequence[i + 1];\r\n          \r\n          if (c1 !== c2 && \r\n              characterSequence[i + 2] === c1 && \r\n              characterSequence[i + 3] === c2) {\r\n            oscillationCount++;\r\n          }\r\n        }\r\n        \r\n        const maxPossibleOscillations = Math.floor((characterSequence.length - 3) / 2);\r\n        const oscillationRatio = oscillationCount / maxPossibleOscillations;\r\n        \r\n        if (oscillationRatio >= 0.3) {\r\n          patterns.push({\r\n            type: 'character',\r\n            strength: oscillationRatio,\r\n            description: 'Pattern of alternating between character perspectives',\r\n            relatedCharacters: Array.from(new Set(characterSequence))\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Identifies temporal layer patterns in the reader's path\r\n   */\r\n  identifyTemporalLayerPatterns(path: ReadingPath): ReadingPattern[] {\r\n    const patterns: ReadingPattern[] = [];\r\n    const temporalLayerFocus = path.temporalLayerFocus;\r\n    \r\n    if (!temporalLayerFocus) {\r\n      return patterns;\r\n    }\r\n    \r\n    const detailedVisits = path.detailedVisits || [];\r\n    const totalVisits = detailedVisits.length;\r\n    if (totalVisits === 0) {\r\n      return patterns;\r\n    }\r\n    \r\n    // Check for temporal layer focus\r\n    Object.entries(temporalLayerFocus).forEach(([layer, count]) => {\r\n      const ratio = count / totalVisits;\r\n      \r\n      if (ratio >= this.TEMPORAL_FOCUS_THRESHOLD) {\r\n        // Calculate how much above threshold\r\n        const strengthAboveThreshold = (ratio - this.TEMPORAL_FOCUS_THRESHOLD) /\r\n          (1 - this.TEMPORAL_FOCUS_THRESHOLD);\r\n        \r\n        // Calculate pattern strength (0.5-1.0 range)\r\n        const strength = 0.5 + (0.5 * strengthAboveThreshold);\r\n        \r\n        patterns.push({\r\n          type: 'temporal',\r\n          strength,\r\n          description: `Strong focus on ${layer} temporal layer (${Math.round(ratio * 100)}% of visits)`,\r\n          relatedTemporalLayers: [layer as TemporalLabel]\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Analyze temporal progression patterns\r\n    const temporalSequences = path.patternSequences?.temporalSequences;\r\n    if (temporalSequences && temporalSequences.length > 0) {\r\n      \r\n      const temporalSequence = temporalSequences[0];\r\n      \r\n      if (temporalSequence.length >= 5) {\r\n        // Check for chronological progression (past -> present -> future)\r\n        let chronologicalCount = 0;\r\n        \r\n        for (let i = 0; i < temporalSequence.length - 2; i++) {\r\n          const t1 = temporalSequence[i];\r\n          const t2 = temporalSequence[i + 1];\r\n          const t3 = temporalSequence[i + 2];\r\n          \r\n          if ((t1 === 'past' && t2 === 'present' && t3 === 'future') ||\r\n              (t1 === 'past' && t2 === 'present') ||\r\n              (t2 === 'present' && t3 === 'future')) {\r\n            chronologicalCount++;\r\n          }\r\n        }\r\n        \r\n        const maxPossibleProgressions = temporalSequence.length - 2;\r\n        const progressionRatio = chronologicalCount / maxPossibleProgressions;\r\n        \r\n        if (progressionRatio >= 0.3) {\r\n          patterns.push({\r\n            type: 'temporal',\r\n            strength: progressionRatio,\r\n            description: 'Pattern of chronological progression through time',\r\n            relatedTemporalLayers: ['past', 'present', 'future']\r\n          });\r\n        }\r\n        \r\n        // Check for reverse chronological progression (future -> present -> past)\r\n        let reverseChronologicalCount = 0;\r\n        \r\n        for (let i = 0; i < temporalSequence.length - 2; i++) {\r\n          const t1 = temporalSequence[i];\r\n          const t2 = temporalSequence[i + 1];\r\n          const t3 = temporalSequence[i + 2];\r\n          \r\n          if ((t1 === 'future' && t2 === 'present' && t3 === 'past') ||\r\n              (t1 === 'future' && t2 === 'present') ||\r\n              (t2 === 'present' && t3 === 'past')) {\r\n            reverseChronologicalCount++;\r\n          }\r\n        }\r\n        \r\n        const reverseProgressionRatio = reverseChronologicalCount / maxPossibleProgressions;\r\n        \r\n        if (reverseProgressionRatio >= 0.3) {\r\n          patterns.push({\r\n            type: 'temporal',\r\n            strength: reverseProgressionRatio,\r\n            description: 'Pattern of reverse chronological movement through time',\r\n            relatedTemporalLayers: ['future', 'present', 'past']\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Previously contained reading rhythm patterns based on time\r\n   * Removed as part of refactoring to eliminate time-based factors\r\n   */\r\n  identifyReadingRhythmPatterns(): ReadingPattern[] {\r\n    // Return empty patterns as time-based rhythm detection has been removed\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Identifies attractor affinity patterns in the reader's path\r\n   */\r\n  identifyAttractorAffinityPatterns(\r\n    path: ReadingPath,\r\n    nodes: Record<string, NodeState>\r\n  ): ReadingPattern[] {\r\n    const patterns: ReadingPattern[] = [];\r\n    const attractorsEngaged = path.attractorsEngaged;\r\n    const detailedVisits = path.detailedVisits || [];\r\n    \r\n    if (!attractorsEngaged || Object.keys(attractorsEngaged).length === 0) {\r\n      return patterns;\r\n    }\r\n    \r\n    // Count total attractor engagements\r\n    const totalEngagements = Object.values(attractorsEngaged).reduce((sum, count) => sum + count, 0);\r\n    if (totalEngagements === 0) {\r\n      return patterns;\r\n    }\r\n    \r\n    // Find attractors with significant engagement\r\n    Object.entries(attractorsEngaged).forEach(([attractor, count]) => {\r\n      const engagementRatio = count / totalEngagements;\r\n      \r\n      if (engagementRatio >= 0.25) { // 25% or more of all engagements\r\n        // Calculate nodes that have this attractor\r\n        const relatedNodes = Object.values(nodes)\r\n          .filter(node => node.strangeAttractors.includes(attractor as StrangeAttractor))\r\n          .map(node => node.id);\r\n        \r\n        // Calculate pattern strength based on engagement ratio and visit ratio\r\n        let visitRatio = 0;\r\n        if (relatedNodes.length > 0) {\r\n          const attractorVisits = detailedVisits.filter(visit =>\r\n            relatedNodes.includes(visit.nodeId)).length;\r\n          visitRatio = attractorVisits / detailedVisits.length;\r\n        }\r\n        \r\n        const strength = (engagementRatio * 0.7) + (visitRatio * 0.3);\r\n        \r\n        patterns.push({\r\n          type: 'thematic',\r\n          strength,\r\n          description: `Strong affinity for \"${attractor}\" concept/theme`,\r\n          relatedAttractors: [attractor as StrangeAttractor],\r\n          relatedNodes\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Check for thematic connections between visited nodes\r\n    if (detailedVisits.length >= 3) {\r\n      // Create a map of node IDs to their attractors\r\n      const nodeAttractors: Record<string, StrangeAttractor[]> = {};\r\n      \r\n      Object.values(nodes).forEach(node => {\r\n        nodeAttractors[node.id] = node.strangeAttractors;\r\n      });\r\n      \r\n      // Count shared attractors between consecutive visits\r\n      const recentVisits = detailedVisits.slice(-Math.min(10, detailedVisits.length));\r\n      let sharedAttractorTransitions = 0;\r\n      \r\n      for (let i = 1; i < recentVisits.length; i++) {\r\n        const prevNode = recentVisits[i-1].nodeId;\r\n        const currNode = recentVisits[i].nodeId;\r\n        \r\n        const prevAttractors = nodeAttractors[prevNode] || [];\r\n        const currAttractors = nodeAttractors[currNode] || [];\r\n        \r\n        const sharedAttractors = prevAttractors.filter(\r\n          attractor => currAttractors.includes(attractor)\r\n        );\r\n        \r\n        if (sharedAttractors.length > 0) {\r\n          sharedAttractorTransitions++;\r\n        }\r\n      }\r\n      \r\n      const thematicContinuityRatio = sharedAttractorTransitions / (recentVisits.length - 1);\r\n      \r\n      if (thematicContinuityRatio >= 0.5) {\r\n        patterns.push({\r\n          type: 'thematic',\r\n          strength: thematicContinuityRatio,\r\n          description: 'Pattern of following thematic connections between nodes'\r\n        });\r\n      }\r\n    }\r\n    \r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Calculates the reader's engagement levels with different strange attractors\r\n   */\r\n  calculateAttractorEngagement(\r\n    readerState: ReaderState,\r\n    nodes: Record<string, NodeState>\r\n  ): AttractorEngagement[] {\r\n    const { path } = readerState;\r\n    const attractorsEngaged = path.attractorsEngaged;\r\n    const detailedVisits = path.detailedVisits || [];\r\n    \r\n    if (!attractorsEngaged || Object.keys(attractorsEngaged).length === 0) {\r\n      return [];\r\n    }\r\n    \r\n    // Create a map of strange attractors to their engagement metrics\r\n    const attractorEngagements: AttractorEngagement[] = [];\r\n    \r\n    // Process each attractor that has been engaged\r\n    Object.entries(attractorsEngaged).forEach(([attractorStr, totalEngagements]) => {\r\n      const attractor = attractorStr as StrangeAttractor;\r\n      \r\n      if (totalEngagements === 0) {\r\n        return;\r\n      }\r\n      \r\n      // Find nodes related to this attractor\r\n      const relatedNodes = Object.values(nodes)\r\n        .filter(node => node.strangeAttractors.includes(attractor))\r\n        .map(node => node.id);\r\n      \r\n      // Find visits where this attractor was engaged\r\n      const engagementVisits = detailedVisits.filter(visit =>\r\n        visit.engagedAttractors.includes(attractor));\r\n      \r\n      if (engagementVisits.length === 0) {\r\n        return;\r\n      }\r\n      \r\n      // Set default trend\r\n      let trend: 'rising' | 'falling' | 'stable' = 'stable';\r\n      \r\n      // Simple trend calculation based on visit index rather than timestamp\r\n      if (engagementVisits.length >= 3) {\r\n        // Divide visits into first half and second half by visit index\r\n        const midpoint = Math.floor(engagementVisits.length / 2);\r\n        const firstHalf = engagementVisits.slice(0, midpoint);\r\n        const secondHalf = engagementVisits.slice(midpoint);\r\n        \r\n        // Compare counts in first and second half to determine trend\r\n        if (secondHalf.length > firstHalf.length * 1.2) {\r\n          trend = 'rising';\r\n        } else if (secondHalf.length < firstHalf.length * 0.8) {\r\n          trend = 'falling';\r\n        }\r\n      }\r\n      \r\n      // Calculate engagement score (0-100)\r\n      // Base on multiple factors:\r\n      // 1. Total engagements relative to other attractors\r\n      // 2. Recency of engagements\r\n      // 3. Consistency of engagement over time\r\n      \r\n      // 1. Calculate relative engagement\r\n      const totalAllAttractors = Object.values(attractorsEngaged)\r\n        .reduce((sum, count) => sum + count, 0);\r\n      \r\n      const relativeEngagement = (totalEngagements / totalAllAttractors) * 100;\r\n      \r\n      // 2. Recency factor - using indices instead of timestamps\r\n      // Check if the engagement appears in recent visits\r\n      const recencyFactor = detailedVisits.indexOf(engagementVisits[engagementVisits.length - 1]) >\r\n        detailedVisits.length * 0.7 ? 0.8 : 0.4;\r\n      \r\n      // 3. Consistency factor - simplified version\r\n      const consistencyFactor = engagementVisits.length > totalEngagements * 0.5 ? 0.7 : 0.3;\r\n      \r\n      // Calculate final score\r\n      const engagementScore = Math.min(100,\r\n        (relativeEngagement * 0.6) +\r\n        (recencyFactor * 20) +\r\n        (consistencyFactor * 20));\r\n      \r\n      // Add to results\r\n      attractorEngagements.push({\r\n        attractor,\r\n        engagementScore,\r\n        totalEngagements,\r\n        relatedNodes,\r\n        trend\r\n      });\r\n    });\r\n    \r\n    // Sort by engagement score (descending)\r\n    return attractorEngagements.sort((a, b) => b.engagementScore - a.engagementScore);\r\n  }\r\n\r\n  /**\r\n   * Identifies the most significant patterns in the reader's journey\r\n   */\r\n  identifySignificantPatterns(\r\n    readerState: ReaderState,\r\n    nodes: Record<string, NodeState>\r\n  ): ReadingPattern[] {\r\n    // Get all patterns\r\n    const allPatterns = this.analyzePathPatterns(readerState, nodes);\r\n    \r\n    // Sort by strength\r\n    const sortedPatterns = allPatterns.sort((a, b) => b.strength - a.strength);\r\n    \r\n    // Return top patterns (max 5, with strength at least 0.6)\r\n    return sortedPatterns\r\n      .filter(pattern => pattern.strength >= 0.6)\r\n      .slice(0, 5);\r\n  }\r\n\r\n  /**\r\n   * Creates transformation conditions based on reader path patterns\r\n   * to link with the TransformationEngine\r\n   */\r\n  createTransformationConditions(\r\n    patterns: ReadingPattern[],\r\n    attractorEngagements: AttractorEngagement[]\r\n  ): PatternBasedCondition[] {\r\n    const conditions: PatternBasedCondition[] = [];\r\n    \r\n    // Create conditions based on patterns\r\n    patterns.forEach(pattern => {\r\n      switch (pattern.type) {\r\n        case 'sequence':\r\n          if (pattern.relatedNodes && pattern.relatedNodes.length >= 2) {\r\n            conditions.push({\r\n              type: 'visitPattern',\r\n              condition: {\r\n                visitPattern: pattern.relatedNodes\r\n              },\r\n              strength: pattern.strength\r\n            });\r\n          }\r\n          break;\r\n          \r\n        case 'character':\r\n          if (pattern.relatedCharacters && pattern.relatedCharacters.length > 0) {\r\n            // This would require adding character-based conditions to the TransformationEngine\r\n            conditions.push({\r\n              type: 'characterFocus',\r\n              condition: {\r\n                // Custom condition that would need to be implemented in TransformationEngine\r\n                characters: pattern.relatedCharacters\r\n              },\r\n              strength: pattern.strength\r\n            });\r\n          }\r\n          break;\r\n          \r\n        case 'temporal':\r\n          if (pattern.relatedTemporalLayers && pattern.relatedTemporalLayers.length > 0) {\r\n            conditions.push({\r\n              type: 'temporalFocus',\r\n              condition: {\r\n                temporalPosition: pattern.relatedTemporalLayers[0]\r\n              },\r\n              strength: pattern.strength\r\n            });\r\n          }\r\n          break;\r\n          \r\n        case 'rhythm':\r\n          // Rhythm-based conditions removed (previously time-based)\r\n          break;\r\n          \r\n        case 'thematic':\r\n          if (pattern.relatedAttractors && pattern.relatedAttractors.length > 0) {\r\n            conditions.push({\r\n              type: 'attractorAffinity',\r\n              condition: {\r\n                strangeAttractorsEngaged: pattern.relatedAttractors\r\n              },\r\n              strength: pattern.strength\r\n            });\r\n          }\r\n          break;\r\n      }\r\n    });\r\n    \r\n    // Create conditions based on attractor engagements\r\n    attractorEngagements\r\n      .filter(engagement => engagement.engagementScore >= 50)\r\n      .forEach(engagement => {\r\n        conditions.push({\r\n          type: 'attractorEngagement',\r\n          condition: {\r\n            strangeAttractorsEngaged: [engagement.attractor]\r\n          },\r\n          strength: engagement.engagementScore / 100\r\n        });\r\n      });\r\n    \r\n    return conditions;\r\n  }\r\n}\r\n\r\n// Export a singleton instance for use throughout the application\r\nexport const pathAnalyzer = new PathAnalyzer();","/**\r\n * TransformationService\r\n *\r\n * Core service that handles the application of Narramorph content transformations\r\n * based on reader patterns and conditions.\r\n *\r\n * This service connects the condition detection system (TransformationEngine) and\r\n * the pattern analysis system (PathAnalyzer) to actual content changes.\r\n *\r\n * Performance optimized with enhanced caching, lazy evaluation, and memory management.\r\n */\r\n\r\nimport {\r\n  TextTransformation,\r\n  NodeState\r\n} from '../types';\r\nimport { ReaderState } from '../store/slices/readerSlice';\r\nimport { transformationEngine } from './TransformationEngine';\r\nimport { pathAnalyzer } from './PathAnalyzer';\r\n\r\n// Enhanced cache for storing previously evaluated and applied transformations\r\ninterface TransformationCache {\r\n  // Key format: nodeId-visitCount-patternHash\r\n  [key: string]: {\r\n    transformations: TextTransformation[];\r\n    timestamp: number;\r\n    content: string;\r\n    // Track which parts of the content were transformed for partial updates\r\n    transformedSegments?: {\r\n      selector: string;\r\n      transformType: string;\r\n      position: [number, number]; // [start, end] positions in content\r\n    }[];\r\n    // Additional metadata for cache invalidation decisions\r\n    metadata?: {\r\n      readerStateHash: string;\r\n      nodeStateHash: string;\r\n      complexity: number; // Higher value = more expensive transformation\r\n    }\r\n  }\r\n}\r\n\r\n// Interface for tracking visible content for lazy evaluation\r\ninterface VisibilityTracker {\r\n  // Key is a content identifier (usually node ID)\r\n  [key: string]: {\r\n    isVisible: boolean;\r\n    lastVisibleTimestamp: number;\r\n    pendingTransformations: TextTransformation[];\r\n    priority: number; // Higher = more important to transform when visible\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a transformation with its priority and metadata\r\n */\r\ninterface PrioritizedTransformation {\r\n  transformation: TextTransformation;\r\n  priority: number;\r\n  sourceType: 'pattern' | 'condition' | 'attractor' | 'temporal' | 'rhythm';\r\n  conflictGroup?: string; // Identifier for potentially conflicting transformations\r\n}\r\n\r\n/**\r\n * Service class for managing the application of content transformations\r\n */\r\nexport class TransformationService {\r\n  private cache: TransformationCache = {};\r\n  private visibilityTracker: VisibilityTracker = {};\r\n  private readonly CACHE_EXPIRY_TIME = 10 * 60 * 1000; // 10 minutes\r\n  private readonly MAX_CACHE_ENTRIES = 200;\r\n  \r\n  // Performance metrics\r\n  private metrics = {\r\n    cacheHits: 0,\r\n    cacheMisses: 0,\r\n    patternAnalysisCount: 0,\r\n    transformationAppliedCount: 0,\r\n    lazyTransformationsDeferredCount: 0,\r\n    lazyTransformationsAppliedCount: 0,\r\n    lastCacheCleanupTime: Date.now()\r\n  };\r\n  \r\n  /**\r\n   * Calculates a unique hash for the reader's current pattern state\r\n   * Used for caching transformation results\r\n   */\r\n  private calculatePatternHash(readerState: ReaderState): string {\r\n    // Create a simple hash based on key reader state components\r\n    const { \r\n      path: { sequence, attractorsEngaged }, \r\n      endpointProgress \r\n    } = readerState;\r\n    \r\n    // Use the last 5 nodes in the sequence, or all if less than 5\r\n    const recentPath = sequence.slice(-5).join('-');\r\n    \r\n    // Use top 3 engaged attractors\r\n    const topAttractors = Object.entries(attractorsEngaged)\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 3)\r\n      .map(([attractor]) => attractor)\r\n      .join('-');\r\n    \r\n    // Use endpoint progress values\r\n    const progressValues = Object.values(endpointProgress).join('-');\r\n    \r\n    return `${recentPath}|${topAttractors}|${progressValues}`;\r\n  }\r\n  \r\n  /**\r\n   * Get a unique cache key for a node transformation\r\n   */\r\n  private getCacheKey(nodeId: string, visitCount: number, patternHash: string): string {\r\n    return `${nodeId}-${visitCount}-${patternHash}`;\r\n  }\r\n  \r\n  /**\r\n   * More comprehensive cache management:\r\n   * - Removes expired entries\r\n   * - Limits total cache size\r\n   * - Prioritizes keeping entries for visible or recently viewed content\r\n   */\r\n  private cleanCache(): void {\r\n    const now = Date.now();\r\n    \r\n    // Only clean periodically to avoid performance overhead\r\n    if (now - this.metrics.lastCacheCleanupTime < 30000) { // 30 seconds\r\n      return;\r\n    }\r\n    \r\n    this.metrics.lastCacheCleanupTime = now;\r\n    \r\n    // Step 1: Remove expired entries\r\n    let entries = Object.entries(this.cache);\r\n    entries = entries.filter(([, value]) => now - value.timestamp <= this.CACHE_EXPIRY_TIME);\r\n    \r\n    // Step 2: If still too many entries, prioritize keeping important ones\r\n    if (entries.length > this.MAX_CACHE_ENTRIES) {\r\n      // Sort by importance (keep visible content and recently accessed entries)\r\n      entries.sort(([keyA, valueA], [keyB, valueB]) => {\r\n        const nodeIdA = keyA.split('-')[0];\r\n        const nodeIdB = keyB.split('-')[0];\r\n        \r\n        // First priority: visible content\r\n        const isVisibleA = this.visibilityTracker[nodeIdA]?.isVisible || false;\r\n        const isVisibleB = this.visibilityTracker[nodeIdB]?.isVisible || false;\r\n        if (isVisibleA !== isVisibleB) return isVisibleB ? 1 : -1;\r\n        \r\n        // Second priority: recently accessed\r\n        return valueB.timestamp - valueA.timestamp;\r\n      });\r\n      \r\n      // Keep only the most important entries\r\n      entries = entries.slice(0, this.MAX_CACHE_ENTRIES);\r\n    }\r\n    \r\n    // Rebuild cache with filtered entries\r\n    this.cache = Object.fromEntries(entries);\r\n  }\r\n  \r\n  /**\r\n   * Assign priorities to transformations based on their type and strength\r\n   */\r\n  private prioritizeTransformations(\r\n    transformations: TextTransformation[],\r\n    readerState: ReaderState,\r\n    nodeState: NodeState\r\n  ): PrioritizedTransformation[] {\r\n    // Start with default priorities\r\n    const prioritized: PrioritizedTransformation[] = transformations.map(transformation => {\r\n      // Base priority assignment\r\n      let priority = 50; // Default mid-level priority\r\n      let sourceType: PrioritizedTransformation['sourceType'] = 'condition';\r\n      const conflictGroup: string | undefined = `selector-${transformation.selector}`;\r\n      \r\n      // Conflict group is based on selector\r\n      // Transformations with same selector might conflict\r\n      \r\n      // Modify priority and source type based on transformation type\r\n      switch (transformation.type) {\r\n        case 'replace':\r\n          priority = 80; // Highest priority since it completely changes content\r\n          sourceType = 'pattern';\r\n          break;\r\n          \r\n        case 'fragment':\r\n          priority = 75;\r\n          sourceType = 'rhythm';\r\n          break;\r\n          \r\n        case 'expand':\r\n          priority = 60;\r\n          sourceType = 'attractor';\r\n          break;\r\n          \r\n        case 'emphasize':\r\n          priority = 50;\r\n          sourceType = 'temporal';\r\n          break;\r\n          \r\n        case 'metaComment':\r\n          priority = 40; // Lowest priority since it just adds comments\r\n          sourceType = 'attractor';\r\n          break;\r\n      }\r\n      \r\n      return {\r\n        transformation,\r\n        priority,\r\n        sourceType,\r\n        conflictGroup\r\n      };\r\n    });\r\n    \r\n    // Further adjust priorities based on reader state and patterns\r\n    // Get significant patterns for this reader\r\n    const patterns = pathAnalyzer.identifySignificantPatterns(readerState, {\r\n      [nodeState.id]: nodeState\r\n    });\r\n    \r\n    // Get attractor engagements\r\n    const attractorEngagements = pathAnalyzer.calculateAttractorEngagement(readerState, {\r\n      [nodeState.id]: nodeState\r\n    });\r\n    \r\n    // Adjust priority based on pattern strength and attractor engagement\r\n    prioritized.forEach(item => {\r\n      // If transformation matches a strong pattern, increase priority\r\n      if (item.sourceType === 'pattern') {\r\n        const matchingPattern = patterns.find(p => \r\n          p.type === 'sequence' && p.strength > 0.7);\r\n        if (matchingPattern) {\r\n          item.priority += Math.round(matchingPattern.strength * 15);\r\n        }\r\n      }\r\n      \r\n      // If transformation is related to an engaged attractor, adjust priority\r\n      if (item.sourceType === 'attractor' && item.transformation.selector) {\r\n        const relatedAttractor = attractorEngagements.find(engagement => \r\n          nodeState.currentContent?.includes(item.transformation.selector) && \r\n          nodeState.strangeAttractors.includes(engagement.attractor)\r\n        );\r\n        \r\n        if (relatedAttractor && relatedAttractor.engagementScore > 50) {\r\n          item.priority += Math.round((relatedAttractor.engagementScore - 50) / 5);\r\n        }\r\n      }\r\n      \r\n      // Temporal-based priority adjustments removed\r\n      \r\n      // Reading rhythm priority adjustments removed\r\n    });\r\n    \r\n    return prioritized;\r\n  }\r\n  \r\n  /**\r\n   * Resolve conflicts between transformations\r\n   * Returns a filtered list with conflicts resolved\r\n   */\r\n  private resolveConflicts(transformations: PrioritizedTransformation[]): PrioritizedTransformation[] {\r\n    // Group transformations by conflict group\r\n    const groupedByConflict: Record<string, PrioritizedTransformation[]> = {};\r\n    \r\n    transformations.forEach(item => {\r\n      if (item.conflictGroup) {\r\n        if (!groupedByConflict[item.conflictGroup]) {\r\n          groupedByConflict[item.conflictGroup] = [];\r\n        }\r\n        groupedByConflict[item.conflictGroup].push(item);\r\n      }\r\n    });\r\n    \r\n    // For each conflict group, keep only the highest priority transformation\r\n    const resolved: PrioritizedTransformation[] = [];\r\n    \r\n    // Add transformations without conflict groups\r\n    transformations\r\n      .filter(item => !item.conflictGroup)\r\n      .forEach(item => resolved.push(item));\r\n    \r\n    // Add highest priority transformation from each conflict group\r\n    Object.values(groupedByConflict).forEach(group => {\r\n      if (group.length > 0) {\r\n        // Sort by priority (highest first)\r\n        group.sort((a, b) => b.priority - a.priority);\r\n        resolved.push(group[0]);\r\n      }\r\n    });\r\n    \r\n    return resolved;\r\n  }\r\n  \r\n  /**\r\n   * Apply transformations to content with priority handling and conflict resolution\r\n   */\r\n  applyTransformationsWithPriority(\r\n    content: string, \r\n    transformations: TextTransformation[], \r\n    readerState: ReaderState,\r\n    nodeState: NodeState\r\n  ): string {\r\n    if (transformations.length === 0) {\r\n      return content;\r\n    }\r\n    \r\n    // Prioritize transformations\r\n    let prioritized = this.prioritizeTransformations(transformations, readerState, nodeState);\r\n    \r\n    // Resolve conflicts\r\n    prioritized = this.resolveConflicts(prioritized);\r\n    \r\n    // Sort by priority (highest first)\r\n    prioritized.sort((a, b) => b.priority - a.priority);\r\n    \r\n    // Apply transformations in priority order\r\n    let transformedContent = content;\r\n    \r\n    prioritized.forEach(({ transformation }) => {\r\n      transformedContent = transformationEngine.applyTextTransformation(\r\n        transformedContent, \r\n        transformation\r\n      );\r\n    });\r\n    \r\n    return transformedContent;\r\n  }\r\n  \r\n  /**\r\n   * Enhanced method to track content visibility for lazy evaluation\r\n   */\r\n  public setContentVisibility(nodeId: string, isVisible: boolean, priority: number = 1): void {\r\n    if (!this.visibilityTracker[nodeId]) {\r\n      this.visibilityTracker[nodeId] = {\r\n        isVisible: false,\r\n        lastVisibleTimestamp: 0,\r\n        pendingTransformations: [],\r\n        priority: priority\r\n      };\r\n    }\r\n    \r\n    // Update visibility state\r\n    this.visibilityTracker[nodeId].isVisible = isVisible;\r\n    \r\n    if (isVisible) {\r\n      this.visibilityTracker[nodeId].lastVisibleTimestamp = Date.now();\r\n      \r\n      // Process any pending transformations for now-visible content\r\n      this.processPendingTransformations(nodeId);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Process any pending transformations for a now-visible content element\r\n   */\r\n  private processPendingTransformations(nodeId: string): void {\r\n    const tracker = this.visibilityTracker[nodeId];\r\n    if (!tracker || !tracker.isVisible || tracker.pendingTransformations.length === 0) {\r\n      return;\r\n    }\r\n    \r\n    // Process the pending transformations now that content is visible\r\n    this.metrics.lazyTransformationsAppliedCount += tracker.pendingTransformations.length;\r\n    \r\n    // Reset pending transformations after processing\r\n    tracker.pendingTransformations = [];\r\n  }\r\n  \r\n  /**\r\n   * Queue a transformation for lazy evaluation when content becomes visible\r\n   */\r\n  public queueLazyTransformation(\r\n    nodeId: string,\r\n    transformation: TextTransformation\r\n  ): void {\r\n    if (!this.visibilityTracker[nodeId]) {\r\n      this.visibilityTracker[nodeId] = {\r\n        isVisible: false,\r\n        lastVisibleTimestamp: 0,\r\n        pendingTransformations: [],\r\n        priority: 1\r\n      };\r\n    }\r\n    \r\n    // If content is already visible, apply immediately\r\n    if (this.visibilityTracker[nodeId].isVisible) {\r\n      this.metrics.lazyTransformationsAppliedCount++;\r\n      return;\r\n    }\r\n    \r\n    // Otherwise, queue for later\r\n    this.visibilityTracker[nodeId].pendingTransformations.push(transformation);\r\n    this.metrics.lazyTransformationsDeferredCount++;\r\n  }\r\n  \r\n  /**\r\n   * Enhanced content transformation with caching, partial updates, and lazy evaluation\r\n   */\r\n  getCachedTransformedContent(\r\n    nodeId: string,\r\n    content: string,\r\n    transformations: TextTransformation[],\r\n    readerState: ReaderState,\r\n    nodeState: NodeState\r\n  ): string {\r\n    // Calculate cache key components\r\n    const patternHash = this.calculatePatternHash(readerState);\r\n    const cacheKey = this.getCacheKey(nodeId, nodeState.visitCount, patternHash);\r\n    \r\n    // Clean expired cache entries periodically\r\n    this.cleanCache();\r\n    \r\n    // Track if this node is visible (for metrics)\r\n    const isVisible = this.visibilityTracker[nodeId]?.isVisible || false;\r\n    \r\n    // Check if we have a cached version\r\n    if (this.cache[cacheKey] && this.cache[cacheKey].content) {\r\n      this.metrics.cacheHits++;\r\n      \r\n      // If we have a cache hit but the content isn't visible, mark for lazy processing\r\n      if (!isVisible && transformations.length > 0) {\r\n        this.metrics.lazyTransformationsDeferredCount++;\r\n      }\r\n      \r\n      return this.cache[cacheKey].content;\r\n    }\r\n    \r\n    this.metrics.cacheMisses++;\r\n    \r\n    // If content isn't visible and transformations are expensive,\r\n    // consider deferring expensive transformations\r\n    if (!isVisible && transformations.length > 3) {\r\n      // Queue transformations for later processing\r\n      transformations.forEach(t => this.queueLazyTransformation(nodeId, t));\r\n      \r\n      // Only apply essential transformations now\r\n      const essentialTransformations = transformations.filter(t =>\r\n        t.type === 'replace' || // Always apply replacements\r\n        t.priority === 'high'   // And high priority transformations\r\n      );\r\n      \r\n      if (essentialTransformations.length < transformations.length) {\r\n        transformations = essentialTransformations;\r\n      }\r\n    }\r\n    \r\n    // Apply transformations\r\n    const transformedContent = this.applyTransformationsWithPriority(\r\n      content,\r\n      transformations,\r\n      readerState,\r\n      nodeState\r\n    );\r\n    \r\n    // Track transformed segments for partial updates\r\n    const transformedSegments = transformations.map(t => ({\r\n      selector: t.selector || '',\r\n      transformType: t.type,\r\n      position: this.findPositionInContent(content, t.selector || '') as [number, number]\r\n    })).filter(seg => seg.position[0] >= 0);\r\n    \r\n    // Cache the result with metadata\r\n    this.cache[cacheKey] = {\r\n      transformations,\r\n      timestamp: Date.now(),\r\n      content: transformedContent,\r\n      transformedSegments,\r\n      metadata: {\r\n        readerStateHash: JSON.stringify({\r\n          path: readerState.path.sequence.slice(-5),\r\n          attractors: Object.keys(readerState.path.attractorsEngaged || {})\r\n        }),\r\n        nodeStateHash: JSON.stringify({\r\n          id: nodeState.id,\r\n          visitCount: nodeState.visitCount\r\n        }),\r\n        complexity: this.calculateTransformationComplexity(transformations)\r\n      }\r\n    };\r\n    \r\n    return transformedContent;\r\n  }\r\n  \r\n  /**\r\n   * Find the position of a selector in content\r\n   * Returns [start, end] positions or [-1, -1] if not found\r\n   */\r\n  private findPositionInContent(content: string, selector: string): [number, number] {\r\n    if (!selector || !content) return [-1, -1];\r\n    \r\n    const start = content.indexOf(selector);\r\n    if (start === -1) return [-1, -1];\r\n    \r\n    return [start, start + selector.length];\r\n  }\r\n  \r\n  /**\r\n   * Calculate complexity score for a set of transformations\r\n   * Higher score = more computationally expensive\r\n   */\r\n  private calculateTransformationComplexity(transformations: TextTransformation[]): number {\r\n    if (!transformations.length) return 0;\r\n    \r\n    return transformations.reduce((score, t) => {\r\n      // Base complexity by type\r\n      let typeComplexity = 1;\r\n      switch (t.type) {\r\n        case 'fragment': typeComplexity = 3; break;\r\n        case 'emphasize': typeComplexity = 2; break;\r\n        case 'metaComment': typeComplexity = 2.5; break;\r\n        case 'expand': typeComplexity = 2; break;\r\n        case 'replace': typeComplexity = 1; break;\r\n      }\r\n      \r\n      // Complexity multiplier based on content size\r\n      const contentSize = (t.selector?.length || 0) + (t.replacement?.length || 0);\r\n      const sizeFactor = Math.log(contentSize + 10) / Math.log(10); // log10(size+10)\r\n      \r\n      return score + typeComplexity * sizeFactor;\r\n    }, 0);\r\n  }\r\n  \r\n  /**\r\n   * Generate a hash for a set of transformations to use in CSS transitions\r\n   */\r\n  getTransformationHash(transformations: TextTransformation[]): string {\r\n    return transformations\r\n      .map(t => `${t.type}-${t.selector?.substring(0, 10)}`)\r\n      .join('|');\r\n  }\r\n  \r\n  /**\r\n   * Generate CSS classes for transitions based on transformation types\r\n   */\r\n  generateTransitionClasses(transformations: TextTransformation[]): Record<string, string> {\r\n    const classMap: Record<string, string> = {};\r\n    \r\n    transformations.forEach(transformation => {\r\n      if (!transformation.selector) return;\r\n      \r\n      const sanitizedSelector = transformation.selector.replace(/[^a-zA-Z0-9]/g, '_');\r\n      // Start with narramorph-transform to get base transition styling\r\n      const baseClass = `narramorph-transform narramorph-transform-${transformation.type}`;\r\n      let classList = baseClass;\r\n      \r\n      // Get intensity for emphasis styles\r\n      const intensity = transformation.intensity || 1;\r\n      \r\n      switch (transformation.type) {\r\n        case 'replace':\r\n          classList += ' narramorph-replaced';\r\n          if (transformation.preserveFormatting) {\r\n            classList += ' preserve-formatting';\r\n          }\r\n          break;\r\n          \r\n        case 'fragment':\r\n          classList += ' narramorph-fragmented';\r\n          if (transformation.fragmentStyle) {\r\n            classList += ` narramorph-fragment-${transformation.fragmentStyle}`;\r\n          }\r\n          break;\r\n          \r\n        case 'expand':\r\n          classList += ' narramorph-expanded';\r\n          if (transformation.expandStyle) {\r\n            classList += ` narramorph-expand-${transformation.expandStyle || 'default'}`;\r\n          }\r\n          break;\r\n          \r\n        case 'emphasize':\r\n          classList += ' narramorph-emphasized';\r\n          if (transformation.emphasis) {\r\n            classList += ` narramorph-emphasis-${transformation.emphasis}`;\r\n          }\r\n          // Add intensity class\r\n          classList += ` intensity-${intensity}`;\r\n          break;\r\n          \r\n        case 'metaComment':\r\n          classList += ' narramorph-commented';\r\n          if (transformation.commentStyle) {\r\n            classList += ` narramorph-comment-${transformation.commentStyle}`;\r\n          }\r\n          break;\r\n      }\r\n      \r\n      // Add unique identifier class\r\n      classList += ` narramorph-element-${sanitizedSelector.substring(0, 20)}`;\r\n      \r\n      classMap[transformation.selector] = classList;\r\n    });\r\n    \r\n    return classMap;\r\n  }\r\n  \r\n  /**\r\n   * Create wrapper elements with CSS classes for transitions\r\n   */\r\n  wrapTransformedContent(\r\n    content: string,\r\n    transformations: TextTransformation[]\r\n  ): string {\r\n    if (transformations.length === 0) return content;\r\n    \r\n    const classMap = this.generateTransitionClasses(transformations);\r\n    let wrappedContent = content;\r\n    \r\n    // Apply wrapping to each transformed element\r\n    // We need to be careful with the order here to avoid nested replacements\r\n    Object.entries(classMap).forEach(([selector, className]) => {\r\n      // Find the transformation for this selector\r\n      const transformation = transformations.find(t => t.selector === selector);\r\n      if (!transformation) return;\r\n      \r\n      // Different wrapping strategies based on transformation type\r\n      // Prepare replacement text outside of the switch to avoid lexical declaration in case block\r\n      let replacement: string;\r\n      \r\n      // Create data attributes for better animation targeting\r\n      const dataAttrs = `\r\n        data-transform-type=\"${transformation.type}\"\r\n        data-selector=\"${escapeRegExp(selector.substring(0, 30))}\"\r\n        data-transform-id=\"${this.getUniqueTransformId(transformation)}\"\r\n      `;\r\n      \r\n      switch (transformation.type) {\r\n        case 'replace':\r\n        case 'fragment':\r\n        case 'emphasize':\r\n          // These transformations modify the original content, so wrap the result\r\n          replacement = transformation.type === 'replace' ?\r\n            transformation.replacement || '' :\r\n            selector;\r\n          \r\n          wrappedContent = wrappedContent.replace(\r\n            new RegExp(escapeRegExp(replacement), 'g'),\r\n            `<span class=\"${className}\" ${dataAttrs}>${replacement}</span>`\r\n          );\r\n          break;\r\n          \r\n        case 'expand':\r\n          // For expansions, we need to wrap both the original and expanded content\r\n          if (transformation.replacement) {\r\n            const expandedText = `${selector} ${transformation.replacement}`;\r\n            const expandStyle = transformation.expandStyle || 'default';\r\n            let expansionClass = 'narramorph-expansion';\r\n            \r\n            if (expandStyle === 'reveal') {\r\n              expansionClass = 'narramorph-reveal-expansion';\r\n            } else if (expandStyle === 'inline') {\r\n              expansionClass = 'narramorph-inline-expansion';\r\n            } else if (expandStyle === 'paragraph') {\r\n              expansionClass = 'narramorph-paragraph-expansion';\r\n            }\r\n            \r\n            wrappedContent = wrappedContent.replace(\r\n              new RegExp(escapeRegExp(expandedText), 'g'),\r\n              `<span class=\"${className}\" ${dataAttrs}>${selector}<span class=\"${expansionClass}\">${transformation.replacement}</span></span>`\r\n            );\r\n          }\r\n          break;\r\n          \r\n        case 'metaComment':\r\n          // For meta comments, wrap the comment part\r\n          if (transformation.replacement) {\r\n            const commentStyle = transformation.commentStyle || 'inline';\r\n            let commentClass = 'narramorph-comment';\r\n            \r\n            if (commentStyle === 'footnote') {\r\n              commentClass = 'narramorph-footnote-marker';\r\n            } else if (commentStyle === 'marginalia') {\r\n              commentClass = 'narramorph-marginalia';\r\n            } else if (commentStyle === 'interlinear') {\r\n              commentClass = 'narramorph-interlinear';\r\n            }\r\n            \r\n            const commentText = transformation.replacement;\r\n            const commentedText = `${selector} [${commentText}]`;\r\n            \r\n            // Different markup based on comment style\r\n            let wrappedMarkup = '';\r\n            if (commentStyle === 'footnote') {\r\n              const footnoteId = `footnote-${commentText.substring(0, 10).replace(/\\W/g, '')}`;\r\n              wrappedMarkup = `<span class=\"${className}\" ${dataAttrs}>${selector}<sup id=\"${footnoteId}-ref\" class=\"${commentClass}\">[]</sup></span>`;\r\n            } else if (commentStyle === 'marginalia') {\r\n              wrappedMarkup = `<span class=\"${className} narramorph-marginalia-container\" ${dataAttrs}>${selector}<span class=\"${commentClass}\">${commentText}</span></span>`;\r\n            } else if (commentStyle === 'interlinear') {\r\n              wrappedMarkup = `<span class=\"${className} narramorph-interlinear-container\" ${dataAttrs}>${selector}<span class=\"${commentClass}\">${commentText}</span></span>`;\r\n            } else {\r\n              // Default inline style\r\n              wrappedMarkup = `<span class=\"${className}\" ${dataAttrs}>${selector}<span class=\"${commentClass}\">[${commentText}]</span></span>`;\r\n            }\r\n            \r\n            wrappedContent = wrappedContent.replace(\r\n              new RegExp(escapeRegExp(commentedText), 'g'),\r\n              wrappedMarkup\r\n            );\r\n          }\r\n          break;\r\n      }\r\n    });\r\n    \r\n    return wrappedContent;\r\n  }\r\n  \r\n  /**\r\n   * Generate a unique ID for a transformation to help with animation tracking\r\n   */\r\n  private getUniqueTransformId(transformation: TextTransformation): string {\r\n    const selectorHash = this.hashString(transformation.selector || '');\r\n    const typeHash = transformation.type.substring(0, 3);\r\n    const extraPart = transformation.replacement ?\r\n      this.hashString(transformation.replacement).substring(0, 3) :\r\n      '';\r\n    \r\n    return `${typeHash}-${selectorHash}${extraPart ? '-' + extraPart : ''}`;\r\n  }\r\n  \r\n  /**\r\n   * Simple string hashing function for generating unique IDs\r\n   */\r\n  private hashString(str: string): string {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32bit integer\r\n    }\r\n    return Math.abs(hash).toString(36).substring(0, 6);\r\n  }\r\n  \r\n  /**\r\n   * Create a set of transformations based on reader patterns\r\n   * With caching and optimization\r\n   */\r\n  createTransformationsFromPatterns(\r\n    readerState: ReaderState,\r\n    nodeState: NodeState\r\n  ): TextTransformation[] {\r\n    this.metrics.patternAnalysisCount++;\r\n    \r\n    // Create cache key for pattern-based transformations\r\n    const patternHash = this.calculatePatternHash(readerState);\r\n    const cacheKey = `patterns-${nodeState.id}-${nodeState.visitCount}-${patternHash}`;\r\n    \r\n    // Check cache first\r\n    if (this.cache[cacheKey] && this.cache[cacheKey].transformations) {\r\n      this.metrics.cacheHits++;\r\n      return this.cache[cacheKey].transformations;\r\n    }\r\n    \r\n    this.metrics.cacheMisses++;\r\n    \r\n    // Get visibility status for lazy evaluation\r\n    const isNodeVisible = this.visibilityTracker[nodeState.id]?.isVisible || false;\r\n    \r\n    // Only perform expensive pattern analysis if the node is visible\r\n    // or if it's the first time analyzing this node\r\n    if (!isNodeVisible && nodeState.visitCount > 1) {\r\n      // Return minimal transformations for non-visible content\r\n      const minimalTransformations: TextTransformation[] = [];\r\n      \r\n      // Cache this result with a shorter expiry\r\n      this.cache[cacheKey] = {\r\n        transformations: minimalTransformations,\r\n        timestamp: Date.now() - (this.CACHE_EXPIRY_TIME / 2), // Shorter expiry\r\n        content: ''\r\n      };\r\n      \r\n      return minimalTransformations;\r\n    }\r\n    \r\n    // Get patterns from the path analyzer - expensive operation\r\n    const patterns = pathAnalyzer.identifySignificantPatterns(readerState, {\r\n      [nodeState.id]: nodeState\r\n    });\r\n    \r\n    // Get attractor engagements - another expensive operation\r\n    const attractorEngagements = pathAnalyzer.calculateAttractorEngagement(readerState, {\r\n      [nodeState.id]: nodeState\r\n    });\r\n    \r\n    // Create transformation conditions from patterns\r\n    const patternConditions = pathAnalyzer.createTransformationConditions(\r\n      patterns,\r\n      attractorEngagements\r\n    );\r\n    \r\n    // Convert pattern conditions to text transformations\r\n    const transformations: TextTransformation[] = [];\r\n    \r\n    // Add priority field to transformations for later optimization\r\n    \r\n    patternConditions.forEach(condition => {\r\n      // We'll create different transformation types based on the pattern type\r\n      switch (condition.type) {\r\n        case 'visitPattern':\r\n          // Repeated sequence patterns could trigger text replacements\r\n          if (condition.strength > 0.8 && nodeState.currentContent) {\r\n            // Extract a significant paragraph to transform\r\n            const paragraphs = nodeState.currentContent.split('\\n\\n');\r\n            if (paragraphs.length > 1) {\r\n              transformations.push({\r\n                type: 'replace',\r\n                selector: paragraphs[1],\r\n                replacement: `${paragraphs[1]} [A recurring pattern emerges in your exploration]`,\r\n                priority: 'high'\r\n              });\r\n            }\r\n          }\r\n          break;\r\n          \r\n        case 'characterFocus':\r\n          // Character focus could trigger emphasis of character-specific content\r\n          if (condition.strength > 0.7 && \r\n              condition.condition.characters?.[0] === nodeState.character &&\r\n              nodeState.currentContent) {\r\n            // Find character-specific content to emphasize\r\n            const paragraphs = nodeState.currentContent.split('\\n\\n');\r\n            if (paragraphs.length > 0) {\r\n              transformations.push({\r\n                type: 'emphasize',\r\n                selector: paragraphs[0],\r\n                emphasis: 'color',\r\n                priority: 'medium'\r\n              });\r\n            }\r\n          }\r\n          break;\r\n          \r\n        case 'temporalFocus':\r\n          // Temporal focus could trigger meta-commentary\r\n          if (condition.strength > 0.7 && \r\n              condition.condition.temporalPosition && \r\n              nodeState.currentContent) {\r\n            const temporalLayer = nodeState.temporalValue <= 3 ? 'past' : \r\n                                 nodeState.temporalValue <= 6 ? 'present' : 'future';\r\n                                 \r\n            if (temporalLayer === condition.condition.temporalPosition) {\r\n              // Find temporal-related content\r\n              const paragraphs = nodeState.currentContent.split('\\n\\n');\r\n              if (paragraphs.length > 2) {\r\n                transformations.push({\r\n                  type: 'metaComment',\r\n                  selector: paragraphs[2],\r\n                  replacement: `You seem drawn to ${condition.condition.temporalPosition} narratives`,\r\n                  priority: 'low' // Comments are less essential\r\n                });\r\n              }\r\n            }\r\n          }\r\n          break;\r\n          \r\n        case 'readingRhythm':\r\n          // Reading rhythm transformations removed (previously time-based)\r\n          break;\r\n          \r\n        case 'attractorAffinity':\r\n        case 'attractorEngagement':\r\n          // Attractor engagement affects content expansion\r\n          if (condition.strength > 0.7 && \r\n              condition.condition.strangeAttractorsEngaged?.[0] &&\r\n              nodeState.currentContent) {\r\n            // Find attractor-related content\r\n            const attractor = condition.condition.strangeAttractorsEngaged[0];\r\n            const paragraphs = nodeState.currentContent.split('\\n\\n');\r\n            \r\n            if (paragraphs.length > 0 && \r\n                nodeState.strangeAttractors.includes(attractor)) {\r\n              transformations.push({\r\n                type: 'expand',\r\n                selector: paragraphs[0],\r\n                replacement: `The concept of ${attractor.replace('-', ' ')} resonates with you.`,\r\n                priority: 'high' // Attractor-related content is important\r\n              });\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    });\r\n    \r\n    return transformations;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function to escape special regex characters in a string\r\n */\r\nfunction escapeRegExp(string: string): string {\r\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\n// Export a singleton instance for use throughout the application\r\nexport const transformationService = new TransformationService();","/**\r\n * Custom hook for managing node state and transformations\r\n * Provides utilities for accessing, navigating, and transforming nodes\r\n */\r\n\r\nimport { useCallback, useEffect, useMemo, useState } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  selectNodeById,\r\n  visitNode,\r\n  revealConnection,\r\n  applyTransformation,\r\n  evaluateTransformations\r\n} from '../store/slices/nodesSlice';\r\nimport {\r\n  navigateToNode,\r\n  engageAttractor,\r\n  selectCurrentNodeId,\r\n  selectNodeRevisitCount\r\n} from '../store/slices/readerSlice';\r\nimport { setViewMode } from '../store/slices/interfaceSlice';\r\nimport { StrangeAttractor, TransformationRule, TransformationCondition, TextTransformation } from '../types';\r\nimport { RootState } from '../store/types';\r\nimport { transformationEngine } from '../services/TransformationEngine';\r\nimport { transformationService } from '../services/TransformationService';\r\n\r\n// Import the CSS for transformations\r\nimport '../styles/NarramorphTransformations.css';\r\n\r\n/**\r\n * Custom hook for node state management and transformations\r\n * @param nodeId Optional node ID to focus on\r\n */\r\nexport const useNodeState = (nodeId?: string) => {\r\n  const dispatch = useDispatch();\r\n  \r\n  // Track applied transformations for transitions\r\n  const [appliedTransformations, setAppliedTransformations] = useState<TextTransformation[]>([]);\r\n  // Track if transformations were just applied for animation\r\n  const [newlyTransformed, setNewlyTransformed] = useState(false);\r\n  \r\n  // Get current node ID if not provided\r\n  const currentNodeId = useSelector(selectCurrentNodeId);\r\n  const targetNodeId = nodeId || currentNodeId;\r\n  \r\n  // Select node data\r\n  const node = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeById(state as RootState, targetNodeId) : null\r\n  );\r\n  \r\n  // Select all nodes to access any node data\r\n  const allNodes = useSelector((state: RootState) => state.nodes.data);\r\n  \r\n  // Get revisit count\r\n  const revisitCount = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeRevisitCount(state, targetNodeId) : 0\r\n  );\r\n  \r\n  // Get reader state for transformation evaluation\r\n  // Used in evaluateTransformations and evaluateCondition\r\n  const readerState = useSelector((state: RootState) => state.reader);\r\n  \r\n  // Navigate to a node\r\n  const navigateTo = useCallback((id: string) => {\r\n    const nodeData = allNodes[id];\r\n    \r\n    if (nodeData) {\r\n      // Record navigation in reader path with required properties\r\n      dispatch(navigateToNode({\r\n        nodeId: id,\r\n        character: nodeData.character,\r\n        temporalValue: nodeData.temporalValue,\r\n        attractors: nodeData.strangeAttractors\r\n      }));\r\n      \r\n      // Record visit in node state\r\n      dispatch(visitNode(id));\r\n      \r\n      // Switch to reading view\r\n      dispatch(setViewMode('reading'));\r\n      \r\n      // This would be where we load the node content in a real implementation\r\n      // For now, we'll just log it\r\n      console.log(`Navigating to node: ${id}`);\r\n    } else {\r\n      console.error(`Could not navigate to node: ${id} - node data not found`);\r\n    }\r\n  }, [dispatch, allNodes]);\r\n  \r\n  // Reveal a new connection\r\n  const revealNodeConnection = useCallback((sourceId: string, targetId: string) => {\r\n    dispatch(revealConnection({ nodeId: sourceId, targetId }));\r\n  }, [dispatch]);\r\n  \r\n  // Engage with a strange attractor\r\n  const engageWithAttractor = useCallback((attractor: StrangeAttractor) => {\r\n    dispatch(engageAttractor(attractor));\r\n  }, [dispatch]);\r\n  \r\n  // Apply a transformation to the node's content\r\n  const applyNodeTransformation = useCallback((\r\n    nodeId: string, \r\n    transformation: TransformationRule\r\n  ) => {\r\n    dispatch(applyTransformation({ nodeId, transformation }));\r\n  }, [dispatch]);\r\n  \r\n  // Get neighboring nodes based on revealed connections\r\n  const neighbors = useMemo(() => {\r\n    if (!node) return [];\r\n    return node.revealedConnections;\r\n  }, [node]);\r\n  \r\n  // Generate transformed content with visual transitions\r\n  const transformedContent = useMemo(() => {\r\n    if (!node?.currentContent) return null;\r\n    \r\n    // Get reader-pattern based transformations\r\n    const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n      readerState,\r\n      node\r\n    );\r\n    \r\n    // Combine with rule-based transformations from node\r\n    const allTransformations = [\r\n      ...patternTransformations,\r\n      ...node.transformations.flatMap(rule =>\r\n        transformationEngine.evaluateCondition(rule.condition, readerState, node) ?\r\n          rule.transformations : []\r\n      )\r\n    ];\r\n    \r\n    // Apply transformations with priority handling\r\n    const transformedText = transformationService.getCachedTransformedContent(\r\n      node.id,\r\n      node.currentContent,\r\n      allTransformations,\r\n      readerState,\r\n      node\r\n    );\r\n    \r\n    // Add wrapper elements with transition classes\r\n    const wrappedContent = transformationService.wrapTransformedContent(\r\n      transformedText,\r\n      allTransformations\r\n    );\r\n    \r\n    // Update state for tracking\r\n    if (JSON.stringify(appliedTransformations) !== JSON.stringify(allTransformations)) {\r\n      setAppliedTransformations(allTransformations);\r\n      setNewlyTransformed(true);\r\n    }\r\n    \r\n    return wrappedContent;\r\n  }, [node, readerState, appliedTransformations]);\r\n  \r\n  // Reset newly transformed flag after animation\r\n  useEffect(() => {\r\n    if (newlyTransformed) {\r\n      const timer = setTimeout(() => {\r\n        setNewlyTransformed(false);\r\n      }, 2000); // Match the animation duration\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [newlyTransformed]);\r\n  \r\n  // Apply transformations based on visit count and reader patterns\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId) return;\r\n    \r\n    // Generate default transformations based on visit count\r\n    // Basic transformation based on visit count\r\n    if (node.visitCount === 1) {\r\n      const basicTransformation: TransformationRule = {\r\n        condition: {\r\n          visitCount: 1\r\n        },\r\n        transformations: [\r\n          {\r\n            type: 'emphasize',\r\n            selector: 'first-paragraph',\r\n            emphasis: 'italic'\r\n          }\r\n        ]\r\n      };\r\n      \r\n      applyNodeTransformation(targetNodeId, basicTransformation);\r\n    }\r\n    \r\n    // Generate pattern-based transformations\r\n    if (node.visitCount >= 2) {\r\n      // This will trigger pattern analysis and create transformations\r\n      // based on reader behavior\r\n      const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n        readerState,\r\n        node\r\n      );\r\n      \r\n      // Apply these transformations\r\n      if (patternTransformations.length > 0) {\r\n        const patternBasedRule: TransformationRule = {\r\n          condition: { visitCount: node.visitCount }, // Always apply for current visit\r\n          transformations: patternTransformations\r\n        };\r\n        \r\n        applyNodeTransformation(targetNodeId, patternBasedRule);\r\n      }\r\n    }\r\n    \r\n    // Evaluate all transformations against current reader state\r\n    dispatch(evaluateTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n    \r\n  }, [node, targetNodeId, revisitCount, readerState, dispatch, applyNodeTransformation]);\r\n  \r\n  // Evaluate a condition directly using the transformation engine\r\n  const evaluateCondition = useCallback(\r\n    (condition: TransformationCondition) => {\r\n      if (!node) return false;\r\n      return transformationEngine.evaluateCondition(condition, readerState, node);\r\n    },\r\n    [node, readerState]\r\n  );\r\n  \r\n  // Return the API\r\n  return {\r\n    node,\r\n    navigateTo,\r\n    revealNodeConnection,\r\n    engageWithAttractor,\r\n    applyNodeTransformation,\r\n    evaluateCondition,\r\n    neighbors,\r\n    revisitCount,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  };\r\n};\r\n\r\nexport default useNodeState;","/**\r\n * TransformationAnimationContainer Component\r\n * \r\n * Provides enhanced transition animations when content transforms between states.\r\n * This component wraps around transformed content and adds visual context\r\n * to help users understand the transformation process.\r\n */\r\n\r\nimport React, { useEffect, useRef, useState, useLayoutEffect } from 'react';\r\nimport { TextTransformation } from '../../types';\r\n\r\n// For debugging DOM measurements and layout issues\r\ninterface ElementMeasurements {\r\n  width: number;\r\n  height: number;\r\n  visibility: string;\r\n  display: string;\r\n  opacity: string;\r\n  position: string;\r\n  zIndex: string;\r\n  overflow: string;\r\n}\r\n\r\ninterface TransformationAnimationContainerProps {\r\n  children: React.ReactNode;\r\n  transformations: TextTransformation[];\r\n  isNewlyTransformed: boolean;\r\n  nodeId: string;\r\n}\r\n\r\nconst TransformationAnimationContainer: React.FC<TransformationAnimationContainerProps> = ({\r\n  children,\r\n  transformations,\r\n  isNewlyTransformed,\r\n  nodeId\r\n}): React.ReactElement => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [animationState, setAnimationState] = useState<'idle' | 'entering' | 'active'>('idle');\r\n  const [transformationCount, setTransformationCount] = useState(transformations.length);\r\n  const [renderAttempt, setRenderAttempt] = useState(0);\r\n  \r\n  // Track DOM measurements for debugging\r\n  const [measurements, setMeasurements] = useState<ElementMeasurements | null>(null);\r\n  const [contentVisible, setContentVisible] = useState(true);\r\n  \r\n  // Force a re-render after mount to ensure visibility\r\n  useEffect(() => {\r\n    // After mount, force a re-render to ensure proper layout\r\n    // Limit to max 3 attempts to prevent infinite loops\r\n    if (renderAttempt < 3) {\r\n      const timer = setTimeout(() => {\r\n        setRenderAttempt(prev => prev + 1);\r\n        console.log(`[AnimationContainer] Forced re-render for node: ${nodeId}, attempt: ${renderAttempt + 1}`);\r\n      }, 100);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [nodeId, renderAttempt]);\r\n  \r\n  // When transformations change, update the animation state\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      setAnimationState('entering');\r\n      \r\n      // After the animation completes, set to active state\r\n      const timer = setTimeout(() => {\r\n        setAnimationState('active');\r\n      }, 1000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isNewlyTransformed, transformations]);\r\n  \r\n  // When node changes or transformation count changes, reset animation state\r\n  useEffect(() => {\r\n    setAnimationState('idle');\r\n    setTransformationCount(transformations.length);\r\n    \r\n    // Debug log for node changes\r\n    console.log(`[AnimationContainer] Node changed to: ${nodeId}, transformations: ${transformations.length}`);\r\n  }, [nodeId, transformations.length]);\r\n  \r\n  // Monitor and log DOM measurements for debugging visibility issues\r\n  useLayoutEffect(() => {\r\n    if (!containerRef.current) return;\r\n    \r\n    // Function to measure DOM element properties\r\n    const measureElement = () => {\r\n      if (!containerRef.current) return;\r\n      \r\n      const style = window.getComputedStyle(containerRef.current);\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      \r\n      const newMeasurements: ElementMeasurements = {\r\n        width: rect.width,\r\n        height: rect.height,\r\n        visibility: style.visibility,\r\n        display: style.display,\r\n        opacity: style.opacity,\r\n        position: style.position,\r\n        zIndex: style.zIndex,\r\n        overflow: style.overflow\r\n      };\r\n      \r\n      setMeasurements(newMeasurements);\r\n      \r\n      // Check if content is visible in DOM\r\n      const isVisible = rect.width > 0 &&\r\n                        rect.height > 0 &&\r\n                        style.visibility !== 'hidden' &&\r\n                        style.display !== 'none' &&\r\n                        parseFloat(style.opacity) > 0;\r\n                        \r\n      setContentVisible(isVisible);\r\n      \r\n      // Log significant changes to visibility\r\n      if (contentVisible !== isVisible) {\r\n        console.log(`[AnimationContainer] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`, {\r\n          nodeId,\r\n          transformations: transformations.length,\r\n          animationState,\r\n          measurements: newMeasurements\r\n        });\r\n      }\r\n    };\r\n    \r\n    // Measure immediately\r\n    measureElement();\r\n    \r\n    // Measure after animations might be complete\r\n    const timer = setTimeout(measureElement, 1100);\r\n    \r\n    // Set up mutation observer to track DOM changes - with debouncing\r\n    let timeoutId: number | null = null;\r\n    const observer = new MutationObserver((mutations) => {\r\n      // Only log significant mutations to reduce noise\r\n      if (mutations.length > 2) {\r\n        console.log(`[AnimationContainer] DOM mutations detected: ${mutations.length}`);\r\n      }\r\n      \r\n      // Debounce measurements to prevent infinite loops\r\n      if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      \r\n      timeoutId = window.setTimeout(() => {\r\n        measureElement();\r\n        timeoutId = null;\r\n      }, 500);\r\n    });\r\n    \r\n    observer.observe(containerRef.current, {\r\n      attributes: true,\r\n      childList: true,\r\n      subtree: false // Reduced to false to prevent excessive notifications\r\n    });\r\n    \r\n    return () => {\r\n      clearTimeout(timer);\r\n      observer.disconnect();\r\n    };\r\n  }, [nodeId, transformations, animationState, contentVisible]);\r\n  \r\n  // Determine which animation effect to apply based on transformation types\r\n  const getAnimationClass = () => {\r\n    if (animationState === 'idle') return '';\r\n    \r\n    const hasReplacements = transformations.some(t => t.type === 'replace');\r\n    const hasEmphasis = transformations.some(t => t.type === 'emphasize');\r\n    const hasExpansions = transformations.some(t => t.type === 'expand');\r\n    \r\n    if (animationState === 'entering') {\r\n      if (hasReplacements) return 'narramorph-container-replace-active';\r\n      if (hasEmphasis) return 'narramorph-container-emphasis-active';\r\n      if (hasExpansions) return 'narramorph-container-expand-active';\r\n      return 'narramorph-container-transform-active';\r\n    }\r\n    \r\n    return 'narramorph-container-active';\r\n  };\r\n  \r\n  // Get a description of transformation activity\r\n  const getTransformationDescription = () => {\r\n    if (transformations.length === 0) return '';\r\n    \r\n    const typeCount: Record<string, number> = {};\r\n    transformations.forEach(t => {\r\n      typeCount[t.type] = (typeCount[t.type] || 0) + 1;\r\n    });\r\n    \r\n    // Generate a description based on the types of transformations\r\n    const descriptions = [];\r\n    \r\n    if (typeCount['replace']) {\r\n      descriptions.push(`${typeCount['replace']} replacements`);\r\n    }\r\n    \r\n    if (typeCount['emphasize']) {\r\n      descriptions.push(`${typeCount['emphasize']} emphasis`);\r\n    }\r\n    \r\n    if (typeCount['expand']) {\r\n      descriptions.push(`${typeCount['expand']} expansions`);\r\n    }\r\n    \r\n    if (typeCount['fragment']) {\r\n      descriptions.push(`${typeCount['fragment']} fragmentations`);\r\n    }\r\n    \r\n    if (typeCount['metaComment']) {\r\n      descriptions.push(`${typeCount['metaComment']} comments`);\r\n    }\r\n    \r\n    return descriptions.join(', ');\r\n  };\r\n  \r\n  // Check if number of transformations has changed\r\n  const hasChangedTransformations = transformations.length !== transformationCount;\r\n  \r\n  // Log when animations are triggered\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      console.log(`[AnimationContainer] Animation started for node: ${nodeId}`, {\r\n        transformations: transformations.length,\r\n        animationState,\r\n        contentVisible\r\n      });\r\n    }\r\n  }, [isNewlyTransformed, nodeId, transformations.length, animationState, contentVisible]);\r\n  \r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`narramorph-animation-container ${getAnimationClass()}`}\r\n      data-transformation-count={transformations.length}\r\n      data-newly-transformed={isNewlyTransformed}\r\n      data-animation-state={animationState}\r\n      data-visible={contentVisible}\r\n      data-render-attempt={renderAttempt}\r\n      style={{\r\n        overflow: 'visible',\r\n        minHeight: '150px',\r\n        position: 'relative', // Ensure positioning context\r\n        visibility: 'visible',\r\n        display: 'block',\r\n        opacity: 1\r\n      }}\r\n    >\r\n      {/* Visual indicator for active transformations */}\r\n      {transformations.length > 0 && (\r\n        <div \r\n          className={`narramorph-transformation-indicator ${isNewlyTransformed ? 'active' : ''}`}\r\n          title={getTransformationDescription()}\r\n        >\r\n          <span className=\"transformation-count\">{transformations.length}</span>\r\n          {hasChangedTransformations && (\r\n            <span className=\"transformation-change-indicator\">\r\n              {transformations.length > transformationCount ? '+' : ''}\r\n              {transformations.length - transformationCount}\r\n            </span>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content with transformations */}\r\n      <div\r\n        ref={contentRef}\r\n        className=\"narramorph-animation-content\"\r\n        style={{\r\n          position: 'relative',\r\n          visibility: 'visible',\r\n          display: 'block',\r\n          opacity: 1,\r\n          minHeight: '100px'\r\n        }}\r\n      >\r\n        {renderAttempt === 0 ? (\r\n          <div className=\"animation-placeholder\" style={{ padding: '20px', textAlign: 'center' }}>\r\n            <p>Preparing narrative...</p>\r\n          </div>\r\n        ) : (\r\n          children\r\n        )}\r\n      </div>\r\n      \r\n      {/* Debug info overlay - only in development */}\r\n      {process.env.NODE_ENV === 'development' && measurements && (\r\n        <div\r\n          className=\"animation-debug-info\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: 0,\r\n            right: 0,\r\n            background: 'rgba(0,0,0,0.7)',\r\n            color: '#fff',\r\n            padding: '3px',\r\n            fontSize: '9px',\r\n            zIndex: 1000,\r\n            pointerEvents: 'none'\r\n          }}\r\n        >\r\n          <div>{`${Math.round(measurements.width)}x${Math.round(measurements.height)}`}</div>\r\n          <div>{`Vis:${measurements.visibility.charAt(0)}|Dis:${measurements.display.charAt(0)}`}</div>\r\n          <div>{`Op:${parseFloat(measurements.opacity).toFixed(1)}|Z:${measurements.zIndex}`}</div>\r\n          <div>{`T:${transformations.length}|S:${animationState.charAt(0)}`}</div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TransformationAnimationContainer;"],"names":["PathAnalyzer","__publicField","readerState","nodes","patterns","path","repeatedSequences","_a","sequence","sequenceLength","maxPossibleLength","lengthFactor","occurrences","i","id","idx","maxPossibleOccurrences","repetitionFactor","strength","characterFocus","totalVisits","character","count","ratio","characterSequences","characterSequence","oscillationCount","c1","c2","maxPossibleOscillations","oscillationRatio","temporalLayerFocus","layer","temporalSequences","temporalSequence","chronologicalCount","t1","t2","t3","maxPossibleProgressions","progressionRatio","reverseChronologicalCount","reverseProgressionRatio","attractorsEngaged","detailedVisits","totalEngagements","sum","attractor","engagementRatio","relatedNodes","node","visitRatio","visit","nodeAttractors","recentVisits","sharedAttractorTransitions","prevNode","currNode","prevAttractors","currAttractors","thematicContinuityRatio","attractorEngagements","attractorStr","engagementVisits","trend","midpoint","firstHalf","secondHalf","totalAllAttractors","relativeEngagement","recencyFactor","consistencyFactor","engagementScore","b","a","pattern","conditions","engagement","pathAnalyzer","TransformationService","endpointProgress","recentPath","topAttractors","progressValues","nodeId","visitCount","patternHash","now","entries","value","keyA","valueA","keyB","valueB","nodeIdA","nodeIdB","isVisibleA","isVisibleB","_b","transformations","nodeState","prioritized","transformation","priority","sourceType","conflictGroup","item","matchingPattern","p","relatedAttractor","groupedByConflict","resolved","group","content","transformedContent","transformationEngine","isVisible","tracker","cacheKey","t","essentialTransformations","transformedSegments","seg","selector","start","score","typeComplexity","contentSize","sizeFactor","classMap","sanitizedSelector","classList","intensity","wrappedContent","className","replacement","dataAttrs","escapeRegExp","expandedText","expandStyle","expansionClass","commentStyle","commentClass","commentText","commentedText","wrappedMarkup","footnoteId","selectorHash","typeHash","extraPart","str","hash","char","minimalTransformations","patternConditions","condition","paragraphs","string","transformationService","useNodeState","dispatch","useDispatch","appliedTransformations","setAppliedTransformations","useState","newlyTransformed","setNewlyTransformed","currentNodeId","useSelector","selectCurrentNodeId","targetNodeId","state","selectNodeById","allNodes","revisitCount","selectNodeRevisitCount","navigateTo","useCallback","nodeData","navigateToNode","visitNode","setViewMode","revealNodeConnection","sourceId","targetId","revealConnection","engageWithAttractor","engageAttractor","applyNodeTransformation","applyTransformation","neighbors","useMemo","allTransformations","rule","transformedText","useEffect","timer","patternTransformations","patternBasedRule","evaluateTransformations","evaluateCondition","TransformationAnimationContainer","children","isNewlyTransformed","containerRef","useRef","contentRef","animationState","setAnimationState","transformationCount","setTransformationCount","renderAttempt","setRenderAttempt","measurements","setMeasurements","contentVisible","setContentVisible","prev","useLayoutEffect","measureElement","style","rect","newMeasurements","timeoutId","observer","mutations","getAnimationClass","hasReplacements","hasEmphasis","hasExpansions","getTransformationDescription","typeCount","descriptions","hasChangedTransformations","jsxs","jsx"],"mappings":"sYA2DO,MAAMA,CAAa,CAAnB,cAEYC,EAAA,2BAAsB,GAGtBA,EAAA,qCAAgC,GAGhCA,EAAA,iCAA4B,IAG5BA,EAAA,gCAA2B,IAW5C,oBACEC,EACAC,EACkB,CAClB,MAAMC,EAA6B,CAAC,EAGpC,OAAIF,EAAY,KAAK,SAAS,OAAS,KAAK,sBAK5CE,EAAS,KAAK,GAAG,KAAK,0BAA0BF,EAAY,IAAI,CAAC,EAGjEE,EAAS,KAAK,GAAG,KAAK,+BAA+BF,EAAY,IAAI,CAAC,EAGtEE,EAAS,KAAK,GAAG,KAAK,8BAA8BF,EAAY,IAAI,CAAC,EAGrEE,EAAS,KAAK,GAAG,KAAK,8BAAA,CAA+B,EAGrDA,EAAS,KAAK,GAAG,KAAK,kCAAkCF,EAAY,KAAMC,CAAK,CAAC,GAEzEC,CAAA,CAMT,0BAA0BC,EAAqC,OAC7D,MAAMD,EAA6B,CAAC,EAC9BE,GAAoBC,EAAAF,EAAK,mBAAL,YAAAE,EAAuB,kBAEjD,MAAI,CAACD,GAAqBA,EAAkB,SAAW,GAKrCA,EAAA,QAASE,GAAuB,CAC5C,GAAAA,EAAS,QAAU,KAAK,oBAAqB,CAE/C,MAAMC,EAAiBD,EAAS,OAC1BE,EAAoB,KAAK,MAAML,EAAK,SAAS,OAAS,CAAC,EACvDM,EAAeF,EAAiBC,EAGtC,IAAIE,EAAc,EAClB,QAASC,EAAI,EAAGA,GAAKR,EAAK,SAAS,OAASI,EAAgBI,IACnCR,EAAK,SAAS,MAAMQ,EAAGA,EAAIJ,CAAc,EAC7C,MAAM,CAACK,EAAIC,IAAQD,IAAON,EAASO,CAAG,CAAC,GACxDH,IAKJ,MAAMI,EAAyB,KAAK,MAAMX,EAAK,SAAS,OAASI,CAAc,EACzEQ,EAAmB,KAAK,IAAI,EAAGL,EAAcI,CAAsB,EAGnEE,EAAYP,EAAe,GAAQM,EAAmB,GAGxDL,GAAe,KAAK,+BACtBR,EAAS,KAAK,CACZ,KAAM,WACN,SAAAc,EACA,YAAa,wBAAwBT,CAAc,kBAAkBG,CAAW,SAChF,aAAcJ,CAAA,CACf,CACH,CACF,CACD,EAEMJ,CAAA,CAMT,+BAA+BC,EAAqC,OAClE,MAAMD,EAA6B,CAAC,EAC9Be,EAAiBd,EAAK,eAE5B,GAAI,CAACc,EACI,OAAAf,EAIT,MAAMgB,GADiBf,EAAK,gBAAkB,CAAC,GACZ,OACnC,GAAIe,IAAgB,EACX,OAAAhB,EAIF,OAAA,QAAQe,CAAc,EAAE,QAAQ,CAAC,CAACE,EAAWC,CAAK,IAAM,CAC7D,MAAMC,EAAQD,EAAQF,EAElB,GAAAG,GAAS,KAAK,0BAA2B,CAMrC,MAAAL,EAAW,GAAO,KAJQK,EAAQ,KAAK,4BAC1C,EAAI,KAAK,4BAKZnB,EAAS,KAAK,CACZ,KAAM,YACN,SAAAc,EACA,YAAa,mBAAmBG,CAAS,iBAAiB,KAAK,MAAME,EAAQ,GAAG,CAAC,eACjF,kBAAmB,CAACF,CAAsB,CAAA,CAC3C,CAAA,CACH,CACD,EAGK,MAAAG,GAAqBjB,EAAAF,EAAK,mBAAL,YAAAE,EAAuB,mBAC9C,GAAAiB,GAAsBA,EAAmB,OAAS,EAAG,CAEjD,MAAAC,EAAoBD,EAAmB,CAAC,EAG1C,GAAAC,EAAkB,QAAU,EAAG,CACjC,IAAIC,EAAmB,EAEvB,QAASb,EAAI,EAAGA,EAAIY,EAAkB,OAAS,EAAGZ,IAAK,CAC/C,MAAAc,EAAKF,EAAkBZ,CAAC,EACxBe,EAAKH,EAAkBZ,EAAI,CAAC,EAE9Bc,IAAOC,GACPH,EAAkBZ,EAAI,CAAC,IAAMc,GAC7BF,EAAkBZ,EAAI,CAAC,IAAMe,GAC/BF,GACF,CAGF,MAAMG,EAA0B,KAAK,OAAOJ,EAAkB,OAAS,GAAK,CAAC,EACvEK,EAAmBJ,EAAmBG,EAExCC,GAAoB,IACtB1B,EAAS,KAAK,CACZ,KAAM,YACN,SAAU0B,EACV,YAAa,wDACb,kBAAmB,MAAM,KAAK,IAAI,IAAIL,CAAiB,CAAC,CAAA,CACzD,CACH,CACF,CAGK,OAAArB,CAAA,CAMT,8BAA8BC,EAAqC,OACjE,MAAMD,EAA6B,CAAC,EAC9B2B,EAAqB1B,EAAK,mBAEhC,GAAI,CAAC0B,EACI,OAAA3B,EAIT,MAAMgB,GADiBf,EAAK,gBAAkB,CAAC,GACZ,OACnC,GAAIe,IAAgB,EACX,OAAAhB,EAIF,OAAA,QAAQ2B,CAAkB,EAAE,QAAQ,CAAC,CAACC,EAAOV,CAAK,IAAM,CAC7D,MAAMC,EAAQD,EAAQF,EAElB,GAAAG,GAAS,KAAK,yBAA0B,CAMpC,MAAAL,EAAW,GAAO,KAJQK,EAAQ,KAAK,2BAC1C,EAAI,KAAK,2BAKZnB,EAAS,KAAK,CACZ,KAAM,WACN,SAAAc,EACA,YAAa,mBAAmBc,CAAK,oBAAoB,KAAK,MAAMT,EAAQ,GAAG,CAAC,eAChF,sBAAuB,CAACS,CAAsB,CAAA,CAC/C,CAAA,CACH,CACD,EAGK,MAAAC,GAAoB1B,EAAAF,EAAK,mBAAL,YAAAE,EAAuB,kBAC7C,GAAA0B,GAAqBA,EAAkB,OAAS,EAAG,CAE/C,MAAAC,EAAmBD,EAAkB,CAAC,EAExC,GAAAC,EAAiB,QAAU,EAAG,CAEhC,IAAIC,EAAqB,EAEzB,QAAStB,EAAI,EAAGA,EAAIqB,EAAiB,OAAS,EAAGrB,IAAK,CAC9C,MAAAuB,EAAKF,EAAiBrB,CAAC,EACvBwB,EAAKH,EAAiBrB,EAAI,CAAC,EAC3ByB,EAAKJ,EAAiBrB,EAAI,CAAC,GAE5BuB,IAAO,QAAUC,IAAO,WAAaC,IAAO,UAC5CF,IAAO,QAAUC,IAAO,WACxBA,IAAO,WAAaC,IAAO,WAC9BH,GACF,CAGI,MAAAI,EAA0BL,EAAiB,OAAS,EACpDM,EAAmBL,EAAqBI,EAE1CC,GAAoB,IACtBpC,EAAS,KAAK,CACZ,KAAM,WACN,SAAUoC,EACV,YAAa,oDACb,sBAAuB,CAAC,OAAQ,UAAW,QAAQ,CAAA,CACpD,EAIH,IAAIC,EAA4B,EAEhC,QAAS5B,EAAI,EAAGA,EAAIqB,EAAiB,OAAS,EAAGrB,IAAK,CAC9C,MAAAuB,EAAKF,EAAiBrB,CAAC,EACvBwB,EAAKH,EAAiBrB,EAAI,CAAC,EAC3ByB,EAAKJ,EAAiBrB,EAAI,CAAC,GAE5BuB,IAAO,UAAYC,IAAO,WAAaC,IAAO,QAC9CF,IAAO,UAAYC,IAAO,WAC1BA,IAAO,WAAaC,IAAO,SAC9BG,GACF,CAGF,MAAMC,EAA0BD,EAA4BF,EAExDG,GAA2B,IAC7BtC,EAAS,KAAK,CACZ,KAAM,WACN,SAAUsC,EACV,YAAa,yDACb,sBAAuB,CAAC,SAAU,UAAW,MAAM,CAAA,CACpD,CACH,CACF,CAGK,OAAAtC,CAAA,CAOT,+BAAkD,CAEhD,MAAO,CAAC,CAAA,CAMV,kCACEC,EACAF,EACkB,CAClB,MAAMC,EAA6B,CAAC,EAC9BuC,EAAoBtC,EAAK,kBACzBuC,EAAiBvC,EAAK,gBAAkB,CAAC,EAE/C,GAAI,CAACsC,GAAqB,OAAO,KAAKA,CAAiB,EAAE,SAAW,EAC3D,OAAAvC,EAIH,MAAAyC,EAAmB,OAAO,OAAOF,CAAiB,EAAE,OAAO,CAACG,EAAKxB,IAAUwB,EAAMxB,EAAO,CAAC,EAC/F,GAAIuB,IAAqB,EAChB,OAAAzC,EAkCL,GA9BG,OAAA,QAAQuC,CAAiB,EAAE,QAAQ,CAAC,CAACI,EAAWzB,CAAK,IAAM,CAChE,MAAM0B,EAAkB1B,EAAQuB,EAEhC,GAAIG,GAAmB,IAAM,CAE3B,MAAMC,EAAe,OAAO,OAAO9C,CAAK,EACrC,OAAe+C,GAAAA,EAAK,kBAAkB,SAASH,CAA6B,CAAC,EAC7E,IAAIG,GAAQA,EAAK,EAAE,EAGtB,IAAIC,EAAa,EACbF,EAAa,OAAS,IAGxBE,EAFwBP,EAAe,OAAOQ,GAC5CH,EAAa,SAASG,EAAM,MAAM,CAAC,EAAE,OACRR,EAAe,QAG1C,MAAA1B,EAAY8B,EAAkB,GAAQG,EAAa,GAEzD/C,EAAS,KAAK,CACZ,KAAM,WACN,SAAAc,EACA,YAAa,wBAAwB6B,CAAS,kBAC9C,kBAAmB,CAACA,CAA6B,EACjD,aAAAE,CAAA,CACD,CAAA,CACH,CACD,EAGGL,EAAe,QAAU,EAAG,CAE9B,MAAMS,EAAqD,CAAC,EAE5D,OAAO,OAAOlD,CAAK,EAAE,QAAgB+C,GAAA,CACpBG,EAAAH,EAAK,EAAE,EAAIA,EAAK,iBAAA,CAChC,EAGK,MAAAI,EAAeV,EAAe,MAAM,CAAC,KAAK,IAAI,GAAIA,EAAe,MAAM,CAAC,EAC9E,IAAIW,EAA6B,EAEjC,QAAS,EAAI,EAAG,EAAID,EAAa,OAAQ,IAAK,CAC5C,MAAME,EAAWF,EAAa,EAAE,CAAC,EAAE,OAC7BG,EAAWH,EAAa,CAAC,EAAE,OAE3BI,EAAiBL,EAAeG,CAAQ,GAAK,CAAC,EAC9CG,EAAiBN,EAAeI,CAAQ,GAAK,CAAC,EAE3BC,EAAe,OACtCX,GAAaY,EAAe,SAASZ,CAAS,CAChD,EAEqB,OAAS,GAC5BQ,GACF,CAGI,MAAAK,EAA0BL,GAA8BD,EAAa,OAAS,GAEhFM,GAA2B,IAC7BxD,EAAS,KAAK,CACZ,KAAM,WACN,SAAUwD,EACV,YAAa,yDAAA,CACd,CACH,CAGK,OAAAxD,CAAA,CAMT,6BACEF,EACAC,EACuB,CACjB,KAAA,CAAE,KAAAE,GAASH,EACXyC,EAAoBtC,EAAK,kBACzBuC,EAAiBvC,EAAK,gBAAkB,CAAC,EAE/C,GAAI,CAACsC,GAAqB,OAAO,KAAKA,CAAiB,EAAE,SAAW,EAClE,MAAO,CAAC,EAIV,MAAMkB,EAA8C,CAAC,EAG9C,cAAA,QAAQlB,CAAiB,EAAE,QAAQ,CAAC,CAACmB,EAAcjB,CAAgB,IAAM,CAC9E,MAAME,EAAYe,EAElB,GAAIjB,IAAqB,EACvB,OAIF,MAAMI,EAAe,OAAO,OAAO9C,CAAK,EACrC,OAAe+C,GAAAA,EAAK,kBAAkB,SAASH,CAAS,CAAC,EACzD,IAAIG,GAAQA,EAAK,EAAE,EAGhBa,EAAmBnB,EAAe,OAAOQ,GAC7CA,EAAM,kBAAkB,SAASL,CAAS,CAAC,EAEzC,GAAAgB,EAAiB,SAAW,EAC9B,OAIF,IAAIC,EAAyC,SAGzC,GAAAD,EAAiB,QAAU,EAAG,CAEhC,MAAME,EAAW,KAAK,MAAMF,EAAiB,OAAS,CAAC,EACjDG,EAAYH,EAAiB,MAAM,EAAGE,CAAQ,EAC9CE,EAAaJ,EAAiB,MAAME,CAAQ,EAG9CE,EAAW,OAASD,EAAU,OAAS,IACjCF,EAAA,SACCG,EAAW,OAASD,EAAU,OAAS,KACxCF,EAAA,UACV,CAUI,MAAAI,EAAqB,OAAO,OAAOzB,CAAiB,EACvD,OAAO,CAACG,EAAKxB,IAAUwB,EAAMxB,EAAO,CAAC,EAElC+C,EAAsBxB,EAAmBuB,EAAsB,IAI/DE,EAAgB1B,EAAe,QAAQmB,EAAiBA,EAAiB,OAAS,CAAC,CAAC,EACxFnB,EAAe,OAAS,GAAM,GAAM,GAGhC2B,EAAoBR,EAAiB,OAASlB,EAAmB,GAAM,GAAM,GAG7E2B,EAAkB,KAAK,IAAI,IAC9BH,EAAqB,GACrBC,EAAgB,GAChBC,EAAoB,EAAG,EAG1BV,EAAqB,KAAK,CACxB,UAAAd,EACA,gBAAAyB,EACA,iBAAA3B,EACA,aAAAI,EACA,MAAAe,CAAA,CACD,CAAA,CACF,EAGMH,EAAqB,KAAK,CAAC,EAAGY,IAAMA,EAAE,gBAAkB,EAAE,eAAe,CAAA,CAMlF,4BACEvE,EACAC,EACkB,CAQX,OANa,KAAK,oBAAoBD,EAAaC,CAAK,EAG5B,KAAK,CAACuE,EAAGD,IAAMA,EAAE,SAAWC,EAAE,QAAQ,EAItE,OAAkBC,GAAAA,EAAQ,UAAY,EAAG,EACzC,MAAM,EAAG,CAAC,CAAA,CAOf,+BACEvE,EACAyD,EACyB,CACzB,MAAMe,EAAsC,CAAC,EAG7C,OAAAxE,EAAS,QAAmBuE,GAAA,CAC1B,OAAQA,EAAQ,KAAM,CACpB,IAAK,WACCA,EAAQ,cAAgBA,EAAQ,aAAa,QAAU,GACzDC,EAAW,KAAK,CACd,KAAM,eACN,UAAW,CACT,aAAcD,EAAQ,YACxB,EACA,SAAUA,EAAQ,QAAA,CACnB,EAEH,MAEF,IAAK,YACCA,EAAQ,mBAAqBA,EAAQ,kBAAkB,OAAS,GAElEC,EAAW,KAAK,CACd,KAAM,iBACN,UAAW,CAET,WAAYD,EAAQ,iBACtB,EACA,SAAUA,EAAQ,QAAA,CACnB,EAEH,MAEF,IAAK,WACCA,EAAQ,uBAAyBA,EAAQ,sBAAsB,OAAS,GAC1EC,EAAW,KAAK,CACd,KAAM,gBACN,UAAW,CACT,iBAAkBD,EAAQ,sBAAsB,CAAC,CACnD,EACA,SAAUA,EAAQ,QAAA,CACnB,EAEH,MAEF,IAAK,SAEH,MAEF,IAAK,WACCA,EAAQ,mBAAqBA,EAAQ,kBAAkB,OAAS,GAClEC,EAAW,KAAK,CACd,KAAM,oBACN,UAAW,CACT,yBAA0BD,EAAQ,iBACpC,EACA,SAAUA,EAAQ,QAAA,CACnB,EAEH,KAAA,CACJ,CACD,EAGDd,EACG,OAAqBgB,GAAAA,EAAW,iBAAmB,EAAE,EACrD,QAAsBA,GAAA,CACrBD,EAAW,KAAK,CACd,KAAM,sBACN,UAAW,CACT,yBAA0B,CAACC,EAAW,SAAS,CACjD,EACA,SAAUA,EAAW,gBAAkB,GAAA,CACxC,CAAA,CACF,EAEID,CAAA,CAEX,CAGa,MAAAE,EAAe,IAAI9E,ECnkBzB,MAAM+E,CAAsB,CAA5B,cACG9E,EAAA,aAA6B,CAAC,GAC9BA,EAAA,yBAAuC,CAAC,GAC/BA,EAAA,yBAAoB,GAAK,GAAK,KAC9BA,EAAA,yBAAoB,KAG7BA,EAAA,eAAU,CAChB,UAAW,EACX,YAAa,EACb,qBAAsB,EACtB,2BAA4B,EAC5B,iCAAkC,EAClC,gCAAiC,EACjC,qBAAsB,KAAK,IAAI,CACjC,GAMQ,qBAAqBC,EAAkC,CAEvD,KAAA,CACJ,KAAM,CAAE,SAAAM,EAAU,kBAAAmC,CAAkB,EACpC,iBAAAqC,CAAA,EACE9E,EAGE+E,EAAazE,EAAS,MAAM,EAAE,EAAE,KAAK,GAAG,EAGxC0E,EAAgB,OAAO,QAAQvC,CAAiB,EACnD,KAAK,CAAC+B,EAAGD,IAAMA,EAAE,CAAC,EAAIC,EAAE,CAAC,CAAC,EAC1B,MAAM,EAAG,CAAC,EACV,IAAI,CAAC,CAAC3B,CAAS,IAAMA,CAAS,EAC9B,KAAK,GAAG,EAGLoC,EAAiB,OAAO,OAAOH,CAAgB,EAAE,KAAK,GAAG,EAE/D,MAAO,GAAGC,CAAU,IAAIC,CAAa,IAAIC,CAAc,EAAA,CAMjD,YAAYC,EAAgBC,EAAoBC,EAA6B,CACnF,MAAO,GAAGF,CAAM,IAAIC,CAAU,IAAIC,CAAW,EAAA,CASvC,YAAmB,CACnB,MAAAC,EAAM,KAAK,IAAI,EAGrB,GAAIA,EAAM,KAAK,QAAQ,qBAAuB,IAC5C,OAGF,KAAK,QAAQ,qBAAuBA,EAGpC,IAAIC,EAAU,OAAO,QAAQ,KAAK,KAAK,EAC7BA,EAAAA,EAAQ,OAAO,CAAC,EAAGC,CAAK,IAAMF,EAAME,EAAM,WAAa,KAAK,iBAAiB,EAGnFD,EAAQ,OAAS,KAAK,oBAEhBA,EAAA,KAAK,CAAC,CAACE,EAAMC,CAAM,EAAG,CAACC,EAAMC,CAAM,IAAM,SAC/C,MAAMC,EAAUJ,EAAK,MAAM,GAAG,EAAE,CAAC,EAC3BK,EAAUH,EAAK,MAAM,GAAG,EAAE,CAAC,EAG3BI,IAAazF,EAAA,KAAK,kBAAkBuF,CAAO,IAA9B,YAAAvF,EAAiC,YAAa,GAC3D0F,IAAaC,EAAA,KAAK,kBAAkBH,CAAO,IAA9B,YAAAG,EAAiC,YAAa,GACjE,OAAIF,IAAeC,EAAmBA,EAAa,EAAI,GAGhDJ,EAAO,UAAYF,EAAO,SAAA,CAClC,EAGDH,EAAUA,EAAQ,MAAM,EAAG,KAAK,iBAAiB,GAI9C,KAAA,MAAQ,OAAO,YAAYA,CAAO,CAAA,CAMjC,0BACNW,EACAjG,EACAkG,EAC6B,CAEvB,MAAAC,EAA2CF,EAAgB,IAAsBG,GAAA,CAErF,IAAIC,EAAW,GACXC,EAAsD,YACpD,MAAAC,EAAoC,YAAYH,EAAe,QAAQ,GAM7E,OAAQA,EAAe,KAAM,CAC3B,IAAK,UACQC,EAAA,GACEC,EAAA,UACb,MAEF,IAAK,WACQD,EAAA,GACEC,EAAA,SACb,MAEF,IAAK,SACQD,EAAA,GACEC,EAAA,YACb,MAEF,IAAK,YACQD,EAAA,GACEC,EAAA,WACb,MAEF,IAAK,cACQD,EAAA,GACEC,EAAA,YACb,KAAA,CAGG,MAAA,CACL,eAAAF,EACA,SAAAC,EACA,WAAAC,EACA,cAAAC,CACF,CAAA,CACD,EAIKrG,EAAW0E,EAAa,4BAA4B5E,EAAa,CACrE,CAACkG,EAAU,EAAE,EAAGA,CAAA,CACjB,EAGKvC,EAAuBiB,EAAa,6BAA6B5E,EAAa,CAClF,CAACkG,EAAU,EAAE,EAAGA,CAAA,CACjB,EAGD,OAAAC,EAAY,QAAgBK,GAAA,CAEtB,GAAAA,EAAK,aAAe,UAAW,CAC3B,MAAAC,EAAkBvG,EAAS,KAAKwG,GACpCA,EAAE,OAAS,YAAcA,EAAE,SAAW,EAAG,EACvCD,IACFD,EAAK,UAAY,KAAK,MAAMC,EAAgB,SAAW,EAAE,EAC3D,CAIF,GAAID,EAAK,aAAe,aAAeA,EAAK,eAAe,SAAU,CACnE,MAAMG,EAAmBhD,EAAqB,KAC5CgB,GAAA,OAAA,QAAAtE,EAAA6F,EAAU,iBAAV,YAAA7F,EAA0B,SAASmG,EAAK,eAAe,YACvDN,EAAU,kBAAkB,SAASvB,EAAW,SAAS,EAC3D,EAEIgC,GAAoBA,EAAiB,gBAAkB,KACzDH,EAAK,UAAY,KAAK,OAAOG,EAAiB,gBAAkB,IAAM,CAAC,EACzE,CACF,CAKD,EAEMR,CAAA,CAOD,iBAAiBF,EAA2E,CAElG,MAAMW,EAAiE,CAAC,EAExEX,EAAgB,QAAgBO,GAAA,CAC1BA,EAAK,gBACFI,EAAkBJ,EAAK,aAAa,IACrBI,EAAAJ,EAAK,aAAa,EAAI,CAAC,GAE3CI,EAAkBJ,EAAK,aAAa,EAAE,KAAKA,CAAI,EACjD,CACD,EAGD,MAAMK,EAAwC,CAAC,EAI5C,OAAAZ,EAAA,OAAeO,GAAA,CAACA,EAAK,aAAa,EAClC,QAAgBA,GAAAK,EAAS,KAAKL,CAAI,CAAC,EAGtC,OAAO,OAAOI,CAAiB,EAAE,QAAiBE,GAAA,CAC5CA,EAAM,OAAS,IAEjBA,EAAM,KAAK,CAACtC,EAAGD,IAAMA,EAAE,SAAWC,EAAE,QAAQ,EACnCqC,EAAA,KAAKC,EAAM,CAAC,CAAC,EACxB,CACD,EAEMD,CAAA,CAMT,iCACEE,EACAd,EACAjG,EACAkG,EACQ,CACJ,GAAAD,EAAgB,SAAW,EACtB,OAAAc,EAIT,IAAIZ,EAAc,KAAK,0BAA0BF,EAAiBjG,EAAakG,CAAS,EAG1EC,EAAA,KAAK,iBAAiBA,CAAW,EAG/CA,EAAY,KAAK,CAAC,EAAG5B,IAAMA,EAAE,SAAW,EAAE,QAAQ,EAGlD,IAAIyC,EAAqBD,EAEzB,OAAAZ,EAAY,QAAQ,CAAC,CAAE,eAAAC,KAAqB,CAC1CY,EAAqBC,EAAqB,wBACxCD,EACAZ,CACF,CAAA,CACD,EAEMY,CAAA,CAMF,qBAAqB9B,EAAgBgC,EAAoBb,EAAmB,EAAS,CACrF,KAAK,kBAAkBnB,CAAM,IAC3B,KAAA,kBAAkBA,CAAM,EAAI,CAC/B,UAAW,GACX,qBAAsB,EACtB,uBAAwB,CAAC,EACzB,SAAAmB,CACF,GAIG,KAAA,kBAAkBnB,CAAM,EAAE,UAAYgC,EAEvCA,IACF,KAAK,kBAAkBhC,CAAM,EAAE,qBAAuB,KAAK,IAAI,EAG/D,KAAK,8BAA8BA,CAAM,EAC3C,CAMM,8BAA8BA,EAAsB,CACpD,MAAAiC,EAAU,KAAK,kBAAkBjC,CAAM,EACzC,CAACiC,GAAW,CAACA,EAAQ,WAAaA,EAAQ,uBAAuB,SAAW,IAK3E,KAAA,QAAQ,iCAAmCA,EAAQ,uBAAuB,OAG/EA,EAAQ,uBAAyB,CAAC,EAAA,CAM7B,wBACLjC,EACAkB,EACM,CAWN,GAVK,KAAK,kBAAkBlB,CAAM,IAC3B,KAAA,kBAAkBA,CAAM,EAAI,CAC/B,UAAW,GACX,qBAAsB,EACtB,uBAAwB,CAAC,EACzB,SAAU,CACZ,GAIE,KAAK,kBAAkBA,CAAM,EAAE,UAAW,CAC5C,KAAK,QAAQ,kCACb,MAAA,CAIF,KAAK,kBAAkBA,CAAM,EAAE,uBAAuB,KAAKkB,CAAc,EACzE,KAAK,QAAQ,kCAAA,CAMf,4BACElB,EACA6B,EACAd,EACAjG,EACAkG,EACQ,OAEF,MAAAd,EAAc,KAAK,qBAAqBpF,CAAW,EACnDoH,EAAW,KAAK,YAAYlC,EAAQgB,EAAU,WAAYd,CAAW,EAG3E,KAAK,WAAW,EAGhB,MAAM8B,IAAY7G,EAAA,KAAK,kBAAkB6E,CAAM,IAA7B,YAAA7E,EAAgC,YAAa,GAG3D,GAAA,KAAK,MAAM+G,CAAQ,GAAK,KAAK,MAAMA,CAAQ,EAAE,QAC/C,YAAK,QAAQ,YAGT,CAACF,GAAajB,EAAgB,OAAS,GACzC,KAAK,QAAQ,mCAGR,KAAK,MAAMmB,CAAQ,EAAE,QAO9B,GAJA,KAAK,QAAQ,cAIT,CAACF,GAAajB,EAAgB,OAAS,EAAG,CAE5CA,EAAgB,QAAaoB,GAAA,KAAK,wBAAwBnC,EAAQmC,CAAC,CAAC,EAGpE,MAAMC,EAA2BrB,EAAgB,OAAOoB,GACtDA,EAAE,OAAS,WACXA,EAAE,WAAa,MACjB,EAEIC,EAAyB,OAASrB,EAAgB,SAClCA,EAAAqB,EACpB,CAIF,MAAMN,EAAqB,KAAK,iCAC9BD,EACAd,EACAjG,EACAkG,CACF,EAGMqB,EAAsBtB,EAAgB,IAAUoB,IAAA,CACpD,SAAUA,EAAE,UAAY,GACxB,cAAeA,EAAE,KACjB,SAAU,KAAK,sBAAsBN,EAASM,EAAE,UAAY,EAAE,CAAA,EAC9D,EAAE,OAAOG,GAAOA,EAAI,SAAS,CAAC,GAAK,CAAC,EAGjC,YAAA,MAAMJ,CAAQ,EAAI,CACrB,gBAAAnB,EACA,UAAW,KAAK,IAAI,EACpB,QAASe,EACT,oBAAAO,EACA,SAAU,CACR,gBAAiB,KAAK,UAAU,CAC9B,KAAMvH,EAAY,KAAK,SAAS,MAAM,EAAE,EACxC,WAAY,OAAO,KAAKA,EAAY,KAAK,mBAAqB,CAAE,CAAA,CAAA,CACjE,EACD,cAAe,KAAK,UAAU,CAC5B,GAAIkG,EAAU,GACd,WAAYA,EAAU,UAAA,CACvB,EACD,WAAY,KAAK,kCAAkCD,CAAe,CAAA,CAEtE,EAEOe,CAAA,CAOD,sBAAsBD,EAAiBU,EAAoC,CACjF,GAAI,CAACA,GAAY,CAACV,EAAgB,MAAA,CAAC,GAAI,EAAE,EAEnC,MAAAW,EAAQX,EAAQ,QAAQU,CAAQ,EACtC,OAAIC,IAAU,GAAW,CAAC,GAAI,EAAE,EAEzB,CAACA,EAAOA,EAAQD,EAAS,MAAM,CAAA,CAOhC,kCAAkCxB,EAA+C,CACnF,OAACA,EAAgB,OAEdA,EAAgB,OAAO,CAAC0B,EAAON,IAAM,SAE1C,IAAIO,EAAiB,EACrB,OAAQP,EAAE,KAAM,CACd,IAAK,WAA6BO,EAAA,EAAG,MACrC,IAAK,YAA8BA,EAAA,EAAG,MACtC,IAAK,cAAgCA,EAAA,IAAK,MAC1C,IAAK,SAA2BA,EAAA,EAAG,MACnC,IAAK,UAA4BA,EAAA,EAAG,KAAA,CAItC,MAAMC,KAAexH,EAAAgH,EAAE,WAAF,YAAAhH,EAAY,SAAU,MAAM2F,EAAAqB,EAAE,cAAF,YAAArB,EAAe,SAAU,GACpE8B,EAAa,KAAK,IAAID,EAAc,EAAE,EAAI,KAAK,IAAI,EAAE,EAE3D,OAAOF,EAAQC,EAAiBE,GAC/B,CAAC,EAlBgC,CAkBhC,CAMN,sBAAsB7B,EAA+C,CACnE,OAAOA,EACJ,IAAIoB,GAAK,OAAA,SAAGA,EAAE,IAAI,KAAIhH,EAAAgH,EAAE,WAAF,YAAAhH,EAAY,UAAU,EAAG,GAAG,GAAE,EACpD,KAAK,GAAG,CAAA,CAMb,0BAA0B4F,EAA+D,CACvF,MAAM8B,EAAmC,CAAC,EAE1C,OAAA9B,EAAgB,QAA0BG,GAAA,CACpC,GAAA,CAACA,EAAe,SAAU,OAE9B,MAAM4B,EAAoB5B,EAAe,SAAS,QAAQ,gBAAiB,GAAG,EAG9E,IAAI6B,EADc,6CAA6C7B,EAAe,IAAI,GAI5E,MAAA8B,EAAY9B,EAAe,WAAa,EAE9C,OAAQA,EAAe,KAAM,CAC3B,IAAK,UACU6B,GAAA,uBACT7B,EAAe,qBACJ6B,GAAA,wBAEf,MAEF,IAAK,WACUA,GAAA,yBACT7B,EAAe,gBACJ6B,GAAA,wBAAwB7B,EAAe,aAAa,IAEnE,MAEF,IAAK,SACU6B,GAAA,uBACT7B,EAAe,cACJ6B,GAAA,sBAAsB7B,EAAe,aAAe,SAAS,IAE5E,MAEF,IAAK,YACU6B,GAAA,yBACT7B,EAAe,WACJ6B,GAAA,wBAAwB7B,EAAe,QAAQ,IAG9D6B,GAAa,cAAcC,CAAS,GACpC,MAEF,IAAK,cACUD,GAAA,wBACT7B,EAAe,eACJ6B,GAAA,uBAAuB7B,EAAe,YAAY,IAEjE,KAAA,CAIJ6B,GAAa,uBAAuBD,EAAkB,UAAU,EAAG,EAAE,CAAC,GAE7DD,EAAA3B,EAAe,QAAQ,EAAI6B,CAAA,CACrC,EAEMF,CAAA,CAMT,uBACEhB,EACAd,EACQ,CACJ,GAAAA,EAAgB,SAAW,EAAU,OAAAc,EAEnC,MAAAgB,EAAW,KAAK,0BAA0B9B,CAAe,EAC/D,IAAIkC,EAAiBpB,EAId,cAAA,QAAQgB,CAAQ,EAAE,QAAQ,CAAC,CAACN,EAAUW,CAAS,IAAM,CAE1D,MAAMhC,EAAiBH,EAAgB,KAAUoB,GAAAA,EAAE,WAAaI,CAAQ,EACxE,GAAI,CAACrB,EAAgB,OAIjB,IAAAiC,EAGJ,MAAMC,EAAY;AAAA,+BACOlC,EAAe,IAAI;AAAA,yBACzBmC,EAAad,EAAS,UAAU,EAAG,EAAE,CAAC,CAAC;AAAA,6BACnC,KAAK,qBAAqBrB,CAAc,CAAC;AAAA,QAGhE,OAAQA,EAAe,KAAM,CAC3B,IAAK,UACL,IAAK,WACL,IAAK,YAEHiC,EAAcjC,EAAe,OAAS,UACpCA,EAAe,aAAe,GAC9BqB,EAEFU,EAAiBA,EAAe,QAC9B,IAAI,OAAOI,EAAaF,CAAW,EAAG,GAAG,EACzC,gBAAgBD,CAAS,KAAKE,CAAS,IAAID,CAAW,SACxD,EACA,MAEF,IAAK,SAEH,GAAIjC,EAAe,YAAa,CAC9B,MAAMoC,EAAe,GAAGf,CAAQ,IAAIrB,EAAe,WAAW,GACxDqC,EAAcrC,EAAe,aAAe,UAClD,IAAIsC,EAAiB,uBAEjBD,IAAgB,SACDC,EAAA,8BACRD,IAAgB,SACRC,EAAA,8BACRD,IAAgB,cACRC,EAAA,kCAGnBP,EAAiBA,EAAe,QAC9B,IAAI,OAAOI,EAAaC,CAAY,EAAG,GAAG,EAC1C,gBAAgBJ,CAAS,KAAKE,CAAS,IAAIb,CAAQ,gBAAgBiB,CAAc,KAAKtC,EAAe,WAAW,gBAClH,CAAA,CAEF,MAEF,IAAK,cAEH,GAAIA,EAAe,YAAa,CACxB,MAAAuC,EAAevC,EAAe,cAAgB,SACpD,IAAIwC,EAAe,qBAEfD,IAAiB,WACJC,EAAA,6BACND,IAAiB,aACXC,EAAA,wBACND,IAAiB,gBACXC,EAAA,0BAGjB,MAAMC,EAAczC,EAAe,YAC7B0C,EAAgB,GAAGrB,CAAQ,KAAKoB,CAAW,IAGjD,IAAIE,EAAgB,GACpB,GAAIJ,IAAiB,WAAY,CACzB,MAAAK,EAAa,YAAYH,EAAY,UAAU,EAAG,EAAE,EAAE,QAAQ,MAAO,EAAE,CAAC,GAC9DE,EAAA,gBAAgBX,CAAS,KAAKE,CAAS,IAAIb,CAAQ,YAAYuB,CAAU,gBAAgBJ,CAAY,oBAAA,MAC5GD,IAAiB,aACVI,EAAA,gBAAgBX,CAAS,qCAAqCE,CAAS,IAAIb,CAAQ,gBAAgBmB,CAAY,KAAKC,CAAW,iBACtIF,IAAiB,cACVI,EAAA,gBAAgBX,CAAS,sCAAsCE,CAAS,IAAIb,CAAQ,gBAAgBmB,CAAY,KAAKC,CAAW,iBAGhIE,EAAA,gBAAgBX,CAAS,KAAKE,CAAS,IAAIb,CAAQ,gBAAgBmB,CAAY,MAAMC,CAAW,kBAGlHV,EAAiBA,EAAe,QAC9B,IAAI,OAAOI,EAAaO,CAAa,EAAG,GAAG,EAC3CC,CACF,CAAA,CAEF,KAAA,CACJ,CACD,EAEMZ,CAAA,CAMD,qBAAqB/B,EAA4C,CACvE,MAAM6C,EAAe,KAAK,WAAW7C,EAAe,UAAY,EAAE,EAC5D8C,EAAW9C,EAAe,KAAK,UAAU,EAAG,CAAC,EAC7C+C,EAAY/C,EAAe,YAC/B,KAAK,WAAWA,EAAe,WAAW,EAAE,UAAU,EAAG,CAAC,EAC1D,GAEK,MAAA,GAAG8C,CAAQ,IAAID,CAAY,GAAGE,EAAY,IAAMA,EAAY,EAAE,EAAA,CAM/D,WAAWC,EAAqB,CACtC,IAAIC,EAAO,EACX,QAAS1I,EAAI,EAAGA,EAAIyI,EAAI,OAAQzI,IAAK,CAC7B,MAAA2I,EAAOF,EAAI,WAAWzI,CAAC,EACpB0I,GAAAA,GAAQ,GAAKA,EAAQC,EAC9BD,EAAOA,EAAOA,CAAA,CAET,OAAA,KAAK,IAAIA,CAAI,EAAE,SAAS,EAAE,EAAE,UAAU,EAAG,CAAC,CAAA,CAOnD,kCACErJ,EACAkG,EACsB,OACtB,KAAK,QAAQ,uBAGP,MAAAd,EAAc,KAAK,qBAAqBpF,CAAW,EACnDoH,EAAW,YAAYlB,EAAU,EAAE,IAAIA,EAAU,UAAU,IAAId,CAAW,GAG5E,GAAA,KAAK,MAAMgC,CAAQ,GAAK,KAAK,MAAMA,CAAQ,EAAE,gBAC/C,YAAK,QAAQ,YACN,KAAK,MAAMA,CAAQ,EAAE,gBAU9B,GAPA,KAAK,QAAQ,cAOT,IAJkB/G,EAAA,KAAK,kBAAkB6F,EAAU,EAAE,IAAnC,YAAA7F,EAAsC,YAAa,KAInD6F,EAAU,WAAa,EAAG,CAE9C,MAAMqD,EAA+C,CAAC,EAGjD,YAAA,MAAMnC,CAAQ,EAAI,CACrB,gBAAiBmC,EACjB,UAAW,KAAK,IAAI,EAAK,KAAK,kBAAoB,EAClD,QAAS,EACX,EAEOA,CAAA,CAIH,MAAArJ,EAAW0E,EAAa,4BAA4B5E,EAAa,CACrE,CAACkG,EAAU,EAAE,EAAGA,CAAA,CACjB,EAGKvC,EAAuBiB,EAAa,6BAA6B5E,EAAa,CAClF,CAACkG,EAAU,EAAE,EAAGA,CAAA,CACjB,EAGKsD,EAAoB5E,EAAa,+BACrC1E,EACAyD,CACF,EAGMsC,EAAwC,CAAC,EAI/C,OAAAuD,EAAkB,QAAqBC,GAAA,SAErC,OAAQA,EAAU,KAAM,CACtB,IAAK,eAEH,GAAIA,EAAU,SAAW,IAAOvD,EAAU,eAAgB,CAExD,MAAMwD,EAAaxD,EAAU,eAAe,MAAM;AAAA;AAAA,CAAM,EACpDwD,EAAW,OAAS,GACtBzD,EAAgB,KAAK,CACnB,KAAM,UACN,SAAUyD,EAAW,CAAC,EACtB,YAAa,GAAGA,EAAW,CAAC,CAAC,qDAC7B,SAAU,MAAA,CACX,CACH,CAEF,MAEF,IAAK,iBAEC,GAAAD,EAAU,SAAW,MACrBpJ,EAAAoJ,EAAU,UAAU,aAApB,YAAApJ,EAAiC,MAAO6F,EAAU,WAClDA,EAAU,eAAgB,CAE5B,MAAMwD,EAAaxD,EAAU,eAAe,MAAM;AAAA;AAAA,CAAM,EACpDwD,EAAW,OAAS,GACtBzD,EAAgB,KAAK,CACnB,KAAM,YACN,SAAUyD,EAAW,CAAC,EACtB,SAAU,QACV,SAAU,QAAA,CACX,CACH,CAEF,MAEF,IAAK,gBAEH,GAAID,EAAU,SAAW,IACrBA,EAAU,UAAU,kBACpBvD,EAAU,iBACUA,EAAU,eAAiB,EAAI,OAChCA,EAAU,eAAiB,EAAI,UAAY,YAE1CuD,EAAU,UAAU,iBAAkB,CAE1D,MAAMC,EAAaxD,EAAU,eAAe,MAAM;AAAA;AAAA,CAAM,EACpDwD,EAAW,OAAS,GACtBzD,EAAgB,KAAK,CACnB,KAAM,cACN,SAAUyD,EAAW,CAAC,EACtB,YAAa,qBAAqBD,EAAU,UAAU,gBAAgB,cACtE,SAAU,KAAA,CACX,CACH,CAGJ,MAEF,IAAK,gBAEH,MAEF,IAAK,oBACL,IAAK,sBAEC,GAAAA,EAAU,SAAW,MACrBzD,EAAAyD,EAAU,UAAU,2BAApB,MAAAzD,EAA+C,KAC/CE,EAAU,eAAgB,CAE5B,MAAMrD,EAAY4G,EAAU,UAAU,yBAAyB,CAAC,EAC1DC,EAAaxD,EAAU,eAAe,MAAM;AAAA;AAAA,CAAM,EAEpDwD,EAAW,OAAS,GACpBxD,EAAU,kBAAkB,SAASrD,CAAS,GAChDoD,EAAgB,KAAK,CACnB,KAAM,SACN,SAAUyD,EAAW,CAAC,EACtB,YAAa,kBAAkB7G,EAAU,QAAQ,IAAK,GAAG,CAAC,uBAC1D,SAAU,MAAA,CACX,CACH,CAEF,KAAA,CACJ,CACD,EAEMoD,CAAA,CAEX,CAKA,SAASsC,EAAaoB,EAAwB,CACrC,OAAAA,EAAO,QAAQ,sBAAuB,MAAM,CACrD,CAGa,MAAAC,EAAwB,IAAI/E,EC91B5BgF,GAAgB3E,GAAoB,CAC/C,MAAM4E,EAAWC,EAAY,EAGvB,CAACC,EAAwBC,CAAyB,EAAIC,EAAAA,SAA+B,CAAA,CAAE,EAEvF,CAACC,EAAkBC,CAAmB,EAAIF,EAAAA,SAAS,EAAK,EAGxDG,EAAgBC,EAAYC,CAAmB,EAC/CC,EAAetF,GAAUmF,EAGzBrH,EAAOsH,EAAaG,GACxBD,EAAeE,EAAeD,EAAoBD,CAAY,EAAI,IACpE,EAGMG,EAAWL,EAAaG,GAAqBA,EAAM,MAAM,IAAI,EAG7DG,EAAeN,EAAaG,GAChCD,EAAeK,EAAuBJ,EAAOD,CAAY,EAAI,CAC/D,EAIMxK,EAAcsK,EAAaG,GAAqBA,EAAM,MAAM,EAG5DK,EAAaC,cAAanK,GAAe,CACvC,MAAAoK,EAAWL,EAAS/J,CAAE,EAExBoK,GAEFlB,EAASmB,EAAe,CACtB,OAAQrK,EACR,UAAWoK,EAAS,UACpB,cAAeA,EAAS,cACxB,WAAYA,EAAS,iBAAA,CACtB,CAAC,EAGOlB,EAAAoB,EAAUtK,CAAE,CAAC,EAGbkJ,EAAAqB,EAAY,SAAS,CAAC,EAIvB,QAAA,IAAI,uBAAuBvK,CAAE,EAAE,GAE/B,QAAA,MAAM,+BAA+BA,CAAE,wBAAwB,CACzE,EACC,CAACkJ,EAAUa,CAAQ,CAAC,EAGjBS,EAAuBL,EAAAA,YAAY,CAACM,EAAkBC,IAAqB,CAC/ExB,EAASyB,EAAiB,CAAE,OAAQF,EAAU,SAAAC,CAAU,CAAA,CAAC,CAAA,EACxD,CAACxB,CAAQ,CAAC,EAGP0B,EAAsBT,cAAalI,GAAgC,CAC9DiH,EAAA2B,EAAgB5I,CAAS,CAAC,CAAA,EAClC,CAACiH,CAAQ,CAAC,EAGP4B,EAA0BX,EAAAA,YAAY,CAC1C7F,EACAkB,IACG,CACH0D,EAAS6B,EAAoB,CAAE,OAAAzG,EAAQ,eAAAkB,CAAgB,CAAA,CAAC,CAAA,EACvD,CAAC0D,CAAQ,CAAC,EAGP8B,EAAYC,EAAAA,QAAQ,IACnB7I,EACEA,EAAK,oBADM,CAAC,EAElB,CAACA,CAAI,CAAC,EAGHgE,EAAqB6E,EAAAA,QAAQ,IAAM,CACnC,GAAA,EAAC7I,GAAA,MAAAA,EAAM,gBAAuB,OAAA,KASlC,MAAM8I,EAAqB,CACzB,GAP6BlC,EAAsB,kCACnD5J,EACAgD,CACF,EAKE,GAAGA,EAAK,gBAAgB,QAAQ+I,GAC9B9E,EAAqB,kBAAkB8E,EAAK,UAAW/L,EAAagD,CAAI,EACtE+I,EAAK,gBAAkB,CAAA,CAAC,CAE9B,EAGMC,EAAkBpC,EAAsB,4BAC5C5G,EAAK,GACLA,EAAK,eACL8I,EACA9L,EACAgD,CACF,EAGMmF,EAAiByB,EAAsB,uBAC3CoC,EACAF,CACF,EAGA,OAAI,KAAK,UAAU9B,CAAsB,IAAM,KAAK,UAAU8B,CAAkB,IAC9E7B,EAA0B6B,CAAkB,EAC5C1B,EAAoB,EAAI,GAGnBjC,CACN,EAAA,CAACnF,EAAMhD,EAAagK,CAAsB,CAAC,EAG9CiC,EAAAA,UAAU,IAAM,CACd,GAAI9B,EAAkB,CACd,MAAA+B,EAAQ,WAAW,IAAM,CAC7B9B,EAAoB,EAAK,GACxB,GAAI,EAEA,MAAA,IAAM,aAAa8B,CAAK,CAAA,CACjC,EACC,CAAC/B,CAAgB,CAAC,EAGrB8B,EAAAA,UAAU,IAAM,CACV,GAAA,GAACjJ,GAAQ,CAACwH,GAsBV,IAlBAxH,EAAK,aAAe,GActB0I,EAAwBlB,EAbwB,CAC9C,UAAW,CACT,WAAY,CACd,EACA,gBAAiB,CACf,CACE,KAAM,YACN,SAAU,kBACV,SAAU,QAAA,CACZ,CAEJ,CAEyD,EAIvDxH,EAAK,YAAc,EAAG,CAGxB,MAAMmJ,EAAyBvC,EAAsB,kCACnD5J,EACAgD,CACF,EAGI,GAAAmJ,EAAuB,OAAS,EAAG,CACrC,MAAMC,EAAuC,CAC3C,UAAW,CAAE,WAAYpJ,EAAK,UAAW,EACzC,gBAAiBmJ,CACnB,EAEAT,EAAwBlB,EAAc4B,CAAgB,CAAA,CACxD,CAIFtC,EAASuC,EAAwB,CAC/B,OAAQ7B,EACR,YAAAxK,CAAA,CACD,CAAC,EAAA,EAED,CAACgD,EAAMwH,EAAcI,EAAc5K,EAAa8J,EAAU4B,CAAuB,CAAC,EAGrF,MAAMY,EAAoBvB,EAAA,YACvBtB,GACMzG,EACEiE,EAAqB,kBAAkBwC,EAAWzJ,EAAagD,CAAI,EADxD,GAGpB,CAACA,EAAMhD,CAAW,CACpB,EAGO,MAAA,CACL,KAAAgD,EACA,WAAA8H,EACA,qBAAAM,EACA,oBAAAI,EACA,wBAAAE,EACA,kBAAAY,EACA,UAAAV,EACA,aAAAhB,EACA,mBAAA5D,EACA,iBAAAmD,EACA,uBAAAH,CACF,CACF,ECnNMuC,GAAoF,CAAC,CACzF,SAAAC,EACA,gBAAAvG,EACA,mBAAAwG,EACA,OAAAvH,CACF,IAA0B,CAClB,MAAAwH,EAAeC,SAAuB,IAAI,EAC1CC,EAAaD,SAAuB,IAAI,EACxC,CAACE,EAAgBC,CAAiB,EAAI5C,EAAAA,SAAyC,MAAM,EACrF,CAAC6C,EAAqBC,CAAsB,EAAI9C,EAAAA,SAASjE,EAAgB,MAAM,EAC/E,CAACgH,EAAeC,CAAgB,EAAIhD,EAAAA,SAAS,CAAC,EAG9C,CAACiD,EAAcC,CAAe,EAAIlD,EAAAA,SAAqC,IAAI,EAC3E,CAACmD,EAAgBC,CAAiB,EAAIpD,EAAAA,SAAS,EAAI,EAGzD+B,EAAAA,UAAU,IAAM,CAGd,GAAIgB,EAAgB,EAAG,CACf,MAAAf,EAAQ,WAAW,IAAM,CACZgB,EAAAK,GAAQA,EAAO,CAAC,EACjC,QAAQ,IAAI,mDAAmDrI,CAAM,cAAc+H,EAAgB,CAAC,EAAE,GACrG,GAAG,EAEC,MAAA,IAAM,aAAaf,CAAK,CAAA,CACjC,EACC,CAAChH,EAAQ+H,CAAa,CAAC,EAG1BhB,EAAAA,UAAU,IAAM,CACd,GAAIQ,EAAoB,CACtBK,EAAkB,UAAU,EAGtB,MAAAZ,EAAQ,WAAW,IAAM,CAC7BY,EAAkB,QAAQ,GACzB,GAAI,EAEA,MAAA,IAAM,aAAaZ,CAAK,CAAA,CACjC,EACC,CAACO,EAAoBxG,CAAe,CAAC,EAGxCgG,EAAAA,UAAU,IAAM,CACda,EAAkB,MAAM,EACxBE,EAAuB/G,EAAgB,MAAM,EAG7C,QAAQ,IAAI,yCAAyCf,CAAM,sBAAsBe,EAAgB,MAAM,EAAE,CACxG,EAAA,CAACf,EAAQe,EAAgB,MAAM,CAAC,EAGnCuH,EAAAA,gBAAgB,IAAM,CAChB,GAAA,CAACd,EAAa,QAAS,OAG3B,MAAMe,EAAiB,IAAM,CACvB,GAAA,CAACf,EAAa,QAAS,OAE3B,MAAMgB,EAAQ,OAAO,iBAAiBhB,EAAa,OAAO,EACpDiB,EAAOjB,EAAa,QAAQ,sBAAsB,EAElDkB,EAAuC,CAC3C,MAAOD,EAAK,MACZ,OAAQA,EAAK,OACb,WAAYD,EAAM,WAClB,QAASA,EAAM,QACf,QAASA,EAAM,QACf,SAAUA,EAAM,SAChB,OAAQA,EAAM,OACd,SAAUA,EAAM,QAClB,EAEAN,EAAgBQ,CAAe,EAG/B,MAAM1G,EAAYyG,EAAK,MAAQ,GACbA,EAAK,OAAS,GACdD,EAAM,aAAe,UACrBA,EAAM,UAAY,QAClB,WAAWA,EAAM,OAAO,EAAI,EAE9CJ,EAAkBpG,CAAS,EAGvBmG,IAAmBnG,GACrB,QAAQ,IAAI,uDAAuDA,EAAY,UAAY,QAAQ,GAAI,CACrG,OAAAhC,EACA,gBAAiBe,EAAgB,OACjC,eAAA4G,EACA,aAAce,CAAA,CACf,CAEL,EAGeH,EAAA,EAGT,MAAAvB,EAAQ,WAAWuB,EAAgB,IAAI,EAG7C,IAAII,EAA2B,KAC/B,MAAMC,EAAW,IAAI,iBAAkBC,GAAc,CAE/CA,EAAU,OAAS,GACrB,QAAQ,IAAI,gDAAgDA,EAAU,MAAM,EAAE,EAI5EF,GACF,aAAaA,CAAS,EAGZA,EAAA,OAAO,WAAW,IAAM,CACnBJ,EAAA,EACHI,EAAA,MACX,GAAG,CAAA,CACP,EAEQ,OAAAC,EAAA,QAAQpB,EAAa,QAAS,CACrC,WAAY,GACZ,UAAW,GACX,QAAS,EAAA,CACV,EAEM,IAAM,CACX,aAAaR,CAAK,EAClB4B,EAAS,WAAW,CACtB,GACC,CAAC5I,EAAQe,EAAiB4G,EAAgBQ,CAAc,CAAC,EAG5D,MAAMW,EAAoB,IAAM,CAC1B,GAAAnB,IAAmB,OAAe,MAAA,GAEtC,MAAMoB,EAAkBhI,EAAgB,KAAUoB,GAAAA,EAAE,OAAS,SAAS,EAChE6G,EAAcjI,EAAgB,KAAUoB,GAAAA,EAAE,OAAS,WAAW,EAC9D8G,EAAgBlI,EAAgB,KAAUoB,GAAAA,EAAE,OAAS,QAAQ,EAEnE,OAAIwF,IAAmB,WACjBoB,EAAwB,sCACxBC,EAAoB,uCACpBC,EAAsB,qCACnB,wCAGF,6BACT,EAGMC,EAA+B,IAAM,CACrC,GAAAnI,EAAgB,SAAW,EAAU,MAAA,GAEzC,MAAMoI,EAAoC,CAAC,EAC3BpI,EAAA,QAAaoB,GAAA,CAC3BgH,EAAUhH,EAAE,IAAI,GAAKgH,EAAUhH,EAAE,IAAI,GAAK,GAAK,CAAA,CAChD,EAGD,MAAMiH,EAAe,CAAC,EAElB,OAAAD,EAAU,SACZC,EAAa,KAAK,GAAGD,EAAU,OAAU,eAAe,EAGtDA,EAAU,WACZC,EAAa,KAAK,GAAGD,EAAU,SAAY,WAAW,EAGpDA,EAAU,QACZC,EAAa,KAAK,GAAGD,EAAU,MAAS,aAAa,EAGnDA,EAAU,UACZC,EAAa,KAAK,GAAGD,EAAU,QAAW,iBAAiB,EAGzDA,EAAU,aACZC,EAAa,KAAK,GAAGD,EAAU,WAAc,WAAW,EAGnDC,EAAa,KAAK,IAAI,CAC/B,EAGMC,EAA4BtI,EAAgB,SAAW8G,EAG7Dd,OAAAA,EAAAA,UAAU,IAAM,CACVQ,GACM,QAAA,IAAI,oDAAoDvH,CAAM,GAAI,CACxE,gBAAiBe,EAAgB,OACjC,eAAA4G,EACA,eAAAQ,CAAA,CACD,CACH,EACC,CAACZ,EAAoBvH,EAAQe,EAAgB,OAAQ4G,EAAgBQ,CAAc,CAAC,EAGrFmB,EAAA,KAAC,MAAA,CACC,IAAK9B,EACL,UAAW,kCAAkCsB,EAAA,CAAmB,GAChE,4BAA2B/H,EAAgB,OAC3C,yBAAwBwG,EACxB,uBAAsBI,EACtB,eAAcQ,EACd,sBAAqBJ,EACrB,MAAO,CACL,SAAU,UACV,UAAW,QACX,SAAU,WACV,WAAY,UACZ,QAAS,QACT,QAAS,CACX,EAGC,SAAA,CAAAhH,EAAgB,OAAS,GACxBuI,EAAA,KAAC,MAAA,CACC,UAAW,uCAAuC/B,EAAqB,SAAW,EAAE,GACpF,MAAO2B,EAA6B,EAEpC,SAAA,CAAAK,EAAA,IAAC,OAAK,CAAA,UAAU,uBAAwB,SAAAxI,EAAgB,OAAO,EAC9DsI,GACEC,EAAA,KAAA,OAAK,CAAA,UAAU,kCACb,SAAA,CAAgBvI,EAAA,OAAS8G,EAAsB,IAAM,GACrD9G,EAAgB,OAAS8G,CAAA,CAC5B,CAAA,CAAA,CAAA,CAEJ,EAIF0B,EAAA,IAAC,MAAA,CACC,IAAK7B,EACL,UAAU,+BACV,MAAO,CACL,SAAU,WACV,WAAY,UACZ,QAAS,QACT,QAAS,EACT,UAAW,OACb,EAEC,aAAkB,EAChB6B,MAAA,MAAI,CAAA,UAAU,wBAAwB,MAAO,CAAE,QAAS,OAAQ,UAAW,UAC1E,eAAC,IAAE,CAAA,SAAA,yBAAsB,EAC3B,EAEAjC,CAAA,CAEJ,EAGC,EAAA,CAmBC,CAEJ,CAEJ"}