{"version":3,"file":"node-view-XdiLjT_l.js","sources":["../../src/store/hooks.ts","../../src/components/Constellation/NodesInstanced.tsx","../../src/components/Constellation/ConnectionsBatched.tsx"],"sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\r\nimport type { AppDispatch } from './index';\r\nimport type { RootState } from './types';\r\n\r\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\r\nexport const useAppDispatch: () => AppDispatch = useDispatch;\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n","import { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  nodeHovered,\r\n  nodeUnhovered,\r\n  selectHoveredNodeId,\r\n  selectSelectedNodeId,\r\n  nodeSelected,\r\n  setViewMode,\r\n  // Removed incorrect import\r\n} from '../../store/slices/interfaceSlice';\r\nimport { navigateToNode } from '../../store/slices/readerSlice';\r\nimport { visitNode } from '../../store/slices/nodesSlice';\r\nimport { AppDispatch } from '../../store';\r\nimport { ConstellationNode, NodePositions } from '../../types';\r\nimport { forwardRef, useMemo, useRef, useState } from 'react';\r\nimport { Color, InstancedMesh, ShaderMaterial } from 'three';\r\nimport * as THREE from 'three';\r\nimport { useFrame, useThree } from '@react-three/fiber';\r\nimport type { ThreeEvent } from '@react-three/fiber';\r\nimport { Text } from '@react-three/drei';\r\n\r\n\r\n// Circuit pattern vertex shader\r\nconst circuitVertexShader = `\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\n// Circuit pattern fragment shader\r\nconst circuitFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  \r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  // Simple hash function\r\n  float hash(vec2 p) {\r\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\r\n  }\r\n  \r\n  void main() {\r\n    // Basic circuit pattern\r\n    vec2 gridPos = floor(vPosition.xy * 10.0);\r\n    float circuit = hash(gridPos) > 0.7 ? 1.0 : 0.0;\r\n    \r\n    // Circuit lines\r\n    vec2 grid = fract(vPosition.xy * 10.0);\r\n    float line = smoothstep(0.95, 0.98, max(grid.x, grid.y));\r\n    \r\n    // Flowing effect on circuit lines\r\n    float flow = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Combine effects\r\n    vec3 finalColor = color * (0.5 + 0.5 * circuit + line * flow);\r\n    \r\n    // Add rim lighting\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    finalColor += color * rim * 0.5;\r\n    \r\n    gl_FragColor = vec4(finalColor, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field vertex shader for hover effect\r\nconst forceFieldVertexShader = `\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    \r\n    // Add subtle pulsating effect\r\n    float pulse = sin(time * 2.0) * 0.05 + 1.05;\r\n    vec3 newPosition = position * pulse;\r\n    \r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field fragment shader for hover effect\r\nconst forceFieldFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    // Create flowing wave pattern\r\n    float wave = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Rim effect for sphere edge glow\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    \r\n    // Transparency based on rim and wave pattern\r\n    float alpha = rim * 0.7 * wave;\r\n    \r\n    // Final color with slight pulsation\r\n    float pulse = sin(time * 3.0) * 0.2 + 0.8;\r\n    vec3 finalColor = color * pulse * (0.5 + wave * 0.5);\r\n    \r\n    gl_FragColor = vec4(finalColor, alpha);\r\n  }\r\n`;\r\n\r\ninterface NodesInstancedProps {\r\n  nodes: ConstellationNode[];\r\n  nodePositions: NodePositions;\r\n  connections: { start: string; end: string }[];\r\n  overrideSelectedNodeId?: string;\r\n  onNodeClick?: (nodeId: string) => void;\r\n  clickableNodeIds?: string[];\r\n  isMinimap?: boolean; // Flag to indicate if this is used in the minimap\r\n isInitialChoicePhase: boolean;\r\n triumvirateActive: boolean;\r\n triumvirateNodes: string[];\r\n positionSynchronizer: {\r\n   updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n   getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n}\r\n\r\n// Define base colors for each triad - match exact character names from nodesSlice.ts\r\nconst triadColors = {\r\n  LastHuman: new Color('#ff6666'), // Reddish\r\n  Archaeologist: new Color('#66ff66'), // Greenish\r\n  Algorithm: new Color('#6666ff'), // Bluish\r\n};\r\n\r\n// Create a more permissive lookup that doesn't rely on exact matching\r\n// Helper to get color for node based on character with proper type safety\r\nconst getNodeColor = (character: string | undefined): Color => {\r\n  if (!character) return new Color('#ffffff');\r\n  \r\n  // Direct lookup with type safety\r\n  if (character === 'LastHuman') return triadColors.LastHuman;\r\n  if (character === 'Archaeologist') return triadColors.Archaeologist;\r\n  if (character === 'Algorithm') return triadColors.Algorithm;\r\n  \r\n  // Case-insensitive lookup as fallback\r\n  const lowerChar = character.toLowerCase();\r\n  if (lowerChar.includes('human')) return triadColors.LastHuman;\r\n  if (lowerChar.includes('arch')) return triadColors.Archaeologist;\r\n  if (lowerChar.includes('algo')) return triadColors.Algorithm;\r\n  \r\n  // Default\r\n  console.warn(`Unknown character type: ${character}, using default color`);\r\n  return new Color('#ffffff');\r\n};\r\n\r\n// Helper functions to reduce cognitive complexity\r\n\r\n// Check if a node is a designated starting node\r\nconst isDesignatedStartingNode = (node: ConstellationNode): boolean => {\r\n  return node.contentSource === 'arch-discovery.md' ||\r\n         node.contentSource === 'algo-awakening.md' ||\r\n         node.contentSource === 'human-discovery.md';\r\n};\r\n\r\n// Get label text for designated starting nodes\r\nconst getStartingNodeLabel = (node: ConstellationNode): string => {\r\n  if (node.contentSource === 'arch-discovery.md') return 'The Archaeologist';\r\n  if (node.contentSource === 'algo-awakening.md') return 'The Algorithm';\r\n  if (node.contentSource === 'human-discovery.md') return 'The Last Human';\r\n  return '';\r\n};\r\n\r\n// Get triumvirate text for nodes\r\nconst getTriumvirateText = (nodeId: string): string => {\r\n  if (nodeId === 'arch-discovery') return 'Discovery';\r\n  if (nodeId === 'algo-awakening') return 'Awakening';\r\n  if (nodeId === 'human-discovery') return 'Choice';\r\n  return '';\r\n};\r\n\r\n// Determine if a node is clickable based on current state\r\nconst isNodeClickable = (\r\n  node: ConstellationNode,\r\n  isDesignatedStarting: boolean,\r\n  triumvirateActive: boolean,\r\n  triumvirateNodeSet: Set<string>,\r\n  isInitialChoicePhase: boolean,\r\n  connections: { start: string; end: string }[],\r\n  onNodeClick?: (nodeId: string) => void,\r\n  clickableNodeIds?: string[],\r\n  selectedNodeId?: string | null\r\n): boolean => {\r\n  if (triumvirateActive) {\r\n    return triumvirateNodeSet.has(node.id);\r\n  }\r\n  \r\n  if (isInitialChoicePhase) {\r\n    return isDesignatedStarting;\r\n  }\r\n  \r\n  if (onNodeClick) {\r\n    return !clickableNodeIds || clickableNodeIds.includes(node.id);\r\n  }\r\n  \r\n  if (selectedNodeId === null) {\r\n    return true;\r\n  }\r\n  \r\n  return connections.some(\r\n    (c) => (c.start === selectedNodeId && c.end === node.id) ||\r\n           (c.start === node.id && c.end === selectedNodeId)\r\n  );\r\n};\r\n\r\n// Handle node navigation actions\r\nconst handleNodeNavigation = (\r\n  dispatch: AppDispatch,\r\n  node: ConstellationNode\r\n): void => {\r\n  dispatch(nodeSelected(node.id));\r\n  dispatch(visitNode(node.id));\r\n  dispatch(setViewMode('reading'));\r\n  dispatch(navigateToNode({\r\n    nodeId: node.id,\r\n    character: node.character,\r\n    temporalValue: node.temporalValue,\r\n    attractors: node.strangeAttractors,\r\n  }));\r\n};\r\n\r\n// Update node scaling with pulsing effect\r\nconst updateNodeScaling = (\r\n  nodeMesh: THREE.Mesh,\r\n  isPulsingNode: boolean,\r\n  time: number,\r\n  isMinimap?: boolean\r\n): void => {\r\n  if (isPulsingNode) {\r\n    const pulseSpeed = 3;\r\n    const pulseAmount = 0.15;\r\n    const baseScale = 1.0;\r\n    const targetScale = baseScale + Math.sin(time * pulseSpeed) * pulseAmount;\r\n    nodeMesh.scale.set(targetScale, targetScale, targetScale);\r\n  } else {\r\n    const baseScale = isMinimap ? 0.5 : 1.0;\r\n    if (nodeMesh.scale.x !== baseScale || nodeMesh.scale.y !== baseScale || nodeMesh.scale.z !== baseScale) {\r\n      nodeMesh.scale.set(baseScale, baseScale, baseScale);\r\n    }\r\n  }\r\n};\r\n\r\n// Update material time uniforms\r\nconst updateMaterialUniforms = (\r\n  materials: ShaderMaterial[],\r\n  time: number\r\n): void => {\r\n  materials.forEach(material => {\r\n    if (material?.uniforms?.time) {\r\n      material.uniforms.time.value = time;\r\n    }\r\n  });\r\n};\r\n\r\n// Update text billboard behavior\r\nconst updateTextBillboards = (\r\n  textRefs: THREE.Object3D[],\r\n  camera: THREE.Camera\r\n): void => {\r\n  textRefs.forEach(text => {\r\n    if (text && text.visible) {\r\n      text.lookAt(camera.position);\r\n    }\r\n  });\r\n};\r\n\r\n// Helper function to handle node hover events\r\nconst handleNodeHover = (\r\n  nodeId: string,\r\n  isClickable: boolean,\r\n  clientX: number,\r\n  clientY: number\r\n): void => {\r\n  const nodeHoverEvent = new CustomEvent('node-hover', {\r\n    detail: {\r\n      position: {\r\n        x: clientX,\r\n        y: clientY - 40\r\n      },\r\n      nodeId,\r\n      isClickable\r\n    }\r\n  });\r\n  window.dispatchEvent(nodeHoverEvent);\r\n};\r\n\r\n// Helper function to handle node unhover events\r\nconst handleNodeUnhover = (): void => {\r\n  const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n  window.dispatchEvent(nodeUnhoverEvent);\r\n};\r\n\r\nexport const NodesInstanced = forwardRef<InstancedMesh, NodesInstancedProps>((props, ref) => {\r\n  const {\r\n    nodes,\r\n    nodePositions,\r\n    connections,\r\n    overrideSelectedNodeId,\r\n    onNodeClick,\r\n    clickableNodeIds,\r\n    isInitialChoicePhase,\r\n    positionSynchronizer,\r\n    triumvirateActive,\r\n    triumvirateNodes,\r\n  } = props;\r\n  const dispatch = useDispatch<AppDispatch>();\r\n  const { camera } = useThree();\r\n  \r\n  const hoveredNodeId = useSelector(selectHoveredNodeId);\r\n  const reduxSelectedNodeId = useSelector(selectSelectedNodeId);\r\n  const selectedNodeId = overrideSelectedNodeId ?? reduxSelectedNodeId;\r\n\r\n  const triumvirateNodeSet = useMemo(() => new Set(triumvirateNodes), [triumvirateNodes]);\r\n  const triumvirateColorMap = useMemo(() => ({\r\n    'arch-discovery': new Color('#66ff66'), // Green\r\n    'algo-awakening': new Color('#6666ff'), // Blue\r\n    'human-discovery': new Color('#ff6666'), // Red\r\n  }), []);  const connectedNodeIds = useMemo(() => {\r\n    if (isInitialChoicePhase || triumvirateActive) return triumvirateNodeSet;\r\n    if (!selectedNodeId) return new Set<string>();\r\n    const connected = new Set<string>();\r\n    connections.forEach((c) => {\r\n      if (c.start === selectedNodeId) connected.add(c.end);\r\n      if (c.end === selectedNodeId) connected.add(c.start);\r\n    });\r\n    return connected;\r\n  }, [selectedNodeId, connections, triumvirateActive, triumvirateNodeSet, isInitialChoicePhase]);\r\n\r\n  // State to track current node positions for positioning groups\r\n  const [groupPositions, setGroupPositions] = useState<{[key: string]: [number, number, number]}>({});\r\n\r\n  // Create refs for accessing objects in the scene\r\n  const materialRefs = useRef<ShaderMaterial[]>([]);\r\n  const forceFieldMaterialRefs = useRef<ShaderMaterial[]>([]);\r\n  const nodeMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  const forceFieldMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  const labelTextRefs = useRef<THREE.Object3D[]>([]);\r\n  const triumvirateTextRefs = useRef<THREE.Object3D[]>([]);\r\n  \r\n  // Store original positions for the noise animation\r\n  const originalPositions = useRef<{[key: string]: [number, number, number]}>({});\r\n  \r\n  // Initialize original positions\r\n  useMemo(() => {\r\n    nodes.forEach(node => {\r\n      const position = nodePositions[node.id] || [0, 0, 0];\r\n      originalPositions.current[node.id] = [...position];\r\n    });\r\n  }, [nodes, nodePositions]);\r\n  \r\n  \r\n  // Update shader time uniform and apply noise movement with optimized LOD\r\n  // Frame counter for throttling updates\r\n  const frameCount = useRef(0);\r\n  const lastUpdatePositionsTime = useRef(0);\r\n  const lastUpdateMaterialsTime = useRef(0);\r\n    // Separate function to handle material updates\r\n  const handleMaterialUpdates = (time: number): void => {\r\n    const shouldUpdateMaterials = time - lastUpdateMaterialsTime.current > 0.05; // 50ms\r\n    if (!shouldUpdateMaterials) return;\r\n\r\n    lastUpdateMaterialsTime.current = time;\r\n    \r\n    // Update time uniforms on important materials only\r\n    const importantMaterials = materialRefs.current.filter((_, i) => {\r\n      const node = nodes[i];\r\n      return node && (\r\n        node.id === selectedNodeId ||\r\n        node.id === hoveredNodeId ||\r\n        connections.some(c => c.start === node.id || c.end === node.id)\r\n      );\r\n    });\r\n    \r\n    updateMaterialUniforms(importantMaterials, time);\r\n    \r\n    // Update force field materials only for selected/hovered nodes\r\n    const importantForceFields = forceFieldMaterialRefs.current.filter((_, i) => {\r\n      const node = nodes[i];\r\n      return node && (node.id === selectedNodeId || node.id === hoveredNodeId);\r\n    });\r\n    \r\n    updateMaterialUniforms(importantForceFields, time);\r\n  };\r\n  // Separate function to handle node position and scale updates\r\n  const handleNodeUpdates = (time: number): void => {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i];\r\n      const nodeMesh = nodeMeshRefs.current[i] as THREE.Mesh;\r\n      \r\n      if (!nodeMesh || !originalPositions.current[node.id]) {\r\n        continue;\r\n      }\r\n\r\n      // Determine if this node should pulse\r\n      const shouldPulse = isInitialChoicePhase && \r\n                         !props.isMinimap && \r\n                         isDesignatedStartingNode(node);\r\n\r\n      updateNodeScaling(nodeMesh, shouldPulse, time, props.isMinimap);\r\n      \r\n      const isImportantNode = node.id === selectedNodeId ||\r\n                             node.id === hoveredNodeId ||\r\n                             connectedNodeIds.has(node.id);\r\n      \r\n      // Always show the node\r\n      nodeMesh.visible = true;\r\n      nodeMesh.position.set(0, 0, 0);\r\n      \r\n      // Show force field only for important nodes\r\n      const forceMesh = forceFieldMeshRefs.current[i];\r\n      if (forceMesh) {\r\n        forceMesh.visible = isImportantNode;\r\n        if (isImportantNode) {\r\n          forceMesh.position.set(0, 0, 0);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Enhanced optimization: Using variable update rates based on priority\r\n  useFrame((state): void => {\r\n    const time = state.clock.elapsedTime;\r\n    frameCount.current += 1;\r\n    \r\n    // Get synchronized positions from the position synchronizer\r\n    const currentPositions = positionSynchronizer.updatePositions(time, props.isMinimap);\r\n    \r\n    handleMaterialUpdates(time);\r\n    \r\n    // SYNC FIX: Ensure we update positions on the same frames as ConnectionsBatched\r\n    // This is critical for keeping nodes and connections aligned\r\n    const timeSinceLastPositionUpdate = time - lastUpdatePositionsTime.current;\r\n    // CRITICAL SYNC FIX: Use same update interval as ConnectionsBatched\r\n    const UPDATE_INTERVAL = 0.15; // 150ms in seconds\r\n    const shouldUpdatePositions = timeSinceLastPositionUpdate >= UPDATE_INTERVAL;\r\n      if (shouldUpdatePositions) {\r\n      lastUpdatePositionsTime.current = time;\r\n      \r\n      handleNodeUpdates(time);\r\n      \r\n      // Update text billboard behavior - make text always face camera      updateTextBillboards(labelTextRefs.current, camera);\r\n      updateTextBillboards(triumvirateTextRefs.current, camera);\r\n      \r\n      // Update group positions for next render\r\n      setGroupPositions({ ...currentPositions });\r\n    }\r\n  });\r\n  \r\n  // Create a dummy instanced mesh to maintain API compatibility with ref\r\n  // while still using individual meshes for better control\r\n  return (\r\n    <group>\r\n      {/* This invisible instanced mesh is just for ref compatibility */}\r\n      {ref && (\r\n        <instancedMesh\r\n          ref={ref}\r\n          args={[\r\n            new THREE.BufferGeometry(),\r\n            new THREE.MeshBasicMaterial(),\r\n            0\r\n          ]}\r\n          visible={false}\r\n        />\r\n      )}\r\n      {nodes.map((node, index) => {\r\n        const isSelected = selectedNodeId === node.id;\r\n        const isConnected = connectedNodeIds.has(node.id);\r\n        const isHovered = hoveredNodeId === node.id;        const isDesignatedStarting = isDesignatedStartingNode(node);\r\n        const labelText = isInitialChoicePhase ? getStartingNodeLabel(node) : '';\r\n        const triumvirateText = triumvirateActive && triumvirateNodes.includes(node.id) ? getTriumvirateText(node.id) : '';\r\n          // Calculate node color using helper function\r\n        const nodeColor = calculateNodeColor(\r\n          node,\r\n          isSelected,\r\n          isConnected,\r\n          isHovered,\r\n          isInitialChoicePhase,\r\n          triumvirateActive,\r\n          triumvirateNodeSet,\r\n          triumvirateColorMap\r\n        );// The main node group's position is determined by synchronized positions,\r\n        // and individual elements within this group (like the sphere and text) will be positioned relatively.\r\n        const groupPosition = groupPositions[node.id] || originalPositions.current[node.id] || [0, 0, 0];\r\n        \r\n        return (\r\n          <group\r\n            key={node.id}\r\n            position={groupPosition} // Position group at the node's current position\r\n            userData={{ nodeId: node.id }} // Add nodeId to userData for connection positioning\r\n          >\r\n            {/* Text label for node - only for designated starting nodes in initial choice phase */}\r\n            {isDesignatedStarting && isInitialChoicePhase && !triumvirateActive && !props.isMinimap && labelText && (\r\n              <Text\r\n                ref={(text) => {\r\n                  if (text) {\r\n                    labelTextRefs.current[index] = text;\r\n                  }\r\n                }}\r\n                position={[0, 2.2, 0]} // Position higher above the node sphere\r\n                fontSize={0.4} // Larger font size for better visibility\r\n                color=\"white\"\r\n                anchorX=\"center\"\r\n                anchorY=\"middle\"\r\n                outlineWidth={0.03}\r\n                outlineColor=\"#000000\"\r\n                material-depthTest={false} // Ensures text is visible\r\n                material-transparent={true}\r\n                fontWeight=\"bold\"\r\n              >\r\n                {labelText}\r\n              </Text>\r\n            )}\r\n\r\n            {/* Triumvirate text labels */}\r\n            {triumvirateActive && !props.isMinimap && triumvirateText && (\r\n              <Text\r\n                ref={(text) => {\r\n                  if (text) {\r\n                    triumvirateTextRefs.current[index] = text;\r\n                  }\r\n                }}\r\n                position={[0, 2.2, 0]} // Position above the node sphere (relative to the group)\r\n                fontSize={0.6} // Larger font size for better visibility\r\n                color=\"white\"\r\n                anchorX=\"center\"\r\n                anchorY=\"middle\"\r\n                outlineWidth={0.05}\r\n                outlineColor=\"#000000\"\r\n                material-depthTest={false} // Ensures text is visible\r\n                material-transparent={true}\r\n                fontWeight=\"bold\"\r\n              >\r\n                {triumvirateText}\r\n              </Text>\r\n            )}\r\n\r\n            {/* Force field effect (only visible when hovered or selected) */}\r\n            {(isHovered || isSelected) && (\r\n              <mesh\r\n                ref={(mesh) => {\r\n                  if (mesh) {\r\n                    forceFieldMeshRefs.current[index] = mesh;\r\n                  }\r\n                }}\r\n                // Position is now relative to the parent group, so [0,0,0] for the force field center\r\n                position={[0, 0, 0]}>\r\n                <sphereGeometry args={[1.4, 16, 16]} />\r\n                <shaderMaterial\r\n                  ref={(material) => {\r\n                    if (material) {\r\n                      forceFieldMaterialRefs.current[index] = material;\r\n                    }\r\n                  }}\r\n                  vertexShader={forceFieldVertexShader}\r\n                  fragmentShader={forceFieldFragmentShader}\r\n                  uniforms={{\r\n                    color: { value: nodeColor },\r\n                    time: { value: 0 }\r\n                  }}\r\n                  transparent={true}\r\n                  depthWrite={false}\r\n                />\r\n              </mesh>\r\n            )}\r\n            \r\n            {/* Main node mesh */}\r\n            <mesh\r\n              ref={(mesh) => {\r\n                if (mesh) {\r\n                  nodeMeshRefs.current[index] = mesh;\r\n                }\r\n              }}\r\n              // Position is now relative to the parent group, so [0,0,0] for the node sphere center\r\n              position={[0, 0, 0]}              onClick={createNodeClickHandler(\r\n                node,\r\n                isDesignatedStarting,\r\n                isInitialChoicePhase,\r\n                dispatch,\r\n                onNodeClick,\r\n                clickableNodeIds,\r\n                selectedNodeId,\r\n                connections\r\n              )}              onPointerOver={createNodeHoverHandler(\r\n                node,\r\n                isDesignatedStarting,\r\n                props.isMinimap || false,\r\n                triumvirateActive,\r\n                triumvirateNodeSet,\r\n                isInitialChoicePhase,\r\n                dispatch,\r\n                hoveredNodeId,\r\n                onNodeClick,\r\n                clickableNodeIds,\r\n                selectedNodeId,\r\n                connections\r\n              )}              onPointerOut={(e: ThreeEvent<PointerEvent>) => {\r\n                if (props.isMinimap) return;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                handleNodeUnhover();\r\n              }}\r\n              onPointerLeave={(e: ThreeEvent<PointerEvent>) => {\r\n                if (props.isMinimap) return;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                handleNodeUnhover();\r\n              }}\r\n            >\r\n              {/* Use lower poly geometry for distant nodes */}\r\n              {/* Performance optimization: Use lower poly geometry for distant nodes */}\r\n              {!isSelected && !isHovered ? (\r\n                <octahedronGeometry args={[1.0, 0]} /> // Lower poly for distant nodes - doubled size\r\n              ) : (\r\n                <sphereGeometry args={[1.0, 8, 8]} /> // Higher detail for selected/hovered - doubled size\r\n              )}\r\n              <shaderMaterial\r\n                ref={(material) => {\r\n                  if (material) {\r\n                    // Store reference to this material\r\n                    materialRefs.current[index] = material;\r\n                  }\r\n                }}\r\n                vertexShader={circuitVertexShader}\r\n                fragmentShader={circuitFragmentShader}\r\n                uniforms={{\r\n                  color: { value: nodeColor },\r\n                  time: { value: 0 }\r\n                }}\r\n                transparent={true}\r\n                depthWrite={false}\r\n              />\r\n            </mesh>\r\n          </group>\r\n        );\r\n      })}\r\n      \r\n      {/* Performance display removed */}\r\n    </group>\r\n  );\r\n});\r\n\r\n// Helper function to calculate node color based on state\r\nconst calculateNodeColor = (\r\n  node: ConstellationNode,\r\n  isSelected: boolean,\r\n  isConnected: boolean,\r\n  isHovered: boolean,\r\n  isInitialChoicePhase: boolean,\r\n  triumvirateActive: boolean,\r\n  triumvirateNodeSet: Set<string>,\r\n  triumvirateColorMap: { [key: string]: Color }\r\n): Color => {\r\n  const nodeColor = getNodeColor(node.character).clone();\r\n  \r\n  if (isInitialChoicePhase) {\r\n    if (triumvirateNodeSet.has(node.id)) {\r\n      const color = triumvirateColorMap[node.id as keyof typeof triumvirateColorMap];\r\n      if (color) {\r\n        nodeColor.set(color);\r\n      }\r\n    } else {\r\n      nodeColor.multiplyScalar(0.2); // Dim non-triumvirate nodes\r\n    }\r\n  } else if (triumvirateActive) {\r\n    if (!triumvirateNodeSet.has(node.id)) {\r\n      nodeColor.multiplyScalar(0.2); // Dim non-triumvirate nodes\r\n    }\r\n  } else if (isSelected) {\r\n    nodeColor.multiplyScalar(1.5); // Lighter shade\r\n  } else if (isConnected) {\r\n    nodeColor.multiplyScalar(0.5); // Darker shade\r\n  } else if (isHovered) {\r\n    nodeColor.multiplyScalar(1.2); // Slightly lighter for hover\r\n  }\r\n  \r\n  return nodeColor;\r\n};\r\n\r\n// Helper function to create onClick handler\r\nconst createNodeClickHandler = (\r\n  node: ConstellationNode,\r\n  isDesignatedStarting: boolean,\r\n  isInitialChoicePhase: boolean,\r\n  dispatch: AppDispatch,\r\n  onNodeClick?: (nodeId: string) => void,\r\n  clickableNodeIds?: string[],\r\n  selectedNodeId?: string | null,\r\n  connections?: { start: string; end: string }[]\r\n) => (e: ThreeEvent<MouseEvent>) => {\r\n  if (e.stopPropagation) e.stopPropagation();\r\n\r\n  // Emit custom event to hide tooltip when a node is clicked\r\n  handleNodeUnhover();\r\n\r\n  if (isInitialChoicePhase) {\r\n    if (isDesignatedStarting) {\r\n      try {\r\n        handleNodeNavigation(dispatch, node);\r\n      } catch (error) {\r\n        console.error('Navigation error:', error);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n  \r\n  // Normal click logic (outside initial choice phase)\r\n  if (onNodeClick) {\r\n    if (clickableNodeIds && !clickableNodeIds.includes(node.id)) {\r\n      return;\r\n    }\r\n    onNodeClick(node.id);\r\n  } else {\r\n    if (selectedNodeId === null) {\r\n      handleNodeNavigation(dispatch, node);\r\n    } else if (connections) {\r\n      const isConnectedToCurrentSelected = connections.some(\r\n        (c) =>\r\n          (c.start === selectedNodeId && c.end === node.id) ||\r\n          (c.start === node.id && c.end === selectedNodeId)\r\n      );\r\n      if (isConnectedToCurrentSelected) {\r\n        handleNodeNavigation(dispatch, node);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Helper function to create onPointerOver handler\r\nconst createNodeHoverHandler = (\r\n  node: ConstellationNode,\r\n  isDesignatedStarting: boolean,\r\n  isMinimap: boolean,\r\n  triumvirateActive: boolean,\r\n  triumvirateNodeSet: Set<string>,\r\n  isInitialChoicePhase: boolean,\r\n  dispatch: AppDispatch,\r\n  hoveredNodeId?: string | null,\r\n  onNodeClick?: (nodeId: string) => void,\r\n  clickableNodeIds?: string[],  selectedNodeId?: string | null,\r\n  connections?: { start: string; end: string }[]\r\n) => (e: ThreeEvent<PointerEvent>) => {\r\n  if (isMinimap) return;\r\n  if (e.stopPropagation) e.stopPropagation();\r\n  \r\n  if (node.id !== hoveredNodeId) {\r\n    dispatch(nodeHovered(node.id));\r\n    \r\n    const isClickable = isNodeClickable(\r\n      node,\r\n      isDesignatedStarting,\r\n      triumvirateActive,\r\n      triumvirateNodeSet,\r\n      isInitialChoicePhase,\r\n      connections || [],\r\n      onNodeClick,\r\n      clickableNodeIds,\r\n      selectedNodeId\r\n    );\r\n    \r\n    handleNodeHover(node.id, isClickable, e.clientX, e.clientY);\r\n  }\r\n};","import React, { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport { Connection, NodePositions } from '../../types';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\ninterface ConnectionsBatchedProps {\r\n  connections: Connection[];\r\n  nodePositions: NodePositions;\r\n  selectedNodeId?: string | null;\r\n  hoveredNodeId?: string | null;\r\n  positionSynchronizer: {\r\n    updatePositions: (time: number, isMinimap?: boolean) => { [key: string]: [number, number, number] };\r\n    getCurrentPositions: () => { [key: string]: [number, number, number] };\r\n  };\r\n  isMinimap?: boolean;\r\n  triumvirateActive?: boolean;\r\n  triumvirateNodes?: string[];\r\n}\r\n\r\n// --- Reusable utility objects to prevent reallocation in the render loop ---\r\nconst baseColor = new THREE.Color();\r\nconst pulseColor = new THREE.Color();\r\n\r\nexport const ConnectionsBatched: React.FC<ConnectionsBatchedProps> = (props) => {\r\n    const { connections, nodePositions, selectedNodeId, hoveredNodeId, positionSynchronizer, isMinimap } = props;\r\n\r\n    const lineSegmentsRef = useRef<THREE.LineSegments>(null!);\r\n    const geometryRef = useRef<THREE.BufferGeometry>(null!);\r\n\r\n    // This effect sets up the geometry and its attributes once.\r\n    useEffect(() => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const positions = new Float32Array(connections.length * 2 * 3);\r\n        const colors = new Float32Array(connections.length * 2 * 3);\r\n\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        \r\n        if (lineSegmentsRef.current) {\r\n            lineSegmentsRef.current.geometry = geometry;\r\n        }\r\n        geometryRef.current = geometry;\r\n\r\n        return () => {\r\n            geometry.dispose();\r\n        }\r\n    }, [connections.length]);\r\n\r\n    useFrame((state) => {\r\n        if (!geometryRef.current) return;\r\n\r\n        const positionAttribute = geometryRef.current.attributes.position as THREE.BufferAttribute;\r\n        const colorAttribute = geometryRef.current.attributes.color as THREE.BufferAttribute;\r\n        \r\n        // Use dynamic positions for the main view, and static for the minimap\r\n        const currentPositions = isMinimap ? nodePositions : positionSynchronizer.updatePositions(state.clock.elapsedTime);\r\n\r\n        for (let i = 0; i < connections.length; i++) {\r\n            const connection = connections[i];\r\n            const startPos = currentPositions[connection.source];\r\n            const endPos = currentPositions[connection.target];\r\n\r\n            if (startPos && endPos) {\r\n                positionAttribute.setXYZ(i * 2, startPos[0], startPos[1], startPos[2]);\r\n                positionAttribute.setXYZ(i * 2 + 1, endPos[0], endPos[1], endPos[2]);\r\n            }\r\n\r\n            const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n            const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n            const isAvailable = !isSelected && !isHovered && selectedNodeId && (connection.source === selectedNodeId || connection.target === selectedNodeId);\r\n\r\n            let finalColor;\r\n\r\n            if (isSelected) {\r\n                finalColor = baseColor.set(0x00bfff);\r\n            } else if (isHovered) {\r\n                finalColor = baseColor.set(0x88ccff);\r\n            } else if (isAvailable) {\r\n                const pulse = 0.5 + 0.5 * Math.sin(state.clock.elapsedTime * 5);\r\n                finalColor = pulseColor.set(0x4488ff).lerp(baseColor.set(0xffffff), pulse);\r\n            } else {\r\n                finalColor = baseColor.set(0xffffff); // Default to white\r\n            }\r\n            \r\n            colorAttribute.setXYZ(i * 2, finalColor.r, finalColor.g, finalColor.b);\r\n            colorAttribute.setXYZ(i * 2 + 1, finalColor.r, finalColor.g, finalColor.b);\r\n        }\r\n\r\n        positionAttribute.needsUpdate = true;\r\n        // Always update colors for simplicity, as the available check is complex\r\n        colorAttribute.needsUpdate = true;\r\n    });\r\n\r\n    return (\r\n        <lineSegments ref={lineSegmentsRef}>\r\n            {/* The geometry is created and managed in the useEffect/useFrame hooks */}\r\n            <lineBasicMaterial vertexColors={true} toneMapped={false} fog={false} />\r\n        </lineSegments>\r\n    );\r\n};\r\n"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","circuitVertexShader","circuitFragmentShader","forceFieldVertexShader","forceFieldFragmentShader","triadColors","Color","getNodeColor","character","lowerChar","isDesignatedStartingNode","node","getStartingNodeLabel","getTriumvirateText","nodeId","isNodeClickable","isDesignatedStarting","triumvirateActive","triumvirateNodeSet","isInitialChoicePhase","connections","onNodeClick","clickableNodeIds","selectedNodeId","handleNodeNavigation","dispatch","nodeSelected","visitNode","setViewMode","navigateToNode","updateNodeScaling","nodeMesh","isPulsingNode","time","isMinimap","targetScale","baseScale","updateMaterialUniforms","materials","material","_a","updateTextBillboards","textRefs","camera","text","handleNodeHover","isClickable","clientX","clientY","nodeHoverEvent","handleNodeUnhover","nodeUnhoverEvent","NodesInstanced","forwardRef","props","ref","nodes","nodePositions","overrideSelectedNodeId","positionSynchronizer","triumvirateNodes","useThree","hoveredNodeId","selectHoveredNodeId","reduxSelectedNodeId","selectSelectedNodeId","useMemo","triumvirateColorMap","connectedNodeIds","connected","c","groupPositions","setGroupPositions","useState","materialRefs","useRef","forceFieldMaterialRefs","nodeMeshRefs","forceFieldMeshRefs","labelTextRefs","triumvirateTextRefs","originalPositions","position","frameCount","lastUpdatePositionsTime","lastUpdateMaterialsTime","handleMaterialUpdates","importantMaterials","_","i","importantForceFields","handleNodeUpdates","shouldPulse","isImportantNode","forceMesh","useFrame","state","currentPositions","jsx","THREE.BufferGeometry","THREE.MeshBasicMaterial","index","isSelected","isConnected","isHovered","labelText","triumvirateText","nodeColor","calculateNodeColor","groupPosition","jsxs","Text","mesh","createNodeClickHandler","createNodeHoverHandler","e","nodeUnhovered","color","error","nodeHovered","baseColor","THREE.Color","pulseColor","ConnectionsBatched","lineSegmentsRef","geometryRef","useEffect","geometry","positions","colors","THREE.Float32BufferAttribute","positionAttribute","colorAttribute","connection","startPos","endPos","isAvailable","finalColor","pulse"],"mappings":"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"}