{"version":3,"file":"NarramorphRenderer-BHn5tT2_.js","sources":["../../src/components/NodeView/NarramorphRenderer.tsx"],"sourcesContent":["/**\r\n * NarramorphRenderer Component\r\n *\r\n * Renders node content with Narramorph transformations applied.\r\n * This component handles the transformation application logic and visual transitions\r\n * for content transformations based on reader patterns.\r\n *\r\n * Performance optimized with:\r\n * - Lazy loading for content that's not in viewport\r\n * - Memoized transformations\r\n * - Prioritized transformation application\r\n * - Intersection Observer for viewport detection\r\n */\r\n\r\nimport React, { useEffect, useState, useRef, useMemo, memo } from 'react';\r\nimport { useNodeState } from '../../hooks/useNodeState';\r\nimport { TextTransformation } from '../../types';\r\nimport { useSelector } from 'react-redux';\r\nimport { RootState } from '../../store/types';\r\nimport TransformationAnimationContainer from './TransformationAnimationContainer';\r\nimport '../../styles/NarramorphTransformations.css';\r\nimport { transformationService } from '../../services/TransformationService';\r\n// Note: Install these packages if needed\r\n// import { FixedSizeList as List } from 'react-window';\r\n// import AutoSizer from 'react-virtualized-auto-sizer';\r\n\r\ninterface NarramorphRendererProps {\r\n  nodeId?: string; // Optional - if not provided, uses current node\r\n  onVisibilityChange?: (isVisible: boolean) => void; // Callback for visibility changes\r\n}\r\n\r\ninterface PerformanceMetrics {\r\n  renderTime: number;\r\n  transformationsCount: number;\r\n  visibilityChanges: number;\r\n  deferredTransformations: number;\r\n}\r\n\r\n\r\n\r\n// Main NarramorphRenderer component with React.memo for better performance\r\nconst NarramorphRenderer: React.FC<NarramorphRendererProps> = memo(({ nodeId, onVisibilityChange }) => {\r\n  const {\r\n    node,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  } = useNodeState(nodeId);\r\n  \r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const observerRef = useRef<IntersectionObserver | null>(null);\r\n  const [renderKey, setRenderKey] = useState(0);\r\n  const [isVisible, setIsVisible] = useState(true);\r\n  const [webGLError, setWebGLError] = useState<Error | null>(null);\r\n  \r\n  // Performance metrics\r\n  const [metrics, setMetrics] = useState<PerformanceMetrics>({\r\n    renderTime: 0,\r\n    transformationsCount: 0,\r\n    visibilityChanges: 0,\r\n    deferredTransformations: 0\r\n  });\r\n  \r\n  // Track which transformations have been animated already\r\n  const [animatedTransformations, setAnimatedTransformations] = useState<string[]>([]);\r\n  \r\n  // Get reading path from reader state\r\n  const readingPath = useSelector((state: RootState) => state.reader.path);\r\n  \r\n  // Effect to monitor for WebGL context loss errors\r\n  useEffect(() => {\r\n    const handleWebGLError = (event: ErrorEvent) => {\r\n      // Check if this is a WebGL context loss error\r\n      if (event.message &&\r\n         (event.message.includes('WebGL context lost') ||\r\n          event.message.includes('THREE.WebGLRenderer'))) {\r\n        console.error('[NarramorphRenderer] WebGL context loss detected!', event.message);\r\n        setWebGLError(new Error(event.message));\r\n      }\r\n    };\r\n    \r\n    window.addEventListener('error', handleWebGLError);\r\n    \r\n    return () => {\r\n      window.removeEventListener('error', handleWebGLError);\r\n    };\r\n  }, []);\r\n\r\n  // Setup intersection observer for visibility detection with guaranteed initial visibility\r\n  useEffect(() => {\r\n    if (!contentRef.current) {\r\n      console.log('[NarramorphRenderer] Content ref not available yet');\r\n      return;\r\n    }\r\n    \r\n    console.log('[NarramorphRenderer] Setting up visibility observer for node:', node?.id);\r\n    \r\n    // Clean up previous observer\r\n    if (observerRef.current) {\r\n      observerRef.current.disconnect();\r\n    }\r\n    \r\n    // IMPORTANT: Ensure content is initially visible - do this before creating the observer\r\n    // to avoid race conditions\r\n    setIsVisible(true);\r\n    if (onVisibilityChange) {\r\n      console.log('[NarramorphRenderer] Setting initial visibility to visible');\r\n      onVisibilityChange(true);\r\n    }\r\n    \r\n    // Create new observer with more permissive settings\r\n    observerRef.current = new IntersectionObserver(\r\n      (entries) => {\r\n        const isNowVisible = entries[0]?.isIntersecting ?? true; // Default to visible if uncertain\r\n        \r\n        // Log visibility check with element details\r\n        if (contentRef.current) {\r\n          const rect = contentRef.current.getBoundingClientRect();\r\n          const style = window.getComputedStyle(contentRef.current);\r\n          console.log(`[NarramorphRenderer] Visibility check: ${isNowVisible ? 'visible' : 'hidden'}`, {\r\n            dimensions: `${Math.round(rect.width)}x${Math.round(rect.height)}`,\r\n            display: style.display,\r\n            visibility: style.visibility,\r\n            opacity: style.opacity,\r\n            position: style.position\r\n          });\r\n        }\r\n        \r\n        // Only update if visibility truly changed and element actually exists\r\n        if (isVisible !== isNowVisible && contentRef.current) {\r\n          console.log(`[NarramorphRenderer] Visibility changed to: ${isNowVisible ? 'visible' : 'hidden'}`);\r\n          setIsVisible(isNowVisible);\r\n          \r\n          // Call the visibility change callback if provided\r\n          if (onVisibilityChange) {\r\n            onVisibilityChange(isNowVisible);\r\n          }\r\n          \r\n          setMetrics(prev => ({\r\n            ...prev,\r\n            visibilityChanges: prev.visibilityChanges + 1\r\n          }));\r\n          \r\n          // Inform the transformation service about visibility changes\r\n          if (node?.id) {\r\n            transformationService.setContentVisibility(\r\n              node.id,\r\n              isNowVisible,\r\n              // Prioritize currently selected node\r\n              node.id === nodeId ? 2 : 1\r\n            );\r\n          }\r\n          \r\n          // Force a re-render when becoming visible again to ensure content appears\r\n          if (isNowVisible) {\r\n            setRenderKey(prev => prev + 1);\r\n          }\r\n        }\r\n      },\r\n      {\r\n        root: null, // viewport\r\n        rootMargin: '500px', // Very large margin to prevent premature unloading\r\n        threshold: 0.01 // Trigger when even slightly visible\r\n      }\r\n    );\r\n    \r\n    // Start observing\r\n    if (contentRef.current) {\r\n      observerRef.current.observe(contentRef.current);\r\n      console.log('[NarramorphRenderer] Started observing content visibility');\r\n      \r\n      // Force an immediate check of visibility status\r\n      setTimeout(() => {\r\n        if (contentRef.current) {\r\n          const rect = contentRef.current.getBoundingClientRect();\r\n          const style = window.getComputedStyle(contentRef.current);\r\n          console.log('[NarramorphRenderer] Initial visibility check:', {\r\n            visible: isVisible,\r\n            dimensions: `${Math.round(rect.width)}x${Math.round(rect.height)}`,\r\n            display: style.display,\r\n            visibility: style.visibility,\r\n            opacity: style.opacity\r\n          });\r\n        }\r\n      }, 50);\r\n    }\r\n    \r\n    // Cleanup\r\n    return () => {\r\n      console.log('[NarramorphRenderer] Cleaning up visibility observer');\r\n      observerRef.current?.disconnect();\r\n    };\r\n  }, [node?.id, nodeId, onVisibilityChange]);\r\n  \r\n  // Prioritize transformations based on visibility and importance\r\n  const prioritizedTransformations = useMemo(() => {\r\n    if (!appliedTransformations.length) return [];\r\n    \r\n    // If content is visible, apply all transformations\r\n    if (isVisible) {\r\n      return appliedTransformations;\r\n    }\r\n    \r\n    // If not visible, only apply high priority transformations\r\n    const highPriorityTransformations = appliedTransformations.filter(t =>\r\n      t.priority === 'high' || t.applyImmediately === true\r\n    );\r\n    \r\n    setMetrics(prev => ({\r\n      ...prev,\r\n      deferredTransformations: appliedTransformations.length - highPriorityTransformations.length\r\n    }));\r\n    \r\n    return highPriorityTransformations;\r\n  }, [appliedTransformations, isVisible]);\r\n  \r\n  // When transformations occur, trigger animations with sequenced timing\r\n  // Optimized version with debounced and batched updates\r\n  useEffect(() => {\r\n    if (!newlyTransformed || !contentRef.current || !isVisible) {\r\n      return; // Skip if not visible or no new transformations\r\n    }\r\n    \r\n    const startTime = performance.now();\r\n    \r\n    // Force re-render to apply new transformations with animation\r\n    setRenderKey(prev => prev + 1);\r\n    \r\n    // Use requestAnimationFrame to sync with browser rendering cycle\r\n    requestAnimationFrame(() => {\r\n      // Get all elements with transformation classes - use a more efficient selector\r\n      const transformedElements = contentRef.current?.querySelectorAll('[data-transform-type]');\r\n      if (!transformedElements || transformedElements.length === 0) return;\r\n      \r\n      // Calculate which transformations are new\r\n      const transformationKeys = appliedTransformations.map(\r\n        (t: TextTransformation) => `${t.type}-${t.selector}`\r\n      );\r\n      const newTransformations = transformationKeys.filter(\r\n        key => !animatedTransformations.includes(key)\r\n      );\r\n      \r\n      if (newTransformations.length === 0) return;\r\n      \r\n      // Get transformation groups for staggered animations\r\n      const transformGroups: Record<string, Element[]> = {\r\n        'replace': [],\r\n        'fragment': [],\r\n        'expand': [],\r\n        'emphasize': [],\r\n        'metaComment': []\r\n      };\r\n      \r\n      // Group elements by transformation type\r\n      transformedElements.forEach(element => {\r\n        const type = element.getAttribute('data-transform-type');\r\n        if (type && type in transformGroups) {\r\n          transformGroups[type].push(element);\r\n        }\r\n      });\r\n      \r\n      // Apply animation class to new transformations with staggered timing\r\n      // Optimize by using a single setTimeout callback for each batch\r\n      const applyAnimationsWithStagger = (elements: Element[], staggerDelay: number = 50) => {\r\n        const batches: Element[][] = [];\r\n        const batchSize = 5; // Process 5 elements per batch for better performance\r\n        \r\n        // Create batches\r\n        for (let i = 0; i < elements.length; i += batchSize) {\r\n          batches.push(Array.from(elements).slice(i, i + batchSize));\r\n        }\r\n        \r\n        // Process batches with staggered timing\r\n        batches.forEach((batch, batchIndex) => {\r\n          setTimeout(() => {\r\n            batch.forEach(element => {\r\n              const type = element.getAttribute('data-transform-type');\r\n              const text = element.textContent || '';\r\n              \r\n              // Only animate elements that match new transformations\r\n              const matchingTransformation = appliedTransformations.find(t =>\r\n                t.type === type &&\r\n                text.includes(t.selector || '') &&\r\n                newTransformations.includes(`${t.type}-${t.selector}`)\r\n              );\r\n              \r\n              if (matchingTransformation) {\r\n                // Add all classes at once for better performance\r\n                element.classList.add('narramorph-transform-new');\r\n                \r\n                // Add appropriate effect class based on transformation type\r\n                switch(type) {\r\n                  case 'replace':\r\n                    element.classList.add('narramorph-replaced');\r\n                    break;\r\n                  case 'fragment':\r\n                    element.classList.add('narramorph-fragmented');\r\n                    break;\r\n                  case 'expand':\r\n                    element.classList.add('narramorph-expanded');\r\n                    break;\r\n                  case 'emphasize':\r\n                    element.classList.add(`narramorph-emphasis-${matchingTransformation.emphasis || 'color'}`);\r\n                    break;\r\n                  case 'metaComment':\r\n                    element.classList.add('narramorph-commented');\r\n                    break;\r\n                }\r\n                \r\n                // Schedule class removal in one batch\r\n                setTimeout(() => {\r\n                  element.classList.remove('narramorph-transform-new');\r\n                }, 2000);\r\n              }\r\n            });\r\n          }, batchIndex * staggerDelay * batchSize);\r\n        });\r\n      };\r\n      \r\n      // Apply animations with staggered timing for each group\r\n      Object.values(transformGroups).forEach(group => {\r\n        applyAnimationsWithStagger(group);\r\n      });\r\n      \r\n      // Update animated transformations list\r\n      setAnimatedTransformations(transformationKeys);\r\n      \r\n      // Update performance metrics\r\n      const endTime = performance.now();\r\n      setMetrics(prev => ({\r\n        ...prev,\r\n        renderTime: endTime - startTime,\r\n        transformationsCount: appliedTransformations.length\r\n      }));\r\n    });\r\n  }, [newlyTransformed, appliedTransformations, animatedTransformations, isVisible]);\r\n  \r\n  // When node changes, reset animation state and update visibility tracking\r\n  useEffect(() => {\r\n    if (node?.id) {\r\n      setAnimatedTransformations([]);\r\n      \r\n      // Reset metrics for new node\r\n      setMetrics({\r\n        renderTime: 0,\r\n        transformationsCount: 0,\r\n        visibilityChanges: 0,\r\n        deferredTransformations: 0\r\n      });\r\n    }\r\n  }, [node?.id]);\r\n  \r\n  \r\n  // Show error state if WebGL context was lost\r\n  if (webGLError) {\r\n    console.error('[NarramorphRenderer] Rendering in error state due to WebGL issue');\r\n    return (\r\n      <div className=\"narramorph-error\">\r\n        <p>Advanced rendering unavailable</p>\r\n        <div dangerouslySetInnerHTML={{ __html: node?.currentContent || 'Content unavailable' }} />\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  // Show loading state if content isn't available\r\n  if (!node || !transformedContent) {\r\n    console.log('[NarramorphRenderer] Showing loading state - content not available yet');\r\n    return <div className=\"narramorph-loading\">Loading content...</div>;\r\n  }\r\n  \r\n  // Render the transformed content with animation container and enhanced visibility tracking\r\n  console.log(`[NarramorphRenderer] Rendering content for node: ${node.id}, visible: ${isVisible}`);\r\n  return (\r\n    <div\r\n      className={`narramorph-container ${isVisible ? 'is-visible' : 'is-hidden'}`}\r\n      key={renderKey}\r\n      data-node-id={node.id}\r\n      data-visibility={isVisible ? 'visible' : 'hidden'}\r\n      style={{\r\n        display: 'block',\r\n        visibility: 'visible',\r\n        position: 'relative',\r\n        minHeight: '200px'\r\n      }}\r\n    >\r\n      <TransformationAnimationContainer\r\n        transformations={prioritizedTransformations}\r\n        isNewlyTransformed={newlyTransformed}\r\n        nodeId={node.id}\r\n      >\r\n        <div\r\n          ref={contentRef}\r\n          className={`narramorph-content ${isVisible ? 'is-visible' : 'is-hidden'}`}\r\n          data-transformations-count={prioritizedTransformations.length}\r\n          data-node-id={node.id}\r\n          data-visit-count={node.visitCount}\r\n          style={{\r\n            display: 'block',\r\n            visibility: 'visible',\r\n            position: 'relative'\r\n          }}\r\n        >\r\n          {/* Show loading indicator before content is ready */}\r\n          {!transformedContent && (\r\n            <div className=\"narramorph-loading-indicator\" style={{margin: '20px 0'}}>\r\n              <div className=\"loading-spinner\"></div>\r\n              <p>Preparing narrative transformations...</p>\r\n            </div>\r\n          )}\r\n          \r\n          {/* Render content directly without virtualization */}\r\n          {transformedContent && (\r\n            <div\r\n              dangerouslySetInnerHTML={{ __html: transformedContent }}\r\n              style={{\r\n                opacity: isVisible ? 1 : 0.99, // Force visibility while maintaining transitions\r\n                transition: 'opacity 0.3s ease-in'\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      </TransformationAnimationContainer>\r\n      \r\n      {/* Optional debugging panel for tracking applied transformations */}\r\n      {process.env.NODE_ENV === 'development' && (\r\n        <div className=\"narramorph-debug\">\r\n          <h4>Applied Transformations {isVisible ? '(Visible)' : '(Hidden)'}</h4>\r\n          <ul>\r\n            {prioritizedTransformations.map((t: TextTransformation, idx: number) => (\r\n              <li key={idx}>\r\n                {t.type}: {t.selector?.substring(0, 20)}... {t.priority && `(${t.priority})`}\r\n              </li>\r\n            ))}\r\n          </ul>\r\n          <p>Path Length: {readingPath.sequence.length}</p>\r\n          <p>Visit Count: {node.visitCount}</p>\r\n          <p>Performance: {metrics.renderTime.toFixed(2)}ms for {metrics.transformationsCount} transformations</p>\r\n          <p>Deferred: {metrics.deferredTransformations} transformations</p>\r\n          <p>Visibility Changes: {metrics.visibilityChanges}</p>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default NarramorphRenderer;"],"names":["NarramorphRenderer","memo","nodeId","onVisibilityChange","node","transformedContent","newlyTransformed","appliedTransformations","useNodeState","contentRef","useRef","observerRef","renderKey","setRenderKey","useState","isVisible","setIsVisible","webGLError","setWebGLError","metrics","setMetrics","animatedTransformations","setAnimatedTransformations","useSelector","state","useEffect","handleWebGLError","event","entries","isNowVisible","_a","rect","style","prev","transformationService","prioritizedTransformations","useMemo","highPriorityTransformations","t","startTime","transformedElements","transformationKeys","newTransformations","key","transformGroups","element","type","applyAnimationsWithStagger","elements","staggerDelay","batches","i","batch","batchIndex","text","matchingTransformation","group","endTime","jsxs","jsx","TransformationAnimationContainer"],"mappings":"oMAyCA,MAAMA,EAAwDC,EAAAA,KAAK,CAAC,CAAE,OAAAC,EAAQ,mBAAAC,KAAyB,CAC/F,KAAA,CACJ,KAAAC,EACA,mBAAAC,EACA,iBAAAC,EACA,uBAAAC,CAAA,EACEC,EAAaN,CAAM,EAEjBO,EAAaC,SAAuB,IAAI,EACxCC,EAAcD,SAAoC,IAAI,EACtD,CAACE,EAAWC,CAAY,EAAIC,EAAAA,SAAS,CAAC,EACtC,CAACC,EAAWC,CAAY,EAAIF,EAAAA,SAAS,EAAI,EACzC,CAACG,EAAYC,CAAa,EAAIJ,EAAAA,SAAuB,IAAI,EAGzD,CAACK,EAASC,CAAU,EAAIN,WAA6B,CACzD,WAAY,EACZ,qBAAsB,EACtB,kBAAmB,EACnB,wBAAyB,CAAA,CAC1B,EAGK,CAACO,EAAyBC,CAA0B,EAAIR,EAAAA,SAAmB,CAAA,CAAE,EAG/DS,EAAaC,GAAqBA,EAAM,OAAO,IAAI,EAGvEC,EAAAA,UAAU,IAAM,CACR,MAAAC,EAAoBC,GAAsB,CAE1CA,EAAM,UACNA,EAAM,QAAQ,SAAS,oBAAoB,GAC3CA,EAAM,QAAQ,SAAS,qBAAqB,KACtC,QAAA,MAAM,oDAAqDA,EAAM,OAAO,EAChFT,EAAc,IAAI,MAAMS,EAAM,OAAO,CAAC,EAE1C,EAEO,cAAA,iBAAiB,QAASD,CAAgB,EAE1C,IAAM,CACJ,OAAA,oBAAoB,QAASA,CAAgB,CACtD,CACF,EAAG,EAAE,EAGLD,EAAAA,UAAU,IAAM,CACV,GAAA,CAAChB,EAAW,QAAS,CACvB,QAAQ,IAAI,oDAAoD,EAChE,MAAA,CAGM,eAAA,IAAI,gEAAiEL,GAAA,YAAAA,EAAM,EAAE,EAGjFO,EAAY,SACdA,EAAY,QAAQ,WAAW,EAKjCK,EAAa,EAAI,EACbb,IACF,QAAQ,IAAI,4DAA4D,EACxEA,EAAmB,EAAI,GAIzBQ,EAAY,QAAU,IAAI,qBACvBiB,GAAY,OACX,MAAMC,IAAeC,EAAAF,EAAQ,CAAC,IAAT,YAAAE,EAAY,iBAAkB,GAGnD,GAAIrB,EAAW,QAAS,CAChB,MAAAsB,EAAOtB,EAAW,QAAQ,sBAAsB,EAChDuB,EAAQ,OAAO,iBAAiBvB,EAAW,OAAO,EACxD,QAAQ,IAAI,0CAA0CoB,EAAe,UAAY,QAAQ,GAAI,CAC3F,WAAY,GAAG,KAAK,MAAME,EAAK,KAAK,CAAC,IAAI,KAAK,MAAMA,EAAK,MAAM,CAAC,GAChE,QAASC,EAAM,QACf,WAAYA,EAAM,WAClB,QAASA,EAAM,QACf,SAAUA,EAAM,QAAA,CACjB,CAAA,CAICjB,IAAcc,GAAgBpB,EAAW,UAC3C,QAAQ,IAAI,+CAA+CoB,EAAe,UAAY,QAAQ,EAAE,EAChGb,EAAaa,CAAY,EAGrB1B,GACFA,EAAmB0B,CAAY,EAGjCT,EAAoBa,IAAA,CAClB,GAAGA,EACH,kBAAmBA,EAAK,kBAAoB,CAAA,EAC5C,EAGE7B,GAAA,MAAAA,EAAM,IACc8B,EAAA,qBACpB9B,EAAK,GACLyB,EAEAzB,EAAK,KAAOF,EAAS,EAAI,CAC3B,EAIE2B,GACWhB,EAAAoB,GAAQA,EAAO,CAAC,EAGnC,EACA,CACE,KAAM,KACN,WAAY,QACZ,UAAW,GAAA,CAEf,EAGIxB,EAAW,UACDE,EAAA,QAAQ,QAAQF,EAAW,OAAO,EAC9C,QAAQ,IAAI,2DAA2D,EAGvE,WAAW,IAAM,CACf,GAAIA,EAAW,QAAS,CAChB,MAAAsB,EAAOtB,EAAW,QAAQ,sBAAsB,EAChDuB,EAAQ,OAAO,iBAAiBvB,EAAW,OAAO,EACxD,QAAQ,IAAI,iDAAkD,CAC5D,QAASM,EACT,WAAY,GAAG,KAAK,MAAMgB,EAAK,KAAK,CAAC,IAAI,KAAK,MAAMA,EAAK,MAAM,CAAC,GAChE,QAASC,EAAM,QACf,WAAYA,EAAM,WAClB,QAASA,EAAM,OAAA,CAChB,CAAA,GAEF,EAAE,GAIA,IAAM,OACX,QAAQ,IAAI,sDAAsD,GAClEF,EAAAnB,EAAY,UAAZ,MAAAmB,EAAqB,YACvB,GACC,CAAC1B,GAAA,YAAAA,EAAM,GAAIF,EAAQC,CAAkB,CAAC,EAGnC,MAAAgC,EAA6BC,EAAAA,QAAQ,IAAM,CAC/C,GAAI,CAAC7B,EAAuB,OAAQ,MAAO,CAAC,EAG5C,GAAIQ,EACK,OAAAR,EAIT,MAAM8B,EAA8B9B,EAAuB,OACzD+B,GAAAA,EAAE,WAAa,QAAUA,EAAE,mBAAqB,EAClD,EAEA,OAAAlB,EAAoBa,IAAA,CAClB,GAAGA,EACH,wBAAyB1B,EAAuB,OAAS8B,EAA4B,MAAA,EACrF,EAEKA,CAAA,EACN,CAAC9B,EAAwBQ,CAAS,CAAC,EA4ItC,OAxIAU,EAAAA,UAAU,IAAM,CACd,GAAI,CAACnB,GAAoB,CAACG,EAAW,SAAW,CAACM,EAC/C,OAGI,MAAAwB,EAAY,YAAY,IAAI,EAGrB1B,EAAAoB,GAAQA,EAAO,CAAC,EAG7B,sBAAsB,IAAM,OAE1B,MAAMO,GAAsBV,EAAArB,EAAW,UAAX,YAAAqB,EAAoB,iBAAiB,yBACjE,GAAI,CAACU,GAAuBA,EAAoB,SAAW,EAAG,OAG9D,MAAMC,EAAqBlC,EAAuB,IAC/C+B,GAA0B,GAAGA,EAAE,IAAI,IAAIA,EAAE,QAAQ,EACpD,EACMI,EAAqBD,EAAmB,OACrCE,GAAA,CAACtB,EAAwB,SAASsB,CAAG,CAC9C,EAEI,GAAAD,EAAmB,SAAW,EAAG,OAGrC,MAAME,EAA6C,CACjD,QAAW,CAAC,EACZ,SAAY,CAAC,EACb,OAAU,CAAC,EACX,UAAa,CAAC,EACd,YAAe,CAAA,CACjB,EAGoBJ,EAAA,QAAmBK,GAAA,CAC/B,MAAAC,EAAOD,EAAQ,aAAa,qBAAqB,EACnDC,GAAQA,KAAQF,GACFA,EAAAE,CAAI,EAAE,KAAKD,CAAO,CACpC,CACD,EAID,MAAME,EAA6B,CAACC,EAAqBC,EAAuB,KAAO,CACrF,MAAMC,EAAuB,CAAC,EAI9B,QAASC,EAAI,EAAGA,EAAIH,EAAS,OAAQG,GAAK,EAChCD,EAAA,KAAK,MAAM,KAAKF,CAAQ,EAAE,MAAMG,EAAGA,EAAI,CAAS,CAAC,EAInDD,EAAA,QAAQ,CAACE,EAAOC,IAAe,CACrC,WAAW,IAAM,CACTD,EAAA,QAAmBP,GAAA,CACjB,MAAAC,EAAOD,EAAQ,aAAa,qBAAqB,EACjDS,EAAOT,EAAQ,aAAe,GAG9BU,EAAyBhD,EAAuB,QACpD+B,EAAE,OAASQ,GACXQ,EAAK,SAAShB,EAAE,UAAY,EAAE,GAC9BI,EAAmB,SAAS,GAAGJ,EAAE,IAAI,IAAIA,EAAE,QAAQ,EAAE,CACvD,EAEA,GAAIiB,EAAwB,CAK1B,OAHQV,EAAA,UAAU,IAAI,0BAA0B,EAGzCC,EAAM,CACX,IAAK,UACKD,EAAA,UAAU,IAAI,qBAAqB,EAC3C,MACF,IAAK,WACKA,EAAA,UAAU,IAAI,uBAAuB,EAC7C,MACF,IAAK,SACKA,EAAA,UAAU,IAAI,qBAAqB,EAC3C,MACF,IAAK,YACHA,EAAQ,UAAU,IAAI,uBAAuBU,EAAuB,UAAY,OAAO,EAAE,EACzF,MACF,IAAK,cACKV,EAAA,UAAU,IAAI,sBAAsB,EAC5C,KAAA,CAIJ,WAAW,IAAM,CACPA,EAAA,UAAU,OAAO,0BAA0B,GAClD,GAAI,CAAA,CACT,CACD,CAAA,EACAQ,EAAaJ,EAAe,CAAS,CAAA,CACzC,CACH,EAGA,OAAO,OAAOL,CAAe,EAAE,QAAiBY,GAAA,CAC9CT,EAA2BS,CAAK,CAAA,CACjC,EAGDlC,EAA2BmB,CAAkB,EAGvC,MAAAgB,EAAU,YAAY,IAAI,EAChCrC,EAAoBa,IAAA,CAClB,GAAGA,EACH,WAAYwB,EAAUlB,EACtB,qBAAsBhC,EAAuB,MAAA,EAC7C,CAAA,CACH,GACA,CAACD,EAAkBC,EAAwBc,EAAyBN,CAAS,CAAC,EAGjFU,EAAAA,UAAU,IAAM,CACVrB,GAAA,MAAAA,EAAM,KACRkB,EAA2B,CAAA,CAAE,EAGlBF,EAAA,CACT,WAAY,EACZ,qBAAsB,EACtB,kBAAmB,EACnB,wBAAyB,CAAA,CAC1B,EACH,EACC,CAAChB,GAAA,YAAAA,EAAM,EAAE,CAAC,EAITa,GACF,QAAQ,MAAM,kEAAkE,EAE7EyC,EAAA,KAAA,MAAI,CAAA,UAAU,mBACb,SAAA,CAACC,EAAAA,IAAA,KAAE,SAA8B,iCAAA,EACjCA,MAAC,OAAI,wBAAyB,CAAE,QAAQvD,GAAA,YAAAA,EAAM,iBAAkB,sBAAyB,CAAA,CAAA,EAC3F,GAKA,CAACA,GAAQ,CAACC,GACZ,QAAQ,IAAI,wEAAwE,QAC5E,MAAA,CAAI,UAAU,qBAAqB,SAAkB,qBAAA,IAI/D,QAAQ,IAAI,oDAAoDD,EAAK,EAAE,cAAcW,CAAS,EAAE,EAE9F2C,EAAA,KAAC,MAAA,CACC,UAAW,wBAAwB3C,EAAY,aAAe,WAAW,GAEzE,eAAcX,EAAK,GACnB,kBAAiBW,EAAY,UAAY,SACzC,MAAO,CACL,QAAS,QACT,WAAY,UACZ,SAAU,WACV,UAAW,OACb,EAEA,SAAA,CAAA4C,EAAA,IAACC,EAAA,CACC,gBAAiBzB,EACjB,mBAAoB7B,EACpB,OAAQF,EAAK,GAEb,SAAAsD,EAAA,KAAC,MAAA,CACC,IAAKjD,EACL,UAAW,sBAAsBM,EAAY,aAAe,WAAW,GACvE,6BAA4BoB,EAA2B,OACvD,eAAc/B,EAAK,GACnB,mBAAkBA,EAAK,WACvB,MAAO,CACL,QAAS,QACT,WAAY,UACZ,SAAU,UACZ,EAGC,SAAA,CAAC,CAAAC,GACCqD,EAAAA,KAAA,MAAI,CAAA,UAAU,+BAA+B,MAAO,CAAC,OAAQ,QAAQ,EACpE,SAAA,CAACC,EAAAA,IAAA,MAAA,CAAI,UAAU,kBAAkB,EAChCA,EAAAA,IAAA,KAAE,SAAsC,wCAAA,CAAA,CAAA,EAC3C,EAIDtD,GACCsD,EAAA,IAAC,MAAA,CACC,wBAAyB,CAAE,OAAQtD,CAAmB,EACtD,MAAO,CACL,QAASU,EAAY,EAAI,IACzB,WAAY,sBAAA,CACd,CAAA,CACF,CAAA,CAAA,CAEJ,CACF,EAGC,EAAA,CAeC,EAhEGH,CAkEP,EAEJ,CAAC"}