{"version":3,"file":"narramorph-hy4W2TfA.js","sources":["../../src/hooks/useNodeState.ts","../../src/components/NodeView/TransformationAnimationContainer.tsx"],"sourcesContent":["/**\r\n * Custom hook for managing node state and transformations\r\n * Provides utilities for accessing, navigating, and transforming nodes\r\n */\r\n\r\nimport { useCallback, useEffect, useMemo, useState, useRef } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  selectNodeById,\r\n  visitNode,\r\n  revealConnection,\r\n  applyTransformation,\r\n  evaluateTransformations,\r\n  applyJourneyTransformations\r\n} from '../store/slices/nodesSlice';\r\nimport {\r\n  navigateToNode,\r\n  engageAttractor,\r\n  selectCurrentNodeId,\r\n  selectNodeRevisitCount\r\n} from '../store/slices/readerSlice';\r\nimport { setViewMode } from '../store/slices/interfaceSlice';\r\nimport { StrangeAttractor, TransformationRule, TransformationCondition, TextTransformation } from '../types';\r\nimport { RootState } from '../store/types';\r\nimport { transformationEngine } from '../services/TransformationEngine';\r\nimport { transformationService } from '../services/TransformationService';\r\n\r\n// Import the CSS for transformations\r\nimport '../styles/NarramorphTransformations.css';\r\n\r\n/**\r\n * Custom hook for node state management and transformations\r\n * @param nodeId Optional node ID to focus on\r\n */\r\nexport const useNodeState = (nodeId?: string) => {\r\n  const dispatch = useDispatch();\r\n  // Track applied transformations for transitions\r\n  const [appliedTransformations, setAppliedTransformations] = useState<TextTransformation[]>([]);\r\n  // Track if transformations were just applied for animation\r\n  const [newlyTransformed, setNewlyTransformed] = useState(false);\r\n  // Track which nodes have had transformations applied to prevent repeated dispatches\r\n  const appliedNodesRef = useRef<Set<string>>(new Set());\r\n\r\n  // Get current node ID if not provided\r\n  const currentNodeId = useSelector(selectCurrentNodeId);\r\n  const targetNodeId = nodeId || currentNodeId;\r\n\r\n  // Select node data\r\n  const node = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeById(state, targetNodeId) : null\r\n  );\r\n\r\n  // Select all nodes to access any node data\r\n  const allNodes = useSelector((state: RootState) => state.nodes.data);\r\n\r\n  // Get revisit count\r\n  const revisitCount = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeRevisitCount(state, targetNodeId) : 0\r\n  );\r\n\r\n  // Get reader state for transformation evaluation\r\n  // Used in evaluateTransformations and evaluateCondition\r\n  const readerState = useSelector((state: RootState) => state.reader);\r\n  \r\n  // Navigate to a node\r\n  const navigateTo = useCallback((id: string) => {\r\n    const nodeData = allNodes[id];\r\n    \r\n    if (nodeData) {\r\n      // Record navigation in reader path with required properties\r\n      dispatch(navigateToNode({\r\n        nodeId: id,\r\n        character: nodeData.character,\r\n        temporalValue: nodeData.temporalValue,\r\n        attractors: nodeData.strangeAttractors\r\n      }));\r\n      \r\n      // Record visit in node state\r\n      dispatch(visitNode(id));\r\n      \r\n      // Switch to reading view\r\n      dispatch(setViewMode('reading'));\r\n      \r\n      // This would be where we load the node content in a real implementation\r\n      // For now, we'll just log it\r\n      console.log(`Navigating to node: ${id}`);\r\n    } else {\r\n      console.error(`Could not navigate to node: ${id} - node data not found`);\r\n    }\r\n  }, [dispatch, allNodes]);\r\n  \r\n  // Reveal a new connection\r\n  const revealNodeConnection = useCallback((sourceId: string, targetId: string) => {\r\n    dispatch(revealConnection({ nodeId: sourceId, targetId }));\r\n  }, [dispatch]);\r\n  \r\n  // Engage with a strange attractor\r\n  const engageWithAttractor = useCallback((attractor: StrangeAttractor) => {\r\n    dispatch(engageAttractor(attractor));\r\n  }, [dispatch]);\r\n  \r\n  // Apply a transformation to the node's content\r\n  const applyNodeTransformation = useCallback((\r\n    nodeId: string, \r\n    transformation: TransformationRule\r\n  ) => {\r\n    dispatch(applyTransformation({ nodeId, transformation }));\r\n  }, [dispatch]);\r\n  \r\n  // Get neighboring nodes based on revealed connections\r\n  const neighbors = useMemo(() => {\r\n    if (!node) return [];\r\n    return node.revealedConnections;\r\n  }, [node]);  // Calculate all transformations (without state updates to prevent infinite loops)\r\n  const allTransformations = useMemo(() => {\r\n    if (!node?.currentContent) return [];\r\n    \r\n    // CRITICAL: Prevent infinite loops by checking if content is already transformed\r\n    if (node.currentContent.includes('data-transform-type') || \r\n        node.currentContent.includes('narramorph-') ||\r\n        node.currentContent.includes('[TransformationService]') ||\r\n        node.currentContent.includes('recursive loop detected') ||\r\n        node.currentContent.includes('temporal displacement')) {\r\n      console.log(`[useNodeState] Content already transformed for node ${node.id}, skipping calculation to prevent infinite loop`);\r\n      return [];\r\n    }\r\n    \r\n    // Get reader-pattern based transformations (with caching to prevent repeated calculations)\r\n    const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n      readerState,\r\n      node\r\n    );\r\n\r\n    // Get journey-based transformations (includes character bleed) - with throttling\r\n    const journeyTransformations = transformationService.calculateJourneyTransformations(\r\n      node.id,\r\n      readerState\r\n    );    // Combine with rule-based transformations from node\r\n    // Priority order: journey transformations (character bleed) first, then patterns, then rules\r\n    const combined = [\r\n      ...journeyTransformations.slice(0, 2).map(t => ({ ...t, priority: 'high' as const })), // Limit journey transformations\r\n      ...patternTransformations.slice(0, 2), // Limit pattern transformations to prevent excessive calculation\r\n      ...node.transformations.flatMap(rule =>\r\n        transformationEngine.evaluateCondition(rule.condition, readerState, node) ?\r\n          rule.transformations.slice(0, 1) : [] // Limit rule transformations even more\r\n      )\r\n    ];\r\n\r\n    // Limit transformations to prevent runaway calculations\r\n    const maxTransformations = 6; // Reduced from 8\r\n    if (combined.length > maxTransformations) {\r\n      console.warn(`[useNodeState] Too many transformations (${combined.length}) for node ${node.id}, limiting to ${maxTransformations}`);\r\n      return combined.slice(0, maxTransformations);\r\n    }\r\n\r\n    return combined;\r\n  }, [node, readerState]); // Fixed dependencies\r\n\r\n  // Generate transformed content with visual transitions\r\n  const transformedContent = useMemo(() => {\r\n    if (!node?.currentContent || allTransformations.length === 0) return node?.currentContent || null;\r\n\r\n    // Apply transformations with priority handling\r\n    const transformedText = transformationService.getCachedTransformedContent(\r\n      node.id,\r\n      node.currentContent,\r\n      allTransformations,\r\n      readerState,\r\n      node\r\n    );\r\n\r\n    // Add wrapper elements with transition classes\r\n    const wrappedContent = transformationService.wrapTransformedContent(\r\n      transformedText,\r\n      allTransformations\r\n    );\r\n\r\n    return wrappedContent;\r\n  }, [node, readerState, allTransformations]);\r\n\r\n  // Track transformation changes in a separate effect to prevent infinite loops\r\n  useEffect(() => {\r\n    if (!node || allTransformations.length === 0) return;\r\n\r\n    // Check if transformations actually changed\r\n    const transformationsChanged = JSON.stringify(appliedTransformations) !== JSON.stringify(allTransformations);\r\n    \r\n    if (transformationsChanged) {\r\n      setAppliedTransformations(allTransformations);\r\n      setNewlyTransformed(true);\r\n\r\n      // Log transformation details for debugging\r\n      if (process.env.NODE_ENV === 'development') {\r\n        const journeyTransformations = allTransformations.filter(t => t.priority === 'high');\r\n        console.log(`[useNodeState] Applied transformations for node ${node.id}:`, {\r\n          journeyTransformations: journeyTransformations.length,\r\n          patternTransformations: allTransformations.filter(t => t.priority !== 'high' && !node.transformations.some(rule => rule.transformations.includes(t))).length,\r\n          ruleTransformations: allTransformations.filter(t => t.priority !== 'high' && node.transformations.some(rule => rule.transformations.includes(t))).length,\r\n          totalTransformations: allTransformations.length,\r\n          hasCharacterBleed: journeyTransformations.some(t => t.type === 'emphasize' || t.type === 'fragment'),\r\n          journeyContext: node.journeyContext\r\n        });\r\n      }\r\n    }\r\n  }, [node, allTransformations, appliedTransformations]);\r\n  \r\n  // Reset newly transformed flag after animation\r\n  useEffect(() => {\r\n    if (newlyTransformed) {\r\n      const timer = setTimeout(() => {\r\n        setNewlyTransformed(false);\r\n      }, 2000); // Match the animation duration\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [newlyTransformed]);  // Apply transformations based on visit count and reader patterns - CRITICAL FIX to prevent infinite loops\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId) return;\r\n    \r\n    // INFINITE LOOP PREVENTION: Check if content is already transformed\r\n    if (node.currentContent && (\r\n      node.currentContent.includes('data-transform-type') || \r\n      node.currentContent.includes('narramorph-') ||\r\n      node.currentContent.includes('[TransformationService]') ||\r\n      node.currentContent.includes('recursive loop detected') ||\r\n      node.currentContent.includes('temporal displacement')\r\n    )) {\r\n      console.log(`[useNodeState] Content already transformed for node ${targetNodeId}, skipping to prevent infinite loop`);\r\n      return;\r\n    }\r\n    \r\n    // Create a unique key based on ONLY the navigation state, not content changes\r\n    // This prevents re-triggering when transformations modify the content\r\n    const nodeKey = `${targetNodeId}-${node.visitCount}`;\r\n    \r\n    // Check if we've already applied transformations for this exact combination\r\n    if (appliedNodesRef.current.has(nodeKey)) {\r\n      console.log(`[useNodeState] Skipping already applied transformations for ${nodeKey}`);\r\n      return;\r\n    }\r\n\r\n    // Only apply transformations when the node actually changes, not when reader state changes\r\n    console.log(`[useNodeState] Applying transformations for node ${targetNodeId} (visitCount: ${node.visitCount})`);\r\n    \r\n    // Mark this node+visit combination as processed BEFORE dispatching to prevent race conditions\r\n    appliedNodesRef.current.add(nodeKey);\r\n    \r\n    // Cleanup old entries to prevent memory leaks (keep only last 50 entries)\r\n    if (appliedNodesRef.current.size > 50) {\r\n      const entries = Array.from(appliedNodesRef.current);\r\n      const toKeep = entries.slice(-25); // Keep last 25 entries\r\n      appliedNodesRef.current.clear();\r\n      toKeep.forEach(key => appliedNodesRef.current.add(key));\r\n    }\r\n\r\n    // Apply journey transformations (character bleed + journey context) - but only once per node\r\n    dispatch(applyJourneyTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n\r\n    // Generate default transformations based on visit count\r\n    if (node.visitCount === 1) {\r\n      const basicTransformation: TransformationRule = {\r\n        condition: {\r\n          visitCount: 1\r\n        },\r\n        transformations: [\r\n          {\r\n            type: 'emphasize',\r\n            selector: 'first-paragraph',\r\n            emphasis: 'italic'\r\n          }\r\n        ]\r\n      };\r\n      \r\n      applyNodeTransformation(targetNodeId, basicTransformation);\r\n    }\r\n\r\n    // Generate pattern-based transformations (with reduced frequency to prevent loops)\r\n    if (node.visitCount >= 2 && node.visitCount <= 5) { // Limit pattern generation to early visits\r\n      const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n        readerState,\r\n        node\r\n      );\r\n      \r\n      // Apply these transformations only if they're not too many\r\n      if (patternTransformations.length > 0 && patternTransformations.length <= 3) {\r\n        const patternBasedRule: TransformationRule = {\r\n          condition: { visitCount: node.visitCount },\r\n          transformations: patternTransformations\r\n        };\r\n        \r\n        applyNodeTransformation(targetNodeId, patternBasedRule);\r\n      }\r\n    }\r\n\r\n    // Evaluate transformations against current reader state (with throttling)\r\n    dispatch(evaluateTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n  }, [targetNodeId, node, dispatch, applyNodeTransformation, readerState]); // Fixed dependencies  // TEMPORARILY DISABLED: Update content variants when reader state changes\r\n  // This effect was causing content to disappear due to re-selection loops\r\n  // TODO: Re-enable with proper dependency management\r\n  /*\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId || !node.enhancedContent) return;\r\n\r\n    // Create selection context and update content variant if needed\r\n    try {\r\n      const context = {\r\n        visitCount: node.visitCount,\r\n        lastVisitedCharacter: readerState.path.sequence.length > 1 \r\n          ? allNodes[readerState.path.sequence[readerState.path.sequence.length - 2]]?.character \r\n          : undefined,\r\n        journeyPattern: readerState.path.sequence.slice(-5),\r\n        characterSequence: readerState.path.sequence\r\n          .slice(-5)\r\n          .map(id => allNodes[id]?.character)\r\n          .filter((char): char is Character => char !== undefined),\r\n        attractorsEngaged: readerState.path.attractorsEngaged || {},\r\n        recursiveAwareness: readerState.path.sequence.length > 0 \r\n          ? 1 - (new Set(readerState.path.sequence).size / readerState.path.sequence.length)\r\n          : 0\r\n      };\r\n\r\n      // Import dynamically to avoid circular dependencies\r\n      import('../services/ContentVariantService').then(({ contentVariantService }) => {\r\n        const selectedContent = contentVariantService.selectContentVariant(\r\n          node.enhancedContent!,\r\n          context\r\n        );\r\n\r\n        // Only dispatch if the content actually changed\r\n        if (selectedContent !== node.currentContent) {\r\n          dispatch(updateContentVariant({ \r\n            nodeId: targetNodeId, \r\n            context,\r\n            selectedContent \r\n          }));\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.warn(`[useNodeState] Error updating content variant for node ${targetNodeId}:`, error);\r\n    }\r\n  }, [node, targetNodeId, readerState.path, allNodes, dispatch]);\r\n  */\r\n  \r\n  // Evaluate a condition directly using the transformation engine\r\n  const evaluateCondition = useCallback(\r\n    (condition: TransformationCondition) => {\r\n      if (!node) return false;\r\n      return transformationEngine.evaluateCondition(condition, readerState, node);\r\n    },\r\n    [node, readerState]\r\n  );\r\n  \r\n  // Return the API\r\n  return {\r\n    node,\r\n    navigateTo,\r\n    revealNodeConnection,\r\n    engageWithAttractor,\r\n    applyNodeTransformation,\r\n    evaluateCondition,\r\n    neighbors,\r\n    revisitCount,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  };\r\n};\r\n\r\nexport default useNodeState;","/**\r\n * TransformationAnimationContainer Component\r\n * \r\n * Provides enhanced transition animations when content transforms between states.\r\n * This component wraps around transformed content and adds visual context\r\n * to help users understand the transformation process.\r\n */\r\n\r\nimport React, { useEffect, useRef, useState, useLayoutEffect } from 'react';\r\nimport { TextTransformation } from '../../types';\r\n\r\n// For debugging DOM measurements and layout issues\r\ninterface ElementMeasurements {\r\n  width: number;\r\n  height: number;\r\n  visibility: string;\r\n  display: string;\r\n  opacity: string;\r\n  position: string;\r\n  zIndex: string;\r\n  overflow: string;\r\n}\r\n\r\ninterface TransformationAnimationContainerProps {\r\n  children: React.ReactNode;\r\n  transformations: TextTransformation[];\r\n  isNewlyTransformed: boolean;\r\n  nodeId: string;\r\n}\r\n\r\nconst TransformationAnimationContainer: React.FC<TransformationAnimationContainerProps> = ({\r\n  children,\r\n  transformations,\r\n  isNewlyTransformed,\r\n  nodeId\r\n}): React.ReactElement => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [animationState, setAnimationState] = useState<'idle' | 'entering' | 'active'>('idle');\r\n  const [transformationCount, setTransformationCount] = useState(transformations.length);\r\n  const [renderAttempt, setRenderAttempt] = useState(0);\r\n  \r\n  // Track DOM measurements for debugging\r\n  const [measurements, setMeasurements] = useState<ElementMeasurements | null>(null);\r\n  const [contentVisible, setContentVisible] = useState(true);\r\n  \r\n  // Force a re-render after mount to ensure visibility\r\n  useEffect(() => {\r\n    // After mount, force a re-render to ensure proper layout\r\n    // Limit to max 3 attempts to prevent infinite loops\r\n    if (renderAttempt < 3) {\r\n      const timer = setTimeout(() => {\r\n        setRenderAttempt(prev => prev + 1);\r\n        console.log(`[AnimationContainer] Forced re-render for node: ${nodeId}, attempt: ${renderAttempt + 1}`);\r\n      }, 100);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [nodeId, renderAttempt]);\r\n  \r\n  // When transformations change, update the animation state\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      setAnimationState('entering');\r\n      \r\n      // After the animation completes, set to active state\r\n      const timer = setTimeout(() => {\r\n        setAnimationState('active');\r\n      }, 1000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isNewlyTransformed, transformations]);\r\n  \r\n  // When node changes or transformation count changes, reset animation state\r\n  useEffect(() => {\r\n    setAnimationState('idle');\r\n    setTransformationCount(transformations.length);\r\n    \r\n    // Debug log for node changes\r\n    console.log(`[AnimationContainer] Node changed to: ${nodeId}, transformations: ${transformations.length}`);\r\n  }, [nodeId, transformations.length]);\r\n  \r\n  // Monitor and log DOM measurements for debugging visibility issues\r\n  useLayoutEffect(() => {\r\n    if (!containerRef.current) return;\r\n    \r\n    // Function to measure DOM element properties\r\n    const measureElement = () => {\r\n      if (!containerRef.current) return;\r\n      \r\n      const style = window.getComputedStyle(containerRef.current);\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      \r\n      const newMeasurements: ElementMeasurements = {\r\n        width: rect.width,\r\n        height: rect.height,\r\n        visibility: style.visibility,\r\n        display: style.display,\r\n        opacity: style.opacity,\r\n        position: style.position,\r\n        zIndex: style.zIndex,\r\n        overflow: style.overflow\r\n      };\r\n      \r\n      setMeasurements(newMeasurements);\r\n      \r\n      // Check if content is visible in DOM\r\n      const isVisible = rect.width > 0 &&\r\n                        rect.height > 0 &&\r\n                        style.visibility !== 'hidden' &&\r\n                        style.display !== 'none' &&\r\n                        parseFloat(style.opacity) > 0;\r\n                        \r\n      setContentVisible(isVisible);\r\n      \r\n      // Log significant changes to visibility\r\n      if (contentVisible !== isVisible) {\r\n        console.log(`[AnimationContainer] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`, {\r\n          nodeId,\r\n          transformations: transformations.length,\r\n          animationState,\r\n          measurements: newMeasurements\r\n        });\r\n      }\r\n    };\r\n    \r\n    // Measure immediately\r\n    measureElement();\r\n    \r\n    // Measure after animations might be complete\r\n    const timer = setTimeout(measureElement, 1100);\r\n    \r\n    // Set up mutation observer to track DOM changes - with debouncing\r\n    let timeoutId: number | null = null;\r\n    const observer = new MutationObserver((mutations) => {\r\n      // Only log significant mutations to reduce noise\r\n      if (mutations.length > 2) {\r\n        console.log(`[AnimationContainer] DOM mutations detected: ${mutations.length}`);\r\n      }\r\n      \r\n      // Debounce measurements to prevent infinite loops\r\n      if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      \r\n      timeoutId = window.setTimeout(() => {\r\n        measureElement();\r\n        timeoutId = null;\r\n      }, 500);\r\n    });\r\n    \r\n    observer.observe(containerRef.current, {\r\n      attributes: true,\r\n      childList: true,\r\n      subtree: false // Reduced to false to prevent excessive notifications\r\n    });\r\n    \r\n    return () => {\r\n      clearTimeout(timer);\r\n      observer.disconnect();\r\n    };\r\n  }, [nodeId, transformations, animationState, contentVisible]);\r\n  \r\n  // Determine which animation effect to apply based on transformation types\r\n  const getAnimationClass = () => {\r\n    if (animationState === 'idle') return '';\r\n    \r\n    const hasReplacements = transformations.some(t => t.type === 'replace');\r\n    const hasEmphasis = transformations.some(t => t.type === 'emphasize');\r\n    const hasExpansions = transformations.some(t => t.type === 'expand');\r\n    \r\n    if (animationState === 'entering') {\r\n      if (hasReplacements) return 'narramorph-container-replace-active';\r\n      if (hasEmphasis) return 'narramorph-container-emphasis-active';\r\n      if (hasExpansions) return 'narramorph-container-expand-active';\r\n      return 'narramorph-container-transform-active';\r\n    }\r\n    \r\n    return 'narramorph-container-active';\r\n  };\r\n  \r\n  // Get a description of transformation activity\r\n  const getTransformationDescription = () => {\r\n    if (transformations.length === 0) return '';\r\n    \r\n    const typeCount: Record<string, number> = {};\r\n    transformations.forEach(t => {\r\n      typeCount[t.type] = (typeCount[t.type] || 0) + 1;\r\n    });\r\n    \r\n    // Generate a description based on the types of transformations\r\n    const descriptions = [];\r\n    \r\n    if (typeCount['replace']) {\r\n      descriptions.push(`${typeCount['replace']} replacements`);\r\n    }\r\n    \r\n    if (typeCount['emphasize']) {\r\n      descriptions.push(`${typeCount['emphasize']} emphasis`);\r\n    }\r\n    \r\n    if (typeCount['expand']) {\r\n      descriptions.push(`${typeCount['expand']} expansions`);\r\n    }\r\n    \r\n    if (typeCount['fragment']) {\r\n      descriptions.push(`${typeCount['fragment']} fragmentations`);\r\n    }\r\n    \r\n    if (typeCount['metaComment']) {\r\n      descriptions.push(`${typeCount['metaComment']} comments`);\r\n    }\r\n    \r\n    return descriptions.join(', ');\r\n  };\r\n  \r\n  // Check if number of transformations has changed\r\n  const hasChangedTransformations = transformations.length !== transformationCount;\r\n  \r\n  // Log when animations are triggered\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      console.log(`[AnimationContainer] Animation started for node: ${nodeId}`, {\r\n        transformations: transformations.length,\r\n        animationState,\r\n        contentVisible\r\n      });\r\n    }\r\n  }, [isNewlyTransformed, nodeId, transformations.length, animationState, contentVisible]);\r\n  \r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`narramorph-animation-container ${getAnimationClass()}`}\r\n      data-transformation-count={transformations.length}\r\n      data-newly-transformed={isNewlyTransformed}\r\n      data-animation-state={animationState}\r\n      data-visible={contentVisible}\r\n      data-render-attempt={renderAttempt}\r\n      style={{\r\n        overflow: 'visible',\r\n        minHeight: '150px',\r\n        position: 'relative', // Ensure positioning context\r\n        visibility: 'visible',\r\n        display: 'block',\r\n        opacity: 1\r\n      }}\r\n    >\r\n      {/* Visual indicator for active transformations */}\r\n      {transformations.length > 0 && (\r\n        <div \r\n          className={`narramorph-transformation-indicator ${isNewlyTransformed ? 'active' : ''}`}\r\n          title={getTransformationDescription()}\r\n        >\r\n          <span className=\"transformation-count\">{transformations.length}</span>\r\n          {hasChangedTransformations && (\r\n            <span className=\"transformation-change-indicator\">\r\n              {transformations.length > transformationCount ? '+' : ''}\r\n              {transformations.length - transformationCount}\r\n            </span>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content with transformations */}\r\n      <div\r\n        ref={contentRef}\r\n        className=\"narramorph-animation-content\"\r\n        style={{\r\n          position: 'relative',\r\n          visibility: 'visible',\r\n          display: 'block',\r\n          opacity: 1,\r\n          minHeight: '100px'\r\n        }}\r\n      >\r\n        {renderAttempt === 0 ? (\r\n          <div className=\"animation-placeholder\" style={{ padding: '20px', textAlign: 'center' }}>\r\n            <p>Preparing narrative...</p>\r\n          </div>\r\n        ) : (\r\n          children\r\n        )}\r\n      </div>\r\n      \r\n      {/* Debug info overlay - only in development */}\r\n      {process.env.NODE_ENV === 'development' && measurements && (\r\n        <div\r\n          className=\"animation-debug-info\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: 0,\r\n            right: 0,\r\n            background: 'rgba(0,0,0,0.7)',\r\n            color: '#fff',\r\n            padding: '3px',\r\n            fontSize: '9px',\r\n            zIndex: 1000,\r\n            pointerEvents: 'none'\r\n          }}\r\n        >\r\n          <div>{`${Math.round(measurements.width)}x${Math.round(measurements.height)}`}</div>\r\n          <div>{`Vis:${measurements.visibility.charAt(0)}|Dis:${measurements.display.charAt(0)}`}</div>\r\n          <div>{`Op:${parseFloat(measurements.opacity).toFixed(1)}|Z:${measurements.zIndex}`}</div>\r\n          <div>{`T:${transformations.length}|S:${animationState.charAt(0)}`}</div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TransformationAnimationContainer;"],"names":["useNodeState","nodeId","dispatch","useDispatch","appliedTransformations","setAppliedTransformations","useState","newlyTransformed","setNewlyTransformed","appliedNodesRef","useRef","currentNodeId","useSelector","selectCurrentNodeId","targetNodeId","node","state","selectNodeById","allNodes","revisitCount","selectNodeRevisitCount","readerState","navigateTo","useCallback","id","nodeData","navigateToNode","visitNode","setViewMode","revealNodeConnection","sourceId","targetId","revealConnection","engageWithAttractor","attractor","engageAttractor","applyNodeTransformation","transformation","applyTransformation","neighbors","useMemo","allTransformations","patternTransformations","transformationService","combined","t","rule","transformationEngine","maxTransformations","transformedContent","transformedText","useEffect","timer","nodeKey","toKeep","key","applyJourneyTransformations","patternBasedRule","evaluateTransformations","evaluateCondition","condition","TransformationAnimationContainer","children","transformations","isNewlyTransformed","containerRef","contentRef","animationState","setAnimationState","transformationCount","setTransformationCount","renderAttempt","setRenderAttempt","measurements","setMeasurements","contentVisible","setContentVisible","prev","useLayoutEffect","measureElement","style","rect","newMeasurements","isVisible","timeoutId","observer","mutations","getAnimationClass","hasReplacements","hasEmphasis","hasExpansions","getTransformationDescription","typeCount","descriptions","hasChangedTransformations","jsxs","jsx"],"mappings":"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"}