{"version":3,"file":"narramorph-BBDYQQAX.js","sources":["../../src/hooks/useNodeState.ts","../../src/components/NodeView/TransformationAnimationContainer.tsx"],"sourcesContent":["/**\r\n * Custom hook for managing node state and transformations\r\n * Provides utilities for accessing, navigating, and transforming nodes\r\n */\r\n\r\nimport { useCallback, useEffect, useMemo, useState, useRef } from 'react';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  selectNodeById,\r\n  visitNode,\r\n  revealConnection,\r\n  applyTransformation,\r\n  evaluateTransformations,\r\n  applyJourneyTransformations\r\n} from '../store/slices/nodesSlice';\r\nimport {\r\n  navigateToNode,\r\n  engageAttractor,\r\n  selectCurrentNodeId,\r\n  selectNodeRevisitCount\r\n} from '../store/slices/readerSlice';\r\nimport { setViewMode } from '../store/slices/interfaceSlice';\r\nimport { StrangeAttractor, TransformationRule, TransformationCondition, TextTransformation } from '../types';\r\nimport { RootState } from '../store/types';\r\nimport { transformationEngine } from '../services/TransformationEngine';\r\nimport { transformationService } from '../services/TransformationService';\r\n\r\n// Import the CSS for transformations\r\nimport '../styles/NarramorphTransformations.css';\r\n\r\n/**\r\n * Custom hook for node state management and transformations\r\n * @param nodeId Optional node ID to focus on\r\n */\r\nexport const useNodeState = (nodeId?: string) => {\r\n  const dispatch = useDispatch();\r\n  // Track applied transformations for transitions\r\n  const [appliedTransformations, setAppliedTransformations] = useState<TextTransformation[]>([]);\r\n  // Track if transformations were just applied for animation\r\n  const [newlyTransformed, setNewlyTransformed] = useState(false);  // Track which nodes have had transformations applied to prevent repeated dispatches\r\n  const appliedNodesRef = useRef<Set<string>>(new Set());\r\n  // Throttle transformation dispatches to prevent excessive calls\r\n  const lastTransformationDispatchRef = useRef<number>(0);\r\n\r\n  // Get current node ID if not provided\r\n  const currentNodeId = useSelector(selectCurrentNodeId);\r\n  const targetNodeId = nodeId || currentNodeId;\r\n\r\n  // Select node data\r\n  const node = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeById(state, targetNodeId) : null\r\n  );\r\n\r\n  // Select all nodes to access any node data\r\n  const allNodes = useSelector((state: RootState) => state.nodes.data);\r\n\r\n  // Get revisit count\r\n  const revisitCount = useSelector((state: RootState) =>\r\n    targetNodeId ? selectNodeRevisitCount(state, targetNodeId) : 0\r\n  );\r\n\r\n  // Get reader state for transformation evaluation\r\n  // Used in evaluateTransformations and evaluateCondition\r\n  const readerState = useSelector((state: RootState) => state.reader);\r\n  \r\n  // Navigate to a node\r\n  const navigateTo = useCallback((id: string) => {\r\n    const nodeData = allNodes[id];\r\n    \r\n    if (nodeData) {\r\n      // Record navigation in reader path with required properties\r\n      dispatch(navigateToNode({\r\n        nodeId: id,\r\n        character: nodeData.character,\r\n        temporalValue: nodeData.temporalValue,\r\n        attractors: nodeData.strangeAttractors\r\n      }));\r\n      \r\n      // Record visit in node state\r\n      dispatch(visitNode(id));\r\n      \r\n      // Switch to reading view\r\n      dispatch(setViewMode('reading'));\r\n      \r\n      // This would be where we load the node content in a real implementation\r\n      // For now, we'll just log it\r\n      console.log(`Navigating to node: ${id}`);\r\n    } else {\r\n      console.error(`Could not navigate to node: ${id} - node data not found`);\r\n    }\r\n  }, [dispatch, allNodes]);\r\n  \r\n  // Reveal a new connection\r\n  const revealNodeConnection = useCallback((sourceId: string, targetId: string) => {\r\n    dispatch(revealConnection({ nodeId: sourceId, targetId }));\r\n  }, [dispatch]);\r\n  \r\n  // Engage with a strange attractor\r\n  const engageWithAttractor = useCallback((attractor: StrangeAttractor) => {\r\n    dispatch(engageAttractor(attractor));\r\n  }, [dispatch]);\r\n  \r\n  // Apply a transformation to the node's content\r\n  const applyNodeTransformation = useCallback((\r\n    nodeId: string, \r\n    transformation: TransformationRule\r\n  ) => {\r\n    dispatch(applyTransformation({ nodeId, transformation }));\r\n  }, [dispatch]);\r\n  \r\n  // Get neighboring nodes based on revealed connections\r\n  const neighbors = useMemo(() => {\r\n    if (!node) return [];\r\n    return node.revealedConnections;\r\n  }, [node]);  // Calculate all transformations using the new master integration method\r\n  const allTransformations = useMemo(() => {\r\n    // EMERGENCY FIX: Use original content to prevent recursive transformations\r\n    const baseContent = node?.originalContent || node?.currentContent;\r\n    if (!baseContent) return [];\r\n    \r\n    // Use the new master transformation coordination method\r\n    // This automatically handles character bleed, journey patterns, and node rules\r\n    // with proper priority ordering, deduplication, and caching\r\n    try {\r\n      // Pass all nodes from Redux store for better context\r\n      const transformations = transformationEngine.calculateAllTransformations(\r\n        baseContent, // EMERGENCY FIX: Always use original content\r\n        node,\r\n        readerState,\r\n        allNodes\r\n      );\r\n      \r\n      console.log(`[useNodeState] Master transformation integration calculated ${transformations.length} transformations for node ${node.id}:`, {\r\n        characterBleed: transformations.filter(t => t.priority === 'high' && (t.type === 'emphasize' || t.type === 'fragment')).length,\r\n        journeyPatterns: transformations.filter(t => t.priority === 'high' && t.type !== 'emphasize' && t.type !== 'fragment').length,\r\n        nodeRules: transformations.filter(t => t.priority !== 'high').length,\r\n        totalTransformations: transformations.length,\r\n        baseContentLength: baseContent.length,\r\n        usingOriginalContent: !!node?.originalContent\r\n      });\r\n      return transformations;\r\n      \r\n    } catch (error) {\r\n      console.error(`[useNodeState] Error in master transformation calculation for node ${node.id}:`, error);\r\n      return [];\r\n    }\r\n  }, [node, readerState, allNodes]);  // Generate transformed content using the new master integration method\r\n  const transformedContent = useMemo(() => {\r\n    // EMERGENCY FIX: Use original content to prevent recursive transformations\r\n    const baseContent = node?.originalContent || node?.currentContent;\r\n    if (!baseContent) return null;\r\n\r\n    try {\r\n      // Use the new master getTransformedContent method\r\n      // This automatically handles all transformation coordination, caching, and content application\r\n      const fullyTransformedContent = transformationEngine.getTransformedContent(\r\n        { ...node, currentContent: baseContent }, // EMERGENCY FIX: Force use of original content\r\n        readerState,\r\n        allNodes\r\n      );\r\n\r\n      // Add wrapper elements with transition classes if transformations were applied\r\n      if (fullyTransformedContent !== baseContent && allTransformations.length > 0) {\r\n        const wrappedContent = transformationService.wrapTransformedContent(\r\n          fullyTransformedContent,\r\n          allTransformations\r\n        );\r\n        \r\n        console.log(`[useNodeState] Applied transformation wrapping for node ${node.id}:`, {\r\n          originalLength: baseContent.length,\r\n          transformedLength: fullyTransformedContent.length,\r\n          wrappedLength: wrappedContent.length,\r\n          transformationsCount: allTransformations.length,\r\n          usingOriginalContent: !!node?.originalContent\r\n        });\r\n        \r\n        return wrappedContent;\r\n      }\r\n\r\n      return fullyTransformedContent;\r\n      \r\n    } catch (error) {\r\n      console.error(`[useNodeState] Error in master content transformation for node ${node.id}:`, error);\r\n      // EMERGENCY FALLBACK: Return original content on error\r\n      return baseContent;\r\n    }\r\n  }, [node, readerState, allNodes, allTransformations]);// Track transformation changes in a separate effect to prevent infinite loops\r\n  useEffect(() => {\r\n    if (!node || allTransformations.length === 0) return;\r\n\r\n    // Check if transformations actually changed\r\n    const transformationsChanged = JSON.stringify(appliedTransformations) !== JSON.stringify(allTransformations);\r\n    \r\n    if (transformationsChanged) {\r\n      setAppliedTransformations(allTransformations);\r\n      setNewlyTransformed(true);\r\n\r\n      // Enhanced logging for debugging the master integration\r\n      if (process.env.NODE_ENV === 'development') {\r\n        const characterBleedTransformations = allTransformations.filter(t => \r\n          t.priority === 'high' && (t.type === 'emphasize' || t.type === 'fragment')\r\n        );\r\n        const journeyPatternTransformations = allTransformations.filter(t => \r\n          t.priority === 'high' && t.type !== 'emphasize' && t.type !== 'fragment'\r\n        );\r\n        const nodeRuleTransformations = allTransformations.filter(t => \r\n          t.priority !== 'high'\r\n        );\r\n        \r\n        console.log(`[useNodeState] Applied master transformations for node ${node.id}:`, {\r\n          characterBleed: {\r\n            count: characterBleedTransformations.length,\r\n            types: characterBleedTransformations.map(t => t.type),\r\n            selectors: characterBleedTransformations.map(t => t.selector?.substring(0, 20)).filter(Boolean)\r\n          },\r\n          journeyPatterns: {\r\n            count: journeyPatternTransformations.length,\r\n            types: journeyPatternTransformations.map(t => t.type)\r\n          },\r\n          nodeRules: {\r\n            count: nodeRuleTransformations.length,\r\n            types: nodeRuleTransformations.map(t => t.type)\r\n          },\r\n          totalTransformations: allTransformations.length,\r\n          journeyContext: node.journeyContext,\r\n          character: node.character,\r\n          visitCount: node.visitCount\r\n        });\r\n      }\r\n    }\r\n  }, [node, allTransformations, appliedTransformations]);\r\n  \r\n  // Reset newly transformed flag after animation\r\n  useEffect(() => {\r\n    if (newlyTransformed) {\r\n      const timer = setTimeout(() => {\r\n        setNewlyTransformed(false);\r\n      }, 2000); // Match the animation duration\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [newlyTransformed]);  // Enhanced transformation application with master integration support\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId) return;\r\n    \r\n    // Throttle: Only allow transformation dispatches every 500ms\r\n    const now = Date.now();\r\n    if (now - lastTransformationDispatchRef.current < 500) {\r\n      return;\r\n    }\r\n    \r\n    // INFINITE LOOP PREVENTION: Check if content is already transformed\r\n    if (node.currentContent && (\r\n      node.currentContent.includes('data-transform-type') || \r\n      node.currentContent.includes('narramorph-') ||\r\n      node.currentContent.includes('[TransformationService]') ||\r\n      node.currentContent.includes('recursive loop detected') ||\r\n      node.currentContent.includes('temporal displacement')\r\n    )) {\r\n      console.log(`[useNodeState] Content already transformed for node ${targetNodeId}, skipping legacy transformation dispatch`);\r\n      return;\r\n    }\r\n    \r\n    // Create a unique key based on ONLY the navigation state, not content changes\r\n    const nodeKey = `${targetNodeId}-${node.visitCount}`;\r\n    \r\n    // Check if we've already applied transformations for this exact combination\r\n    if (appliedNodesRef.current.has(nodeKey)) {\r\n      console.log(`[useNodeState] Skipping already applied legacy transformations for ${nodeKey}`);\r\n      return;\r\n    }\r\n\r\n    // Only apply legacy transformations when the node actually changes\r\n    console.log(`[useNodeState] Applying legacy transformation dispatch for node ${targetNodeId} (visitCount: ${node.visitCount})`);\r\n    \r\n    // Update the last dispatch timestamp BEFORE dispatching\r\n    lastTransformationDispatchRef.current = now;\r\n    \r\n    // Mark this node+visit combination as processed BEFORE dispatching\r\n    appliedNodesRef.current.add(nodeKey);\r\n    \r\n    // Cleanup old entries to prevent memory leaks\r\n    if (appliedNodesRef.current.size > 50) {\r\n      const entries = Array.from(appliedNodesRef.current);\r\n      const toKeep = entries.slice(-25);\r\n      appliedNodesRef.current.clear();\r\n      toKeep.forEach(key => appliedNodesRef.current.add(key));\r\n    }\r\n\r\n    // Apply journey transformations (for backward compatibility with Redux store)\r\n    // Note: The master integration handles this automatically, but we keep this for store consistency\r\n    dispatch(applyJourneyTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n\r\n    // Apply basic visit-based transformations for backward compatibility\r\n    if (node.visitCount === 1) {\r\n      const basicTransformation: TransformationRule = {\r\n        condition: { visitCount: 1 },\r\n        transformations: [{\r\n          type: 'emphasize',\r\n          selector: 'first-paragraph',\r\n          emphasis: 'italic'\r\n        }]\r\n      };\r\n      applyNodeTransformation(targetNodeId, basicTransformation);\r\n    }\r\n\r\n    // Generate reduced pattern-based transformations to complement master integration\r\n    if (node.visitCount >= 2 && node.visitCount <= 3) {\r\n      const patternTransformations = transformationService.createTransformationsFromPatterns(\r\n        readerState,\r\n        node\r\n      );\r\n      \r\n      if (patternTransformations.length > 0 && patternTransformations.length <= 2) {\r\n        const patternBasedRule: TransformationRule = {\r\n          condition: { visitCount: node.visitCount },\r\n          transformations: patternTransformations.slice(0, 1) // Limit to 1 to avoid conflicts with master integration\r\n        };\r\n        applyNodeTransformation(targetNodeId, patternBasedRule);\r\n      }\r\n    }\r\n\r\n    // Evaluate transformations against current reader state\r\n    dispatch(evaluateTransformations({\r\n      nodeId: targetNodeId,\r\n      readerState\r\n    }));\r\n  }, [targetNodeId, node, dispatch, applyNodeTransformation, readerState]);// TEMPORARILY DISABLED: Update content variants when reader state changes\r\n  // This effect was causing content to disappear due to re-selection loops\r\n  // TODO: Re-enable with proper dependency management\r\n  /*\r\n  useEffect(() => {\r\n    if (!node || !targetNodeId || !node.enhancedContent) return;\r\n\r\n    // Create selection context and update content variant if needed\r\n    try {\r\n      const context = {\r\n        visitCount: node.visitCount,\r\n        lastVisitedCharacter: readerState.path.sequence.length > 1 \r\n          ? allNodes[readerState.path.sequence[readerState.path.sequence.length - 2]]?.character \r\n          : undefined,\r\n        journeyPattern: readerState.path.sequence.slice(-5),\r\n        characterSequence: readerState.path.sequence\r\n          .slice(-5)\r\n          .map(id => allNodes[id]?.character)\r\n          .filter((char): char is Character => char !== undefined),\r\n        attractorsEngaged: readerState.path.attractorsEngaged || {},\r\n        recursiveAwareness: readerState.path.sequence.length > 0 \r\n          ? 1 - (new Set(readerState.path.sequence).size / readerState.path.sequence.length)\r\n          : 0\r\n      };\r\n\r\n      // Import dynamically to avoid circular dependencies\r\n      import('../services/ContentVariantService').then(({ contentVariantService }) => {\r\n        const selectedContent = contentVariantService.selectContentVariant(\r\n          node.enhancedContent!,\r\n          context\r\n        );\r\n\r\n        // Only dispatch if the content actually changed\r\n        if (selectedContent !== node.currentContent) {\r\n          dispatch(updateContentVariant({ \r\n            nodeId: targetNodeId, \r\n            context,\r\n            selectedContent \r\n          }));\r\n        }\r\n      });\r\n    } catch (error) {\r\n      console.warn(`[useNodeState] Error updating content variant for node ${targetNodeId}:`, error);\r\n    }\r\n  }, [node, targetNodeId, readerState.path, allNodes, dispatch]);\r\n  */\r\n  \r\n  // Evaluate a condition directly using the transformation engine\r\n  const evaluateCondition = useCallback(\r\n    (condition: TransformationCondition) => {\r\n      if (!node) return false;\r\n      return transformationEngine.evaluateCondition(condition, readerState, node);\r\n    },\r\n    [node, readerState]\r\n  );\r\n  \r\n  // Return the API\r\n  return {\r\n    node,\r\n    navigateTo,\r\n    revealNodeConnection,\r\n    engageWithAttractor,\r\n    applyNodeTransformation,\r\n    evaluateCondition,\r\n    neighbors,\r\n    revisitCount,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  };\r\n};\r\n\r\nexport default useNodeState;","/**\r\n * TransformationAnimationContainer Component\r\n * \r\n * Provides enhanced transition animations when content transforms between states.\r\n * This component wraps around transformed content and adds visual context\r\n * to help users understand the transformation process.\r\n */\r\n\r\nimport React, { useEffect, useRef, useState, useLayoutEffect } from 'react';\r\nimport { TextTransformation } from '../../types';\r\n\r\n// For debugging DOM measurements and layout issues\r\ninterface ElementMeasurements {\r\n  width: number;\r\n  height: number;\r\n  visibility: string;\r\n  display: string;\r\n  opacity: string;\r\n  position: string;\r\n  zIndex: string;\r\n  overflow: string;\r\n}\r\n\r\ninterface TransformationAnimationContainerProps {\r\n  children: React.ReactNode;\r\n  transformations: TextTransformation[];\r\n  isNewlyTransformed: boolean;\r\n  nodeId: string;\r\n}\r\n\r\nconst TransformationAnimationContainer: React.FC<TransformationAnimationContainerProps> = ({\r\n  children,\r\n  transformations,\r\n  isNewlyTransformed,\r\n  nodeId\r\n}): React.ReactElement => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [animationState, setAnimationState] = useState<'idle' | 'entering' | 'active'>('idle');\r\n  const [transformationCount, setTransformationCount] = useState(transformations.length);\r\n  const [renderAttempt, setRenderAttempt] = useState(0);\r\n  \r\n  // Track DOM measurements for debugging\r\n  const [measurements, setMeasurements] = useState<ElementMeasurements | null>(null);\r\n  const [contentVisible, setContentVisible] = useState(true);\r\n  \r\n  // Force a re-render after mount to ensure visibility\r\n  useEffect(() => {\r\n    // After mount, force a re-render to ensure proper layout\r\n    // Limit to max 3 attempts to prevent infinite loops\r\n    if (renderAttempt < 3) {\r\n      const timer = setTimeout(() => {\r\n        setRenderAttempt(prev => prev + 1);\r\n        console.log(`[AnimationContainer] Forced re-render for node: ${nodeId}, attempt: ${renderAttempt + 1}`);\r\n      }, 100);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [nodeId, renderAttempt]);\r\n  \r\n  // When transformations change, update the animation state\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      setAnimationState('entering');\r\n      \r\n      // After the animation completes, set to active state\r\n      const timer = setTimeout(() => {\r\n        setAnimationState('active');\r\n      }, 1000);\r\n      \r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [isNewlyTransformed, transformations]);\r\n  \r\n  // When node changes or transformation count changes, reset animation state\r\n  useEffect(() => {\r\n    setAnimationState('idle');\r\n    setTransformationCount(transformations.length);\r\n    \r\n    // Debug log for node changes\r\n    console.log(`[AnimationContainer] Node changed to: ${nodeId}, transformations: ${transformations.length}`);\r\n  }, [nodeId, transformations.length]);\r\n  \r\n  // Monitor and log DOM measurements for debugging visibility issues\r\n  useLayoutEffect(() => {\r\n    if (!containerRef.current) return;\r\n    \r\n    // Function to measure DOM element properties\r\n    const measureElement = () => {\r\n      if (!containerRef.current) return;\r\n      \r\n      const style = window.getComputedStyle(containerRef.current);\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      \r\n      const newMeasurements: ElementMeasurements = {\r\n        width: rect.width,\r\n        height: rect.height,\r\n        visibility: style.visibility,\r\n        display: style.display,\r\n        opacity: style.opacity,\r\n        position: style.position,\r\n        zIndex: style.zIndex,\r\n        overflow: style.overflow\r\n      };\r\n      \r\n      setMeasurements(newMeasurements);\r\n      \r\n      // Check if content is visible in DOM\r\n      const isVisible = rect.width > 0 &&\r\n                        rect.height > 0 &&\r\n                        style.visibility !== 'hidden' &&\r\n                        style.display !== 'none' &&\r\n                        parseFloat(style.opacity) > 0;\r\n                        \r\n      setContentVisible(isVisible);\r\n      \r\n      // Log significant changes to visibility\r\n      if (contentVisible !== isVisible) {\r\n        console.log(`[AnimationContainer] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`, {\r\n          nodeId,\r\n          transformations: transformations.length,\r\n          animationState,\r\n          measurements: newMeasurements\r\n        });\r\n      }\r\n    };\r\n    \r\n    // Measure immediately\r\n    measureElement();\r\n    \r\n    // Measure after animations might be complete\r\n    const timer = setTimeout(measureElement, 1100);\r\n    \r\n    // Set up mutation observer to track DOM changes - with debouncing\r\n    let timeoutId: number | null = null;\r\n    const observer = new MutationObserver((mutations) => {\r\n      // Only log significant mutations to reduce noise\r\n      if (mutations.length > 2) {\r\n        console.log(`[AnimationContainer] DOM mutations detected: ${mutations.length}`);\r\n      }\r\n      \r\n      // Debounce measurements to prevent infinite loops\r\n      if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n      \r\n      timeoutId = window.setTimeout(() => {\r\n        measureElement();\r\n        timeoutId = null;\r\n      }, 500);\r\n    });\r\n    \r\n    observer.observe(containerRef.current, {\r\n      attributes: true,\r\n      childList: true,\r\n      subtree: false // Reduced to false to prevent excessive notifications\r\n    });\r\n    \r\n    return () => {\r\n      clearTimeout(timer);\r\n      observer.disconnect();\r\n    };\r\n  }, [nodeId, transformations, animationState, contentVisible]);\r\n  \r\n  // Determine which animation effect to apply based on transformation types\r\n  const getAnimationClass = () => {\r\n    if (animationState === 'idle') return '';\r\n    \r\n    const hasReplacements = transformations.some(t => t.type === 'replace');\r\n    const hasEmphasis = transformations.some(t => t.type === 'emphasize');\r\n    const hasExpansions = transformations.some(t => t.type === 'expand');\r\n    \r\n    if (animationState === 'entering') {\r\n      if (hasReplacements) return 'narramorph-container-replace-active';\r\n      if (hasEmphasis) return 'narramorph-container-emphasis-active';\r\n      if (hasExpansions) return 'narramorph-container-expand-active';\r\n      return 'narramorph-container-transform-active';\r\n    }\r\n    \r\n    return 'narramorph-container-active';\r\n  };\r\n  \r\n  // Get a description of transformation activity\r\n  const getTransformationDescription = () => {\r\n    if (transformations.length === 0) return '';\r\n    \r\n    const typeCount: Record<string, number> = {};\r\n    transformations.forEach(t => {\r\n      typeCount[t.type] = (typeCount[t.type] || 0) + 1;\r\n    });\r\n    \r\n    // Generate a description based on the types of transformations\r\n    const descriptions = [];\r\n    \r\n    if (typeCount['replace']) {\r\n      descriptions.push(`${typeCount['replace']} replacements`);\r\n    }\r\n    \r\n    if (typeCount['emphasize']) {\r\n      descriptions.push(`${typeCount['emphasize']} emphasis`);\r\n    }\r\n    \r\n    if (typeCount['expand']) {\r\n      descriptions.push(`${typeCount['expand']} expansions`);\r\n    }\r\n    \r\n    if (typeCount['fragment']) {\r\n      descriptions.push(`${typeCount['fragment']} fragmentations`);\r\n    }\r\n    \r\n    if (typeCount['metaComment']) {\r\n      descriptions.push(`${typeCount['metaComment']} comments`);\r\n    }\r\n    \r\n    return descriptions.join(', ');\r\n  };\r\n  \r\n  // Check if number of transformations has changed\r\n  const hasChangedTransformations = transformations.length !== transformationCount;\r\n  \r\n  // Log when animations are triggered\r\n  useEffect(() => {\r\n    if (isNewlyTransformed) {\r\n      console.log(`[AnimationContainer] Animation started for node: ${nodeId}`, {\r\n        transformations: transformations.length,\r\n        animationState,\r\n        contentVisible\r\n      });\r\n    }\r\n  }, [isNewlyTransformed, nodeId, transformations.length, animationState, contentVisible]);\r\n  \r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`narramorph-animation-container ${getAnimationClass()}`}\r\n      data-transformation-count={transformations.length}\r\n      data-newly-transformed={isNewlyTransformed}\r\n      data-animation-state={animationState}\r\n      data-visible={contentVisible}\r\n      data-render-attempt={renderAttempt}\r\n      style={{\r\n        overflow: 'visible',\r\n        minHeight: '150px',\r\n        position: 'relative', // Ensure positioning context\r\n        visibility: 'visible',\r\n        display: 'block',\r\n        opacity: 1\r\n      }}\r\n    >\r\n      {/* Visual indicator for active transformations */}\r\n      {transformations.length > 0 && (\r\n        <div \r\n          className={`narramorph-transformation-indicator ${isNewlyTransformed ? 'active' : ''}`}\r\n          title={getTransformationDescription()}\r\n        >\r\n          <span className=\"transformation-count\">{transformations.length}</span>\r\n          {hasChangedTransformations && (\r\n            <span className=\"transformation-change-indicator\">\r\n              {transformations.length > transformationCount ? '+' : ''}\r\n              {transformations.length - transformationCount}\r\n            </span>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content with transformations */}\r\n      <div\r\n        ref={contentRef}\r\n        className=\"narramorph-animation-content\"\r\n        style={{\r\n          position: 'relative',\r\n          visibility: 'visible',\r\n          display: 'block',\r\n          opacity: 1,\r\n          minHeight: '100px'\r\n        }}\r\n      >\r\n        {renderAttempt === 0 ? (\r\n          <div className=\"animation-placeholder\" style={{ padding: '20px', textAlign: 'center' }}>\r\n            <p>Preparing narrative...</p>\r\n          </div>\r\n        ) : (\r\n          children\r\n        )}\r\n      </div>\r\n      \r\n      {/* Debug info overlay - only in development */}\r\n      {process.env.NODE_ENV === 'development' && measurements && (\r\n        <div\r\n          className=\"animation-debug-info\"\r\n          style={{\r\n            position: 'absolute',\r\n            bottom: 0,\r\n            right: 0,\r\n            background: 'rgba(0,0,0,0.7)',\r\n            color: '#fff',\r\n            padding: '3px',\r\n            fontSize: '9px',\r\n            zIndex: 1000,\r\n            pointerEvents: 'none'\r\n          }}\r\n        >\r\n          <div>{`${Math.round(measurements.width)}x${Math.round(measurements.height)}`}</div>\r\n          <div>{`Vis:${measurements.visibility.charAt(0)}|Dis:${measurements.display.charAt(0)}`}</div>\r\n          <div>{`Op:${parseFloat(measurements.opacity).toFixed(1)}|Z:${measurements.zIndex}`}</div>\r\n          <div>{`T:${transformations.length}|S:${animationState.charAt(0)}`}</div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TransformationAnimationContainer;"],"names":["useNodeState","nodeId","dispatch","useDispatch","appliedTransformations","setAppliedTransformations","useState","newlyTransformed","setNewlyTransformed","appliedNodesRef","useRef","lastTransformationDispatchRef","currentNodeId","useSelector","selectCurrentNodeId","targetNodeId","node","state","selectNodeById","allNodes","revisitCount","selectNodeRevisitCount","readerState","navigateTo","useCallback","id","nodeData","navigateToNode","visitNode","setViewMode","revealNodeConnection","sourceId","targetId","revealConnection","engageWithAttractor","attractor","engageAttractor","applyNodeTransformation","transformation","applyTransformation","neighbors","useMemo","allTransformations","baseContent","transformations","transformationEngine","t","error","transformedContent","fullyTransformedContent","wrappedContent","transformationService","useEffect","timer","now","nodeKey","toKeep","key","applyJourneyTransformations","patternTransformations","patternBasedRule","evaluateTransformations","evaluateCondition","condition","TransformationAnimationContainer","children","isNewlyTransformed","containerRef","contentRef","animationState","setAnimationState","transformationCount","setTransformationCount","renderAttempt","setRenderAttempt","measurements","setMeasurements","contentVisible","setContentVisible","prev","useLayoutEffect","measureElement","style","rect","newMeasurements","isVisible","timeoutId","observer","mutations","getAnimationClass","hasReplacements","hasEmphasis","hasExpansions","getTransformationDescription","typeCount","descriptions","hasChangedTransformations","jsxs","jsx"],"mappings":"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"}