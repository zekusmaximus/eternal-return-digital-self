{"version":3,"mappings":"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","names":["ErrorBoundary","Component","props","error","errorInfo","isContentCorrupted","content","indicator","sanitizeDisplayContent","sanitized","line","SimpleTransformationContainer","children","transformations","nodeId","prevTransformationCount","setPrevTransformationCount","useState","isNewlyTransformed","setIsNewlyTransformed","transformationSignature","setTransformationSignature","useEffect","currentSignature","t","timer","getTransformationDescription","typeCount","descriptions","jsxs","jsx","SimpleTextRenderer","memo","onRenderComplete","onVisibilityChange","node","originalTransformedContent","appliedTransformations","useNodeState","processedContent","setProcessedContent","isVisible","setIsVisible","isLoading","setIsLoading","corruptionDetected","setCorruptionDetected","contentRef","useRef","observerRef","mutationObserverRef","renderCount","setRenderCount","useSelector","state","callbacksCalledRef","dispatch","useDispatch","_a","baseContent","recoverNodeContent","finalContent","validateNodeContent","prev","currentContentRef","currentObserver","mutationTimeout","mutations","mutation","target","computedStyle","hasMemory","performance","ReactMarkdown","lazy","__vitePreload","module","MiniConstellation","MarginaliaSidebar","NarramorphRendererPromise","NarramorphRenderer","remarkGfmPromise","ContentLoading","SideComponentLoading","NodeView","useAppDispatch","selectedNodeId","selectSelectedNodeId","viewMode","selectViewMode","selectNodeById","uniqueViewKey","useMemo","viewManager","useNarramorph","setUseNarramorph","useWebGLFallback","setUseWebGLFallback","forceSimpleRenderer","setForceSimpleRenderer","contentContainerRef","renderCompleteCalledRef","processedNodeRef","narramorphActivatedRef","lastVisitedIdRef","viewTransitionState","setViewTransitionState","memoryStats","setMemoryStats","useCallback","setContentDebug","contentDebug","isStillVisible","now","memory","loadNodeContent","contentLength","contentCorrupted","contentPreview","hasCurrentContent","componentLoaded","preBoundingRect","err","visibilityTimer","boundingRect","visitNode","synopsis","addVisitedNode","handleWebGLContextLoss","event","handleReturnToConstellation","returnToConstellation","characterClass","getTemporalClass","renderNodeContent","Suspense"],"ignoreList":[],"sources":["../../src/components/common/ErrorBoundary.tsx","../../src/utils/contentSanitizer.ts","../../src/components/NodeView/SimpleTransformationContainer.tsx","../../src/components/NodeView/SimpleTextRenderer.tsx","../../src/components/NodeView/NodeView.tsx"],"sourcesContent":["import { Component, ErrorInfo, ReactNode } from 'react';\r\n\r\ninterface Props {\r\n  children: ReactNode;\r\n  fallback: ReactNode;\r\n}\r\n\r\ninterface State {\r\n  hasError: boolean;\r\n  error: Error | null;\r\n}\r\n\r\n/**\r\n * ErrorBoundary component to catch and handle errors in its child components.\r\n * Provides a fallback UI when an error occurs.\r\n */\r\nclass ErrorBoundary extends Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.state = { \r\n      hasError: false,\r\n      error: null\r\n    };\r\n  }\r\n\r\n  static getDerivedStateFromError(error: Error): State {\r\n    // Update state so the next render will show the fallback UI\r\n    return { \r\n      hasError: true,\r\n      error: error\r\n    };\r\n  }\r\n\r\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\r\n    // Log the error to console\r\n    console.error('ErrorBoundary caught an error:', error);\r\n    console.error('Component stack:', errorInfo.componentStack);\r\n  }\r\n\r\n  render(): ReactNode {\r\n    if (this.state.hasError) {\r\n      // Render fallback UI\r\n      return this.props.fallback;\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\nexport default ErrorBoundary;","/**\r\n * Content Sanitizer Utility\r\n * \r\n * EMERGENCY FIX: Prevents recursive transformation cascade by cleaning content\r\n * before applying new transformations and sanitizing output for display.\r\n */\r\n\r\n/**\r\n * Cleans content of all transformation markup to return to original text\r\n * This prevents recursive application of transformations to already-transformed content\r\n */\r\nexport function stripTransformationMarkup(content: string): string {\r\n  if (!content) return '';\r\n  \r\n  try {\r\n    let cleanContent = content;\r\n    \r\n    // Remove all span elements with transformation classes\r\n    cleanContent = cleanContent.replace(\r\n      /<span[^>]*class=\"[^\"]*(?:glitch-text|text-transformation|narramorph-|text-emphasis|text-expanded|text-fragmented|text-commented|text-replaced)[^\"]*\"[^>]*>(.*?)<\\/span>/gs,\r\n      '$1'\r\n    );\r\n    \r\n    // Remove data attributes that indicate transformations\r\n    cleanContent = cleanContent.replace(\r\n      /<span[^>]*data-transform-type=\"[^\"]*\"[^>]*>(.*?)<\\/span>/gs,\r\n      '$1'\r\n    );\r\n    \r\n    // Remove perspective shift markers\r\n    cleanContent = cleanContent.replace(\r\n      /perspective shift:\\s*\\w+\\s*→\\s*\\w+/g,\r\n      ''\r\n    );\r\n    \r\n    // Remove system markers and debug text\r\n    cleanContent = cleanContent.replace(\r\n      /\\[(?:PATTERN_DETECTED|ANALYSIS_COMPLETE|DATA_INTEGRITY|TEMPORAL_MARKER)[^[\\]]*\\]/g,\r\n      ''\r\n    );\r\n    \r\n    // Remove malformed spans that indicate corruption\r\n    cleanContent = cleanContent.replace(\r\n      /<<\\*\\*span\\*\\*[^>]*>/g,\r\n      ''\r\n    );\r\n    \r\n    // Remove strikethrough Unicode combining characters\r\n    cleanContent = cleanContent.replace(/̶/g, '');\r\n    \r\n    // Remove empty elements and excessive whitespace\r\n    cleanContent = cleanContent.replace(/<[^>]*><\\/[^>]*>/g, '');\r\n    cleanContent = cleanContent.replace(/\\s+/g, ' ');\r\n    cleanContent = cleanContent.trim();\r\n    \r\n    console.log(`[ContentSanitizer] Cleaned content: ${content.length} → ${cleanContent.length} characters`);\r\n    return cleanContent;\r\n    \r\n  } catch (error) {\r\n    console.error('[ContentSanitizer] Error cleaning content:', error);\r\n    return content; // Return original if cleaning fails\r\n  }\r\n}\r\n\r\n/**\r\n * Validates if content has been corrupted by transformation cascade\r\n */\r\nexport function isContentCorrupted(content: string): boolean {\r\n  if (!content) return true;\r\n  \r\n  const corruptionIndicators = [\r\n    content.includes('[object Object]'),\r\n    content.includes('undefined'),\r\n    content.includes('<span class=\"glitch-text\"><span class=\"glitch-text\">'), // Nested spans\r\n    content.match(/<<\\*\\*span\\*\\*/g), // Malformed HTML\r\n    content.length < 10, // Too short\r\n    content.split('<span').length > 10, // Too many spans\r\n  ];\r\n  \r\n  return corruptionIndicators.some(indicator => indicator);\r\n}\r\n\r\n/**\r\n * Sanitizes final output for display by removing any remaining markup leakage\r\n */\r\nexport function sanitizeDisplayContent(content: string): string {\r\n  if (!content) return '';\r\n  \r\n  try {\r\n    let sanitized = content;\r\n    \r\n    // Remove any remaining transformation markers\r\n    sanitized = sanitized.replace(/\\*#\\s*/g, '');\r\n    \r\n    // Clean up multiple consecutive spaces\r\n    sanitized = sanitized.replace(/\\s{2,}/g, ' ');\r\n    \r\n    // Remove leading/trailing whitespace from lines\r\n    sanitized = sanitized.split('\\n').map(line => line.trim()).join('\\n');\r\n    \r\n    // Remove empty lines caused by removed markers\r\n    sanitized = sanitized.replace(/\\n\\s*\\n\\s*\\n/g, '\\n\\n');\r\n    \r\n    return sanitized.trim();\r\n    \r\n  } catch (error) {\r\n    console.error('[ContentSanitizer] Error sanitizing display content:', error);\r\n    return content;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a unique transformation ID for tracking applied transformations\r\n */\r\nexport function generateTransformationId(transformation: {\r\n  type: string;\r\n  selector?: string;\r\n  priority?: string;\r\n}): string {\r\n  return `${transformation.type}-${transformation.selector?.substring(0, 20) || 'unknown'}-${transformation.priority || 'medium'}`;\r\n}\r\n\r\n/**\r\n * Checks if a transformation has already been applied to content\r\n */\r\nexport function hasTransformationBeenApplied(\r\n  appliedIds: string[],\r\n  transformationId: string\r\n): boolean {\r\n  return appliedIds.includes(transformationId);\r\n}\r\n","/**\r\n * SimpleTransformationContainer Component\r\n * \r\n * A lightweight, reliable container for text transformations.\r\n * This is a simplified version of TransformationAnimationContainer\r\n * that prioritizes stability and content visibility over complex effects.\r\n */\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { TextTransformation } from '../../types';\r\n\r\ninterface SimpleTransformationContainerProps {\r\n  children: React.ReactNode;\r\n  transformations: TextTransformation[];\r\n  nodeId: string;\r\n}\r\n\r\nconst SimpleTransformationContainer: React.FC<SimpleTransformationContainerProps> = ({\r\n  children,\r\n  transformations,\r\n  nodeId\r\n}) => {  // Track previous transformation count to detect changes\r\n  const [prevTransformationCount, setPrevTransformationCount] = useState(0);\r\n  const [isNewlyTransformed, setIsNewlyTransformed] = useState(false);\r\n  const [transformationSignature, setTransformationSignature] = useState('');\r\n  \r\n  // When transformations change, update state to show indicators\r\n  useEffect(() => {\r\n    // Create a signature to detect actual transformation changes, not just count changes\r\n    const currentSignature = transformations\r\n      .map(t => `${t.type}-${t.selector || 'no-selector'}-${JSON.stringify(t)}`)\r\n      .sort()\r\n      .join('|');\r\n    \r\n    if (currentSignature !== transformationSignature) {\r\n      // Detect if new transformations were added\r\n      if (transformations.length > prevTransformationCount) {\r\n        setIsNewlyTransformed(true);\r\n        \r\n        // Reset the newly transformed flag after animations would complete\r\n        const timer = setTimeout(() => {\r\n          setIsNewlyTransformed(false);\r\n        }, 2000);\r\n        \r\n        // Update state\r\n        setPrevTransformationCount(transformations.length);\r\n        setTransformationSignature(currentSignature);\r\n        \r\n        return () => clearTimeout(timer);\r\n      } else {\r\n        // Just update tracking without animation if count didn't increase\r\n        setPrevTransformationCount(transformations.length);\r\n        setTransformationSignature(currentSignature);\r\n      }\r\n    }\r\n  }, [transformations, transformationSignature, prevTransformationCount]);\r\n  \r\n  // Get a description of transformation activity for tooltip\r\n  const getTransformationDescription = () => {\r\n    if (transformations.length === 0) return '';\r\n    \r\n    const typeCount: Record<string, number> = {};\r\n    transformations.forEach(t => {\r\n      typeCount[t.type] = (typeCount[t.type] || 0) + 1;\r\n    });\r\n    \r\n    // Generate a description based on the types of transformations\r\n    const descriptions = [];\r\n    \r\n    if (typeCount['replace']) {\r\n      descriptions.push(`${typeCount['replace']} replacements`);\r\n    }\r\n    \r\n    if (typeCount['emphasize']) {\r\n      descriptions.push(`${typeCount['emphasize']} emphasis`);\r\n    }\r\n    \r\n    if (typeCount['expand']) {\r\n      descriptions.push(`${typeCount['expand']} expansions`);\r\n    }\r\n    \r\n    if (typeCount['fragment']) {\r\n      descriptions.push(`${typeCount['fragment']} fragmentations`);\r\n    }\r\n    \r\n    if (typeCount['metaComment']) {\r\n      descriptions.push(`${typeCount['metaComment']} comments`);\r\n    }\r\n    \r\n    return descriptions.join(', ');\r\n  };\r\n  \r\n  return (\r\n    <div \r\n      className={`simple-transformation-container ${isNewlyTransformed ? 'newly-transformed' : ''}`}\r\n      data-transformation-count={transformations.length}\r\n      data-node-id={nodeId}\r\n    >\r\n      {/* Visual indicator for active transformations - much simpler than the complex version */}\r\n      {transformations.length > 0 && (\r\n        <div \r\n          className={`transformation-indicator ${isNewlyTransformed ? 'active' : ''}`}\r\n          title={getTransformationDescription()}\r\n        >\r\n          <span className=\"transformation-count\">{transformations.length}</span>\r\n          {isNewlyTransformed && transformations.length > prevTransformationCount && (\r\n            <span className=\"transformation-change\">\r\n              +{transformations.length - prevTransformationCount}\r\n            </span>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {/* Main content */}\r\n      <div className=\"simple-transformation-content\">\r\n        {children}\r\n      </div>\r\n      \r\n      {/* Optional overlay for transition effects */}\r\n      {isNewlyTransformed && (\r\n        <div \r\n          className=\"transformation-overlay\"\r\n          aria-hidden=\"true\"\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SimpleTransformationContainer;","/**\r\n * SimpleTextRenderer Component\r\n * \r\n * A lightweight, reliable alternative to the NarramorphRenderer\r\n * that prioritizes stability and content visibility over visual effects.\r\n * \r\n * This component:\r\n * 1. Renders node content with minimal dependencies\r\n * 2. Uses pure React/DOM rendering without WebGL\r\n * 3. Maintains proper text display even when resources are constrained\r\n * 4. Provides graceful fallbacks and simplified transformations\r\n * 5. EMERGENCY FIX: Prevents and recovers from content corruption\r\n */\r\n\r\nimport React, { useEffect, useState, useRef, memo } from 'react';\r\nimport { useNodeState } from '../../hooks/useNodeState';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport { RootState } from '../../store/types';\r\nimport { recoverNodeContent, validateNodeContent } from '../../store/slices/nodesSlice';\r\nimport { isContentCorrupted, sanitizeDisplayContent } from '../../utils/contentSanitizer';\r\nimport '../../styles/NarramorphTransformations.css';\r\nimport '../../styles/SimpleTextRenderer.css';\r\nimport SimpleTransformationContainer from './SimpleTransformationContainer';\r\n\r\ninterface SimpleTextRendererProps {\r\n  nodeId?: string;\r\n  onRenderComplete?: () => void;\r\n  onVisibilityChange?: (isVisible: boolean) => void;\r\n}\r\n\r\n// Main renderer component\r\nconst SimpleTextRenderer: React.FC<SimpleTextRendererProps> = memo(({\r\n  nodeId,\r\n  onRenderComplete,\r\n  onVisibilityChange\r\n}) => {\r\n  const {\r\n    node,\r\n    transformedContent: originalTransformedContent,\r\n    appliedTransformations\r\n  } = useNodeState(nodeId);\r\n    const [processedContent, setProcessedContent] = useState<string>('');\r\n  const [isVisible, setIsVisible] = useState(true);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [corruptionDetected, setCorruptionDetected] = useState(false);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const observerRef = useRef<IntersectionObserver | null>(null);\r\n  const mutationObserverRef = useRef<MutationObserver | null>(null);\r\n  \r\n  // Track rendering metrics\r\n  const [renderCount, setRenderCount] = useState(0);\r\n  \r\n  // Get reading path from reader state\r\n  const readingPath = useSelector((state: RootState) => state.reader.path);\r\n    // Track if callbacks have been called to prevent infinite loops\r\n  const callbacksCalledRef = useRef(false);\r\n  const dispatch = useDispatch();\r\n    // EMERGENCY CONTENT RECOVERY: Process transformations with corruption detection\r\n  useEffect(() => {\r\n    if (node?.currentContent || node?.originalContent) {\r\n      console.log(`[SimpleTextRenderer] Processing content for node: ${node.id}, length: ${(node.originalContent || node.currentContent)?.length}`);\r\n      setIsLoading(true);\r\n      setCorruptionDetected(false);\r\n      \r\n      try {\r\n        // EMERGENCY FIX: Use original content if available\r\n        const baseContent = node.originalContent || node.currentContent || '';\r\n        \r\n        // Check for corruption in the content we're about to process\r\n        if (isContentCorrupted(baseContent)) {\r\n          console.error(`[SimpleTextRenderer] Content corruption detected for node ${node.id}:`, {\r\n            contentLength: baseContent.length,\r\n            contentPreview: baseContent.substring(0, 100)\r\n          });\r\n          \r\n          setCorruptionDetected(true);\r\n          \r\n          // Try to recover from original content\r\n          if (node.originalContent && node.originalContent !== baseContent) {\r\n            console.log(`[SimpleTextRenderer] Attempting content recovery for node ${node.id}`);\r\n            dispatch(recoverNodeContent(node.id));\r\n            return; // Exit and let the recovery trigger a re-render\r\n          } else {\r\n            // Show fallback content\r\n            setProcessedContent('⚠️ Content temporarily unavailable. Please refresh to restore.');\r\n            setIsLoading(false);\r\n            return;\r\n          }\r\n        }\r\n        \r\n        // Either use the transformed content from useNodeState or process it ourselves\r\n        const content = originalTransformedContent || baseContent;\r\n        \r\n        // Apply final sanitization to remove any remaining corruption markers\r\n        const finalContent = sanitizeDisplayContent(content);\r\n        \r\n        console.log(`[SimpleTextRenderer] Content processing complete for node ${node.id}:`, {\r\n          originalLength: baseContent.length,\r\n          transformedLength: content.length,\r\n          finalLength: finalContent.length,\r\n          appliedTransformations: appliedTransformations.length,\r\n          usingOriginalContent: !!node.originalContent\r\n        });\r\n        \r\n        setProcessedContent(finalContent);\r\n        \r\n        // Validate content integrity\r\n        dispatch(validateNodeContent(node.id));\r\n        \r\n        // Increment render count for monitoring\r\n        setRenderCount(prev => prev + 1);\r\n        \r\n        // Immediately mark as not loading and visible\r\n        setIsLoading(false);\r\n        setIsVisible(true);\r\n        \r\n        // Only call callbacks once per content change to prevent infinite loops\r\n        if (!callbacksCalledRef.current) {\r\n          callbacksCalledRef.current = true;\r\n          \r\n          // Signal render completion if callback provided\r\n          if (onRenderComplete) {\r\n            console.log(`[SimpleTextRenderer] Render complete for node: ${node.id}`);\r\n            // Reduced delay to minimize possibility of content flickering\r\n            setTimeout(onRenderComplete, 10);\r\n          }\r\n          \r\n          // Ensure parent knows content is visible\r\n          if (onVisibilityChange) {\r\n            console.log(`[SimpleTextRenderer] Explicitly marking content as visible`);\r\n            onVisibilityChange(true);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`[SimpleTextRenderer] Error processing content:`, error);\r\n        setCorruptionDetected(true);\r\n        setProcessedContent('❌ Content processing error. Please refresh to restore.');\r\n        setIsLoading(false);\r\n      }\r\n    }  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [node?.currentContent, node?.originalContent, node?.id, originalTransformedContent, dispatch]);\r\n\r\n  // Reset callback flag when node changes\r\n  useEffect(() => {\r\n    callbacksCalledRef.current = false;\r\n  }, [node?.id]);\r\n  // Set up visibility observer with simplified reliable detection\r\n  useEffect(() => {\r\n    const currentContentRef = contentRef.current;\r\n    const currentObserver = observerRef.current;\r\n    if (!currentContentRef) return;\r\n    \r\n    console.log(`[DEBUG] Setting up IntersectionObserver for node: ${node?.id}, current visibility: ${isVisible}`);\r\n    \r\n    // Clean up previous observer\r\n    if (currentObserver) {\r\n      currentObserver.disconnect();\r\n    }\r\n    \r\n    // Force visibility to true initially - BUGFIX\r\n    if (!isVisible) {\r\n      console.log(`[DEBUG] Forcing initial visibility to true for node: ${node?.id}`);\r\n      setIsVisible(true);\r\n      \r\n      // Only notify parent component if callback provided and callbacks haven't been called\r\n      if (onVisibilityChange && !callbacksCalledRef.current) {\r\n        onVisibilityChange(true);\r\n      }\r\n    }\r\n    \r\n    // DISABLE INTERSECTION OBSERVER TO PREVENT INFINITE LOOPS\r\n    // The intersection observer was causing render loops, so we'll just assume content is always visible\r\n    console.log(`[DEBUG] Skipping IntersectionObserver setup to prevent infinite loops for node: ${node?.id}`);\r\n    \r\n    // Cleanup function\r\n    return () => {\r\n      console.log(`[DEBUG] Cleaning up IntersectionObserver for node: ${node?.id}`);\r\n      if (currentObserver) {\r\n        currentObserver.disconnect();\r\n      }    };\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [node?.id, isVisible]); // Removed onVisibilityChange to prevent infinite loops\r\n  // Set up MutationObserver to prevent style changes that would hide content\r\n  useEffect(() => {\r\n    const currentContentRef = contentRef.current;\r\n    if (!currentContentRef) return;\r\n    \r\n    console.log(`[DEBUG] Setting up MutationObserver for node: ${node?.id}`);\r\n    \r\n    // Clean up previous observer\r\n    if (mutationObserverRef.current) {\r\n      mutationObserverRef.current.disconnect();\r\n    }\r\n    \r\n    // Create mutation observer with reduced frequency to prevent infinite loops\r\n    let mutationTimeout: number | null = null;\r\n    \r\n    mutationObserverRef.current = new MutationObserver((mutations) => {\r\n      // Debounce mutations to prevent excessive calls\r\n      if (mutationTimeout) {\r\n        clearTimeout(mutationTimeout);\r\n      }\r\n      \r\n      mutationTimeout = window.setTimeout(() => {\r\n        mutations.forEach((mutation) => {\r\n          if (mutation.type === 'attributes' &&\r\n              (mutation.attributeName === 'style' ||\r\n               mutation.attributeName === 'class' ||\r\n               mutation.attributeName === 'display' ||\r\n               mutation.attributeName === 'visibility' ||\r\n               mutation.attributeName === 'opacity')) {\r\n            \r\n            const target = mutation.target as HTMLElement;\r\n            const computedStyle = window.getComputedStyle(target);\r\n            \r\n            console.log(`[DEBUG] Style mutation detected on ${target.tagName}#${target.id}.${target.className}:`, {\r\n              display: computedStyle.display,\r\n              visibility: computedStyle.visibility,\r\n              opacity: computedStyle.opacity\r\n            });\r\n            \r\n            // If any change would hide the content, force it back to visible\r\n            if (computedStyle.display === 'none' ||\r\n                computedStyle.visibility === 'hidden' ||\r\n                parseFloat(computedStyle.opacity) === 0) {\r\n              \r\n              console.warn(`[DEBUG] Preventing content from being hidden by style mutation`);\r\n              \r\n              // Force visibility\r\n              target.style.display = target.style.display === 'none' ? 'block' : target.style.display;\r\n              target.style.visibility = target.style.visibility === 'hidden' ? 'visible' : target.style.visibility;\r\n              target.style.opacity = parseFloat(target.style.opacity) === 0 ? '1' : target.style.opacity;\r\n              \r\n              // Only notify parent if this is the main content element and callbacks haven't been called\r\n              if (target === currentContentRef && onVisibilityChange && !callbacksCalledRef.current) {\r\n                console.log(`[DEBUG] Notifying parent that content is still visible after mutation`);\r\n                onVisibilityChange(true);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }, 100); // Debounce mutations by 100ms\r\n    });\r\n    \r\n    // Observe the content element and its children with reduced scope\r\n    mutationObserverRef.current.observe(currentContentRef, {\r\n      attributes: true,\r\n      attributeFilter: ['style', 'class'],\r\n      childList: false, // Reduce scope to prevent excessive mutations\r\n      subtree: false,   // Don't observe subtree to reduce noise\r\n    });\r\n      // Cleanup function\r\n    return () => {\r\n      console.log(`[DEBUG] Cleaning up MutationObserver for node: ${node?.id}`);\r\n      if (mutationTimeout) {\r\n        clearTimeout(mutationTimeout);\r\n      }\r\n      mutationObserverRef.current?.disconnect();    };\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [node?.id]); // Removed onVisibilityChange to prevent infinite loops\r\n  \r\n  // Render empty state if no content\r\n  if (!node || !node.currentContent) {\r\n    return <div className=\"simple-renderer-loading\">Loading narrative content...</div>;\r\n  }\r\n  \r\n  // Render with simpler container\r\n  return (\r\n    <div\r\n      className={`simple-renderer-container ${isVisible ? 'is-visible' : ''}`}\r\n      data-node-id={node.id}\r\n      data-render-count={renderCount}\r\n      style={{\r\n        display: 'block',\r\n        visibility: 'visible',\r\n        position: 'relative',\r\n        minHeight: '200px'\r\n      }}\r\n    >      <SimpleTransformationContainer\r\n        transformations={appliedTransformations}\r\n        nodeId={node.id}\r\n      >\r\n        {isLoading && (\r\n          <div className=\"simple-renderer-loading\" style={{ padding: '20px 0' }}>\r\n            <div className=\"loading-spinner\"></div>\r\n            <p>Preparing narrative content...</p>\r\n          </div>\r\n        )}\r\n        \r\n        {corruptionDetected && (\r\n          <div className=\"content-corruption-warning\" style={{ \r\n            padding: '15px', \r\n            margin: '10px 0', \r\n            backgroundColor: '#fff3cd', \r\n            border: '1px solid #ffeeba', \r\n            borderRadius: '4px', \r\n            color: '#856404' \r\n          }}>\r\n            <strong>⚠️ Content Recovery Mode</strong>\r\n            <p>Content corruption detected. Attempting recovery...</p>\r\n          </div>\r\n        )}\r\n        \r\n        <div\r\n          ref={contentRef}\r\n          className=\"simple-renderer-content\"\r\n          data-transformations-count={appliedTransformations.length}\r\n          data-corruption-detected={corruptionDetected}\r\n          style={{\r\n            display: 'block',\r\n            visibility: 'visible',\r\n            opacity: corruptionDetected ? 0.7 : 1\r\n          }}\r\n        >\r\n          <div\r\n            dangerouslySetInnerHTML={{ __html: processedContent }}\r\n            className=\"content-inner\"\r\n          />\r\n        </div>\r\n      </SimpleTransformationContainer>\r\n        {/* Debug information */}\r\n      {process.env.NODE_ENV === 'development' && (\r\n        <div className=\"simple-renderer-debug\">\r\n          <div className=\"debug-info\">\r\n            <span>Node: {node.id}</span>\r\n            <span>Transformations: {appliedTransformations.length}</span>\r\n            <span>Renders: {renderCount}</span>\r\n            <span>Path Length: {readingPath.sequence.length}</span>\r\n            <span>Visibility: {isVisible ? 'Visible' : 'Hidden'}</span>\r\n            <span>Journey Context: {node.journeyContext ? 'Active' : 'None'}</span>\r\n            {node.journeyContext && (\r\n              <>\r\n                <span>Last Character: {node.journeyContext.lastVisitedCharacter || 'None'}</span>\r\n                <span>Character Bleed: {\r\n                  appliedTransformations.some(t => \r\n                    t.type === 'fragment' || t.type === 'emphasize' && t.intensity && t.intensity > 3\r\n                  ) ? 'Yes' : 'No'\r\n                }</span>\r\n              </>\r\n            )}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default SimpleTextRenderer;\r\n","// src/components/NodeView/NodeView.tsx\r\n\r\nimport { useEffect, useState, lazy, Suspense, useRef, useMemo, useCallback } from 'react';\r\nimport ErrorBoundary from '../common/ErrorBoundary';\r\nimport SimpleTextRenderer from './SimpleTextRenderer';\r\nimport { viewManager } from '../../services/ViewManager';\r\nimport { useSelector } from 'react-redux';\r\nimport {\r\n  selectSelectedNodeId,\r\n  returnToConstellation,\r\n  selectViewMode,\r\n} from '../../store/slices/interfaceSlice';\r\nimport { loadNodeContent, selectNodeById, visitNode, validateNodeContent, recoverNodeContent } from '../../store/slices/nodesSlice';\r\nimport { useAppDispatch } from '../../store/hooks';\r\nimport { addVisitedNode } from '../../store/slices/readerSlice';\r\nimport './NodeView.css';\r\nimport '../common/ErrorStyles.css'; // Import error and debug styles\r\nimport { RootState } from '../../store';\r\n\r\n// Define interface for the non-standard performance.memory API\r\ninterface MemoryInfo {\r\n  jsHeapSizeLimit: number;\r\n  totalJSHeapSize: number;\r\n  usedJSHeapSize: number;\r\n}\r\n\r\n// Extend Performance interface\r\ninterface ExtendedPerformance extends Performance {\r\n  memory?: MemoryInfo;\r\n}\r\n\r\n// Type guard for memory property\r\nfunction hasMemory(performance: Performance): performance is ExtendedPerformance {\r\n  return 'memory' in performance;\r\n}\r\n\r\n// Dynamically import heavy components with loading tracking\r\nconst ReactMarkdown = lazy(() => {\r\n  console.log('[NodeView] Loading ReactMarkdown component');\r\n  return import('react-markdown').then(module => {\r\n    console.log('[NodeView] ReactMarkdown component loaded');\r\n    return module;\r\n  });\r\n});\r\n\r\nconst MiniConstellation = lazy(() => import('./MiniConstellation'));\r\nconst MarginaliaSidebar = lazy(() => import('./MarginaliaSidebar'));\r\n\r\n// Pre-load NarramorphRenderer to avoid race conditions with content loading\r\nconst NarramorphRendererPromise = import('./NarramorphRenderer');\r\nconst NarramorphRenderer = lazy(() => {\r\n  console.log('[NodeView] Loading NarramorphRenderer component');\r\n  return NarramorphRendererPromise.then(module => {\r\n    console.log('[NodeView] NarramorphRenderer component loaded');\r\n    return module;\r\n  });\r\n});\r\n\r\n// Dynamically import remark plugin with loading tracking\r\nconst remarkGfmPromise = import('remark-gfm').then(module => {\r\n  console.log('[NodeView] remark-gfm plugin loaded');\r\n  return module.default;\r\n});\r\n\r\n// Loading components\r\nconst ContentLoading = () => (\r\n  <div className=\"content-loading\">\r\n    <div className=\"loading-spinner\"></div>\r\n    <p>Loading content...</p>\r\n  </div>\r\n);\r\n\r\nconst SideComponentLoading = () => <div className=\"side-component-loading\"></div>;\r\n\r\nconst NodeView = () => {\r\n  const dispatch = useAppDispatch();\r\n  const selectedNodeId = useSelector(selectSelectedNodeId);\r\n  const viewMode = useSelector(selectViewMode);\r\n  const node = useSelector((state: RootState) => selectedNodeId ? selectNodeById(state, selectedNodeId) : null);\r\n  // Extract stable primitives for hooks\r\n\r\n  // Get unique view key from ViewManager to force proper unmount/remount\r\n  const uniqueViewKey = useMemo(() => viewManager.getUniqueViewKey(), []);\r\n\r\n  // State to control transition between ReactMarkdown and NarramorphRenderer\r\n  const [useNarramorph, setUseNarramorph] = useState(false);\r\n  \r\n  // Add fallback state for handling WebGL context loss\r\n  const [useWebGLFallback, setUseWebGLFallback] = useState(false);\r\n  \r\n  // Track if simple renderer has been forced\r\n  const [forceSimpleRenderer, setForceSimpleRenderer] = useState(true); // FORCE SIMPLE RENDERER TO STOP INFINITE LOOPS\r\n  \r\n  // Track if WebGL is available for this view (determined by context manager)\r\n  const webGLAvailable = true;\r\n  \r\n  // Reference to content container for visibility debugging\r\n  const contentContainerRef = useRef<HTMLDivElement>(null);\r\n  const renderCompleteCalledRef = useRef(false);\r\n  const processedNodeRef = useRef<string | null>(null);\r\n  const narramorphActivatedRef = useRef(false);\r\n  // Track last visited node ID to ensure breadcrumb effect runs once per distinct node\r\n  const lastVisitedIdRef = useRef<string | null>(null);\r\n\r\n  // Create a state to track view transitions\r\n  const [viewTransitionState, setViewTransitionState] = useState({\r\n    transitionTime: Date.now(),\r\n    lastViewMode: viewMode,\r\n    transitionCount: 0,\r\n    renderCount: 0\r\n  });\r\n  \r\n  // Track memory usage\r\n  const [memoryStats, setMemoryStats] = useState({\r\n    jsHeapSizeLimit: 0,\r\n    totalJSHeapSize: 0,\r\n    usedJSHeapSize: 0,\r\n    timestamp: 0\r\n  });\r\n\r\n  // Define onVisibilityChange using useCallback\r\n  const onVisibilityChange = useCallback((isVisible: boolean) => {\r\n    console.log(`[NodeView] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`);\r\n\r\n    // BUGFIX: If visibility changes to hidden, force it back to visible\r\n    if (!isVisible && contentContainerRef.current) {\r\n      console.warn('[NodeView] Forcing content visibility after hidden state detected');\r\n      contentContainerRef.current.style.display = 'block';\r\n      contentContainerRef.current.style.visibility = 'visible';\r\n      contentContainerRef.current.style.opacity = '1';\r\n\r\n      // Don't update debug state to indicate an issue\r\n      return;\r\n    }\r\n\r\n    // Only update debug state once to prevent render loops\r\n    if (!renderCompleteCalledRef.current) {\r\n      setContentDebug(prev => ({ ...prev, visibilityIssue: !isVisible }));\r\n    }\r\n  }, []);\r\n  \r\n  // Debug state to track content status\r\n  const [contentDebug, setContentDebug] = useState({\r\n    loadStarted: false,\r\n    contentLoaded: false,\r\n    renderStarted: false,\r\n    narramorphActivated: false,\r\n    visibilityIssue: false,\r\n    errorOccurred: false\r\n  });\r\n\r\n  // Define onRenderComplete using useCallback to memoize it\r\n  const onRenderComplete = useCallback(() => {\r\n    // Prevent multiple calls to this function\r\n    if (renderCompleteCalledRef.current) {\r\n      console.log('[NodeView] Skipping duplicate onRenderComplete call');\r\n      return;\r\n    }\r\n    \r\n    renderCompleteCalledRef.current = true;\r\n    console.log('[NodeView] SimpleTextRenderer completed rendering');\r\n\r\n    // BUGFIX: Ensure content remains visible after render\r\n    if (contentContainerRef.current) {\r\n      console.log('[NodeView] Forcing container visibility after render complete');\r\n      contentContainerRef.current.style.display = 'block';\r\n      contentContainerRef.current.style.visibility = 'visible';\r\n      contentContainerRef.current.style.opacity = '1';\r\n    }\r\n\r\n    setContentDebug(prev => ({ ...prev, visibilityIssue: false }));\r\n\r\n    // BUGFIX: Set a verification check after render\r\n    setTimeout(() => {\r\n      if (contentContainerRef.current) {\r\n        const isStillVisible =\r\n          contentContainerRef.current.offsetParent !== null &&\r\n          window.getComputedStyle(contentContainerRef.current).display !== 'none' &&\r\n          window.getComputedStyle(contentContainerRef.current).visibility !== 'hidden';\r\n\r\n        console.log(`[NodeView] Post-render visibility check: ${isStillVisible ? 'visible' : 'not visible'}`);\r\n\r\n        if (!isStillVisible) {\r\n          console.warn('[NodeView] Content became invisible after render - forcing visibility');\r\n          contentContainerRef.current.style.display = 'block';\r\n          contentContainerRef.current.style.visibility = 'visible';\r\n          contentContainerRef.current.style.opacity = '1';\r\n        }\r\n      }\r\n    }, 500);\r\n  }, []);\r\n\r\n  // Reset callback flags when node changes\r\n  useEffect(() => {\r\n    if (selectedNodeId !== processedNodeRef.current) {\r\n      renderCompleteCalledRef.current = false;\r\n      processedNodeRef.current = selectedNodeId;\r\n      narramorphActivatedRef.current = false;\r\n    }\r\n  }, [selectedNodeId]);\r\n\r\n  // Effect to track view transitions and manage render count\r\n  useEffect(() => {\r\n    if (viewTransitionState.lastViewMode !== viewMode) {\r\n      const now = Date.now();\r\n      console.log(`[NodeView] View transition: ${viewTransitionState.lastViewMode} -> ${viewMode} at ${now}`);\r\n      \r\n      setViewTransitionState(prev => ({\r\n        ...prev,\r\n        lastViewMode: viewMode,\r\n        transitionTime: now,\r\n        transitionCount: prev.transitionCount + 1,\r\n        renderCount: prev.renderCount + 1\r\n      }));\r\n      \r\n      // Reset content debug state on transition\r\n      setContentDebug(prev => ({\r\n        ...prev,\r\n        loadStarted: false,\r\n        contentLoaded: false,\r\n        renderStarted: false,\r\n        narramorphActivated: false,\r\n        visibilityIssue: false,\r\n        errorOccurred: false\r\n      }));\r\n      \r\n      // Collect memory stats on transition\r\n      if (hasMemory(performance) && performance.memory) {\r\n        const memory = performance.memory;\r\n        setMemoryStats({\r\n          jsHeapSizeLimit: memory.jsHeapSizeLimit,\r\n          totalJSHeapSize: memory.totalJSHeapSize,\r\n          usedJSHeapSize: memory.usedJSHeapSize,\r\n          timestamp: now\r\n        });\r\n      }\r\n    } else {\r\n      // Increment render count on each render without transition\r\n      setViewTransitionState(prev => ({\r\n        ...prev,\r\n        renderCount: prev.renderCount + 1\r\n      }));\r\n    }\r\n  }, [viewMode, viewTransitionState.lastViewMode]);\r\n  \r\n  // Effect to load content if needed - CRITICAL FIX to prevent infinite loops\r\n  useEffect(() => {\r\n    // Only check if we need to load content, don't depend on the content itself\r\n    const needsContent = selectedNodeId && !node?.content;\r\n    if (needsContent) {\r\n      console.log(`[NodeView] Loading content for node: ${selectedNodeId}`, {\r\n        viewMode\r\n      });\r\n      setContentDebug(prev => ({ ...prev, loadStarted: true }));\r\n      dispatch(loadNodeContent(selectedNodeId));\r\n    }\r\n  }, [selectedNodeId, dispatch, viewMode, node?.content]);\r\n\r\n  // Create stable values for dependencies to prevent hook warnings\r\n  const contentLength = node?.currentContent?.length || 0;\r\n  \r\n  // Create stable derived values to avoid dependency on full content string\r\n  const contentCorrupted = useMemo(() => {\r\n    if (!node?.currentContent) return false;\r\n    return (\r\n      node.currentContent.includes('[object Object]') ||\r\n      node.currentContent.includes('undefined') ||\r\n      node.currentContent.length < 10\r\n    );\r\n  }, [node?.currentContent]);\r\n  \r\n  const contentPreview = useMemo(() => {\r\n    return node?.currentContent?.substring(0, 50) || 'NO CONTENT';\r\n  }, [node?.currentContent]);\r\n\r\n\r\n  // Separate effect for content loaded debugging - SIMPLIFIED to prevent loops\r\n  useEffect(() => {\r\n    if (node?.id && processedNodeRef.current === selectedNodeId) {\r\n      const hasCurrentContent = contentLength > 0; // Use contentLength instead of !!node.currentContent\r\n      \r\n      console.log(`[NodeView] Content processed for node: ${selectedNodeId}`, {\r\n        hasContent: hasCurrentContent,\r\n        visitCount: node.visitCount,\r\n        contentLength,\r\n        contentPreview, // Use the stable derived value\r\n        enhancedContentExists: !!node.enhancedContent,\r\n        contentExists: !!node.content\r\n      });\r\n      \r\n      setContentDebug(prev => ({ ...prev, contentLoaded: hasCurrentContent }));\r\n      \r\n      // Use the stable derived value for corruption check\r\n      if (hasCurrentContent && contentCorrupted) {\r\n        console.error(`[NodeView] Possible content corruption detected:`, {\r\n          contentStart: contentPreview,\r\n          contentLength\r\n        });\r\n      }\r\n    }\r\n  }, [\r\n    selectedNodeId, \r\n    node?.id, \r\n    node?.visitCount, \r\n    node?.content,\r\n    node?.enhancedContent,\r\n    contentLength, \r\n    contentPreview,\r\n    contentCorrupted\r\n  ]);\r\n\r\n  // Preload components and enable Narramorph transformations after content is loaded\r\n  useEffect(() => {\r\n    // Only check if node has content, don't depend on content value to prevent loops\r\n    if (node?.id && contentLength > 0 && !narramorphActivatedRef.current) {\r\n      console.log(`[NodeView] Preparing to activate Narramorph for node: ${node.id}`, {\r\n        viewMode,\r\n        hasContent: contentLength > 0\r\n      });\r\n      setContentDebug(prev => ({ ...prev, renderStarted: true }));\r\n      \r\n      // Mark as activated to prevent repeated calls\r\n      narramorphActivatedRef.current = true;\r\n      \r\n      // First ensure NarramorphRenderer is loaded before enabling it\r\n      // This prevents the race condition between component loading and state changes\r\n      let componentLoaded = false;\r\n      \r\n      // Start preloading the component immediately\r\n      console.log('[NodeView] Preloading NarramorphRenderer component');\r\n      NarramorphRendererPromise.then(() => {\r\n        componentLoaded = true;\r\n        console.log('[NodeView] NarramorphRenderer preload complete');\r\n        \r\n        // Only proceed if we still have the same node content (prevent stale closure issues)\r\n        if (node?.id) {\r\n          console.log(`[NodeView] Activating Narramorph renderer for node: ${node.id} after preload`);\r\n          \r\n          // Now it's safe to enable the component\r\n          setUseNarramorph(true);\r\n          setContentDebug(prev => ({ ...prev, narramorphActivated: true }));\r\n          \r\n          // Check DOM state after enabling\r\n          if (contentContainerRef.current) {\r\n            const preBoundingRect = contentContainerRef.current.getBoundingClientRect();\r\n            console.log('[NodeView] Post-preload container dimensions:', {\r\n              width: preBoundingRect.width,\r\n              height: preBoundingRect.height,\r\n              display: window.getComputedStyle(contentContainerRef.current).display,\r\n              visibility: window.getComputedStyle(contentContainerRef.current).visibility\r\n            });\r\n          }\r\n        }\r\n      }).catch(err => {\r\n        console.error('[NodeView] Error preloading NarramorphRenderer:', err);\r\n        // Force simple renderer on error\r\n        setForceSimpleRenderer(true);\r\n      });\r\n      \r\n      // Set up visibility check that runs after components should be loaded and rendered\r\n      const visibilityTimer = setTimeout(() => {\r\n        if (contentContainerRef.current) {\r\n          console.log('[NodeView] Force checking content visibility');\r\n          const isVisible = contentContainerRef.current.offsetParent !== null;\r\n          const boundingRect = contentContainerRef.current.getBoundingClientRect();\r\n          const computedStyle = window.getComputedStyle(contentContainerRef.current);\r\n          \r\n          console.log('[NodeView] Content visibility check:', {\r\n            isVisible,\r\n            width: boundingRect.width,\r\n            height: boundingRect.height,\r\n            display: computedStyle.display,\r\n            visibility: computedStyle.visibility,\r\n            zIndex: computedStyle.zIndex,\r\n            position: computedStyle.position,\r\n            opacity: computedStyle.opacity,\r\n            componentLoaded\r\n          });\r\n          \r\n          // If content isn't visible or has zero dimensions\r\n          if (!isVisible || boundingRect.width === 0 || boundingRect.height === 0) {\r\n            console.warn('[NodeView] Content invisible after rendering - forcing simple renderer');\r\n            setForceSimpleRenderer(true);\r\n            setContentDebug(prev => ({ ...prev, visibilityIssue: true }));\r\n          }\r\n        }\r\n      }, 1500); // Increased timeout to allow more time for loading\r\n      \r\n      return () => clearTimeout(visibilityTimer);\r\n    }\r\n    return undefined; // Explicit return for when condition is false\r\n  }, [contentLength, node?.id, viewMode]);\r\n  \r\n  // Effect to track node visits and breadcrumb history – fires once per unique node ID\r\n  useEffect(() => {\r\n    if (!node?.id || node.id === lastVisitedIdRef.current) return;\r\n\r\n    // Increment visit count for analytics\r\n    dispatch(visitNode(node.id));\r\n\r\n    // Create a plain-text synopsis from current content (first 100 chars)\r\n    const synopsis =\r\n      (node.currentContent ?? '')\r\n        .replace(/<\\/?[^>]+(>|$)/g, '')\r\n        .replace(/\\s+/g, ' ')\r\n        .trim()\r\n        .slice(0, 100);\r\n\r\n    // Add breadcrumb / visited node entry\r\n    dispatch(\r\n      addVisitedNode({\r\n        id: node.id,\r\n        title: node.title ?? '',\r\n        synopsis,\r\n      }),\r\n    );    // Update ref to prevent duplicate processing\r\n    lastVisitedIdRef.current = node.id;\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [dispatch, node?.id]);\r\n  \r\n  // EMERGENCY CONTENT RECOVERY: Validate content on each render and trigger recovery if needed\r\n  useEffect(() => {\r\n    if (node?.id && node?.currentContent) {\r\n      // Validate content integrity\r\n      dispatch(validateNodeContent(node.id));\r\n      \r\n      // If content is marked as corrupted, attempt recovery\r\n      if (node.transformationState === 'corrupted' && node.originalContent) {\r\n        console.warn(`[NodeView] Content corruption detected for node ${node.id}, initiating recovery`);\r\n        dispatch(recoverNodeContent(node.id));\r\n      }\r\n    }\r\n  }, [node?.id, node?.currentContent, node?.transformationState, node?.originalContent, dispatch]);\r\n  \r\n  // Handle WebGL context loss errors\r\n  useEffect(() => {\r\n    const handleWebGLContextLoss = (event: ErrorEvent) => {\r\n      // Check if this is a WebGL context loss error\r\n      if (event.message &&\r\n         (event.message.includes('WebGL context lost') ||\r\n          event.message.includes('THREE.WebGLRenderer'))) {\r\n        console.error('[NodeView] WebGL context loss detected!', {\r\n          message: event.message,\r\n          stack: event.error?.stack || 'No stack trace',\r\n          viewMode,\r\n          timeElapsed: Date.now() - viewTransitionState.transitionTime + 'ms',\r\n          renderCount: viewTransitionState.renderCount\r\n        });\r\n        \r\n        // Set fallback mode to use ReactMarkdown instead\r\n        setUseWebGLFallback(true);\r\n        setUseNarramorph(false);\r\n        setContentDebug(prev => ({ ...prev, errorOccurred: true }));\r\n        \r\n        // Collect memory stats on error\r\n        if (hasMemory(performance) && performance.memory) {\r\n          const memory = performance.memory;\r\n          setMemoryStats({\r\n            jsHeapSizeLimit: memory.jsHeapSizeLimit,\r\n            totalJSHeapSize: memory.totalJSHeapSize,\r\n            usedJSHeapSize: memory.usedJSHeapSize,\r\n            timestamp: Date.now()\r\n          });\r\n          \r\n          console.log(`[NodeView] Memory usage at WebGL error:`, {\r\n            usedHeap: Math.round(memory.usedJSHeapSize / (1024 * 1024)) + 'MB',\r\n            totalHeap: Math.round(memory.totalJSHeapSize / (1024 * 1024)) + 'MB',\r\n            limit: Math.round(memory.jsHeapSizeLimit / (1024 * 1024)) + 'MB'\r\n          });\r\n        }\r\n      }\r\n    };\r\n    \r\n    // Listen for error events that might indicate WebGL issues\r\n    window.addEventListener('error', handleWebGLContextLoss);\r\n    \r\n    return () => {\r\n      window.removeEventListener('error', handleWebGLContextLoss);\r\n    };\r\n  }, [viewMode, viewTransitionState.renderCount, viewTransitionState.transitionTime]);\r\n  \r\n  // Handle return to constellation view\r\n  const handleReturnToConstellation = () => {\r\n    dispatch(returnToConstellation());\r\n  };\r\n\r\n  if (viewMode !== 'reading' || !node) {\r\n    return null;\r\n  }\r\n\r\n  const characterClass = `${node.character.toLowerCase()}-theme`;\r\n\r\n  const getTemporalClass = () => {\r\n    if (node.temporalValue <= 3) return 'past-indicator';\r\n    if (node.temporalValue <= 6) return 'present-indicator';\r\n    return 'future-indicator';\r\n  };\r\n\r\n  const renderNodeContent = () => {\r\n    if (!node.currentContent) {\r\n      return (\r\n        <div className=\"node-loading\">\r\n          <span>Loading narrative fragment...</span>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // Add a wrapper with debug information\r\n    return (\r\n      <div\r\n        ref={contentContainerRef}\r\n        className={`content-container ${node.currentState}`}\r\n        data-content-loaded=\"true\"\r\n        data-node-id={node.id}\r\n        data-visit-count={node.visitCount}\r\n        style={{ position: 'relative', visibility: 'visible', display: 'block' }}\r\n      >\r\n        {/* Determine the appropriate renderer to use based on conditions */}\r\n        {forceSimpleRenderer || !webGLAvailable ? (\r\n          // Use SimpleTextRenderer when either forced or WebGL isn't available\r\n          <div\r\n            className=\"simple-renderer-wrapper\"\r\n            style={{\r\n              display: 'block',\r\n              visibility: 'visible',\r\n              position: 'relative',\r\n              minHeight: '200px',\r\n              opacity: 1,\r\n              zIndex: 5\r\n            }}\r\n          >\r\n            <SimpleTextRenderer\r\n              key={`simple-${node.id}-${node.visitCount}`}\r\n              nodeId={node.id}\r\n              onRenderComplete={onRenderComplete}\r\n              onVisibilityChange={onVisibilityChange}\r\n            />\r\n          </div>\r\n        ) : (\r\n          // Try advanced rendering if conditions allow\r\n          <Suspense fallback={<ContentLoading />}>\r\n            {useNarramorph && !useWebGLFallback ? (\r\n              // Try to use Narramorph, but with error boundary and fallback\r\n              <ErrorBoundary\r\n                fallback={\r\n                  <div className=\"fallback-content\" style={{ visibility: 'visible', display: 'block' }}>\r\n                    <p className=\"error-notice\">Advanced rendering unavailable - showing basic content</p>\r\n                    <ReactMarkdown remarkPlugins={[() => remarkGfmPromise]}>{node.currentContent}</ReactMarkdown>\r\n                  </div>\r\n                }\r\n              >\r\n                {/* Render placeholder div to reserve space during loading */}\r\n                <div\r\n                  style={{\r\n                    minHeight: '200px',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'center'\r\n                  }}\r\n                >\r\n                  <NarramorphRenderer\r\n                    key={`narramorph-${node.id}-${node.visitCount}`}\r\n                    nodeId={node.id}\r\n                    onVisibilityChange={(isVisible: boolean) => {\r\n                      console.log(`[NodeView] Content visibility changed to: ${isVisible ? 'visible' : 'hidden'}`);\r\n                      \r\n                      // Use a ref to track visibility changes over time\r\n                      const visibilityTimer = setTimeout(() => {\r\n                        // Only update state if component is still mounted\r\n                        if (contentContainerRef.current) {\r\n                          setContentDebug(prev => ({ ...prev, visibilityIssue: !isVisible }));\r\n                          \r\n                          // Only force simple renderer if content remains invisible\r\n                          if (!isVisible) {\r\n                            setForceSimpleRenderer(true);\r\n                          }\r\n                        }\r\n                      }, 1000); // Wait 1 second before applying changes\r\n                      \r\n                      return () => clearTimeout(visibilityTimer);\r\n                    }}\r\n                  />\r\n                </div>\r\n              </ErrorBoundary>\r\n            ) : (\r\n              // Fallback to basic rendering with ReactMarkdown\r\n              <div style={{ visibility: 'visible', display: 'block', position: 'relative', minHeight: '100px' }}>\r\n                <div className=\"content-loading\" style={{ marginBottom: '10px' }}>\r\n                  <div className=\"loading-spinner\"></div>\r\n                  <p>Preparing content...</p>\r\n                </div>\r\n                <ReactMarkdown\r\n                  key={`markdown-${node.id}-${node.visitCount}`}\r\n                  remarkPlugins={[() => remarkGfmPromise]}\r\n                >\r\n                  {node.currentContent}\r\n                </ReactMarkdown>\r\n              </div>\r\n            )}\r\n          </Suspense>\r\n        )}\r\n        \r\n        {/* Enhanced debug indicator with transition tracking */}\r\n        <div className=\"debug-indicator\">\r\n          <div className={`status-dot ${contentDebug.contentLoaded ? 'status-green' : 'status-red'}`} title=\"Content loaded\"></div>\r\n          <div className={`status-dot ${contentDebug.narramorphActivated ? 'status-green' : 'status-yellow'}`} title=\"Narramorph active\"></div>\r\n          <div className={`status-dot ${contentDebug.errorOccurred ? 'status-red' : 'status-green'}`} title=\"No errors\"></div>\r\n          <div className={`status-dot ${contentDebug.visibilityIssue ? 'status-red' : 'status-green'}`} title=\"Content visible\"></div>\r\n          <div className={`status-dot ${forceSimpleRenderer ? 'status-blue' : 'status-yellow'}`} title=\"Simple renderer\"></div>\r\n          <div className={`status-dot ${webGLAvailable ? 'status-green' : 'status-red'}`} title=\"WebGL available\"></div>\r\n          <div className=\"debug-metrics\">\r\n            <span title=\"View transition count\">T:{viewTransitionState.transitionCount}</span>\r\n            <span title=\"Render count\">R:{viewTransitionState.renderCount}</span>\r\n            {memoryStats.usedJSHeapSize > 0 && (\r\n              <span title=\"Memory usage\">\r\n                M:{Math.round(memoryStats.usedJSHeapSize / (1024 * 1024))}MB\r\n              </span>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n  \r\n  return (\r\n    <div \r\n      key={uniqueViewKey}\r\n      className={`node-view-container ${characterClass}`}\r\n    >\r\n      <div className={`temporal-indicator ${getTemporalClass()}`}></div>\r\n\r\n      <div className=\"node-header\">\r\n        <h1>{node.title}</h1>\r\n        <div className=\"node-metadata\">\r\n          <span className=\"node-character\">{node.character}</span>\r\n          <span className=\"node-state\">{node.currentState}</span>\r\n          <span className=\"node-visits\">Visits: {node.visitCount}</span>\r\n        </div>\r\n      </div>\r\n      \r\n      <div\r\n        className=\"node-content force-visible\"\r\n        style={{\r\n          position: 'relative'\r\n        }}\r\n      >\r\n        {renderNodeContent()}\r\n      </div>\r\n      \r\n      <div className=\"node-navigation\">\r\n        <button onClick={handleReturnToConstellation} className=\"navigation-button\">\r\n          Return to Constellation\r\n        </button>\r\n      </div>\r\n      \r\n      {/* Mini constellation for context - fixed in bottom right corner */}\r\n      <div style={{\r\n        position: 'absolute',\r\n        bottom: '20px',\r\n        right: '20px',\r\n        width: '300px',\r\n        height: '300px',\r\n        pointerEvents: 'auto'\r\n      }}>\r\n        <Suspense fallback={<SideComponentLoading />}>\r\n          <MiniConstellation />\r\n        </Suspense>\r\n      </div>\r\n      \r\n      {/* Sidebar with marginalia */}\r\n      <Suspense fallback={<SideComponentLoading />}>\r\n        <MarginaliaSidebar\r\n          nodeId={node.id}\r\n          strangeAttractors={node.strangeAttractors}\r\n        />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NodeView;"],"file":"assets/NodeView-BcISpU7u.js"}