{"version":3,"file":"NarramorphRenderer-D8aPU9Cz.js","sources":["../../src/components/NodeView/NarramorphRenderer.tsx"],"sourcesContent":["/**\r\n * NarramorphRenderer Component\r\n *\r\n * Renders node content with Narramorph transformations applied.\r\n * This component handles the transformation application logic and visual transitions\r\n * for content transformations based on reader patterns.\r\n *\r\n * Performance optimized with:\r\n * - Lazy loading for content that's not in viewport\r\n * - Memoized transformations\r\n * - Prioritized transformation application\r\n * - Intersection Observer for viewport detection\r\n */\r\n\r\nimport React, { useEffect, useState, useRef, useMemo, memo, useCallback } from 'react';\r\nimport { useNodeState } from '../../hooks/useNodeState';\r\nimport { TextTransformation } from '../../types';\r\nimport { useSelector } from 'react-redux';\r\nimport { RootState } from '../../store/types';\r\nimport TransformationAnimationContainer from './TransformationAnimationContainer';\r\nimport '../../styles/NarramorphTransformations.css';\r\nimport { transformationService } from '../../services/TransformationService';\r\nimport { finalTextCleanup } from '../../utils/contentSanitizer';\r\n// Note: Install these packages if needed\r\n// import { FixedSizeList as List } from 'react-window';\r\n// import AutoSizer from 'react-virtualized-auto-sizer';\r\n\r\ninterface NarramorphRendererProps {\r\n  nodeId?: string; // Optional - if not provided, uses current node\r\n  onVisibilityChange?: (isVisible: boolean) => void; // Callback for visibility changes\r\n}\r\n\r\ninterface PerformanceMetrics {\r\n  renderTime: number;\r\n  transformationsCount: number;\r\n  visibilityChanges: number;\r\n  deferredTransformations: number;\r\n}\r\n\r\n\r\n\r\n// Main NarramorphRenderer component with React.memo for better performance\r\nconst NarramorphRenderer: React.FC<NarramorphRendererProps> = memo(({ nodeId, onVisibilityChange }) => {\r\n  const {\r\n    node,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  } = useNodeState(nodeId);\r\n  \r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const observerRef = useRef<IntersectionObserver | null>(null);\r\n  const lastLogTimestamp = useRef<number | null>(null);\r\n  // Enhanced throttling: track both timestamp and count of visibility changes\r\n  const lastVisibilityChangeRef = useRef<number>(Date.now());\r\n  const visibilityChangeCountRef = useRef<number>(0);\r\n  // Store previous visibility state for validation\r\n  const previousVisibilityRef = useRef<boolean>(true);\r\n  const [renderKey, setRenderKey] = useState(0);\r\n  const [isVisible, setIsVisible] = useState(true);\r\n  const [webGLError, setWebGLError] = useState<Error | null>(null);\r\n  \r\n  // Performance metrics\r\n  const [metrics, setMetrics] = useState<PerformanceMetrics>({\r\n    renderTime: 0,\r\n    transformationsCount: 0,\r\n    visibilityChanges: 0,\r\n    deferredTransformations: 0\r\n  });\r\n  \r\n  // Track which transformations have been animated already\r\n  const [animatedTransformations, setAnimatedTransformations] = useState<string[]>([]);\r\n    // Memoized clean content with technical markers removed\r\n  const cleanContent = useMemo(() => {\r\n    if (!transformedContent) return '';\r\n    return finalTextCleanup(transformedContent);\r\n  }, [transformedContent]);\r\n\r\n  // Memoized clean fallback content for error cases\r\n  const cleanFallbackContent = useMemo(() => {\r\n    if (!node?.currentContent) return 'Content unavailable';\r\n    return finalTextCleanup(node.currentContent);\r\n  }, [node?.currentContent]);\r\n\r\n  // Get reading path from reader state\r\n  const readingPath = useSelector((state: RootState) => state.reader.path);\r\n  \r\n  // Effect to monitor for WebGL context loss errors\r\n  useEffect(() => {\r\n    const handleWebGLError = (event: ErrorEvent) => {\r\n      // Check if this is a WebGL context loss error\r\n      if (event.message &&\r\n         (event.message.includes('WebGL context lost') ||\r\n          event.message.includes('THREE.WebGLRenderer'))) {\r\n        console.error('[NarramorphRenderer] WebGL context loss detected!', event.message);\r\n        setWebGLError(new Error(event.message));\r\n      }\r\n    };\r\n    \r\n    window.addEventListener('error', handleWebGLError);\r\n    \r\n    return () => {\r\n      window.removeEventListener('error', handleWebGLError);\r\n    };\r\n  }, [isVisible, onVisibilityChange]);  // Helper function to handle visibility state validation\r\n  const validateAndUpdateVisibility = useCallback((\r\n    isNowVisible: boolean,\r\n    previousVisibility: boolean,\r\n    isComponentMounted: boolean\r\n  ): boolean => {\r\n    if (!isComponentMounted || !contentRef.current) return false;\r\n    \r\n    const now = Date.now();\r\n    const timeSinceLastChange = now - lastVisibilityChangeRef.current;\r\n    const tooManyChanges = visibilityChangeCountRef.current > 3 && timeSinceLastChange < 15000;\r\n    \r\n    return (\r\n      isVisible !== isNowVisible &&\r\n      timeSinceLastChange > 3000 &&\r\n      !tooManyChanges &&\r\n      previousVisibility === isVisible\r\n    );\r\n  }, [isVisible]);\r\n\r\n  // Helper function to apply visibility change\r\n  const applyVisibilityChange = useCallback((\r\n    isNowVisible: boolean,\r\n    isComponentMounted: boolean\r\n  ): void => {\r\n    if (!isComponentMounted) return;\r\n    \r\n    lastVisibilityChangeRef.current = Date.now();\r\n    visibilityChangeCountRef.current += 1;\r\n    \r\n    setIsVisible(isNowVisible);\r\n    \r\n    // Reset change counter after 15 seconds of stability\r\n    setTimeout(() => {\r\n      if (isComponentMounted) {\r\n        visibilityChangeCountRef.current = 0;\r\n      }\r\n    }, 15000);\r\n    \r\n    // Call the visibility change callback\r\n    if (onVisibilityChange) {\r\n      console.log(\"[NarramorphRenderer] Calling onVisibilityChange:\", isNowVisible, \"Previous:\", isVisible);\r\n      onVisibilityChange(isNowVisible);\r\n    }\r\n    \r\n    // Update metrics and inform transformation service\r\n    setMetrics(prev => ({\r\n      ...prev,\r\n      visibilityChanges: prev.visibilityChanges + 1\r\n    }));\r\n    \r\n    if (node?.id) {\r\n      transformationService.setContentVisibility(\r\n        node.id,\r\n        isNowVisible,\r\n        node.id === nodeId ? 2 : 1\r\n      );\r\n    }\r\n    \r\n    // Force re-render when becoming visible\r\n    if (isNowVisible) {\r\n      setRenderKey(prev => prev + 1);\r\n    }\r\n  }, [isVisible, onVisibilityChange, node?.id, nodeId]);\r\n\r\n  // Helper function to handle the delayed visibility validation\r\n  const handleDelayedValidation = useCallback((\r\n    isNowVisible: boolean,\r\n    entries: IntersectionObserverEntry[],\r\n    isComponentMounted: boolean\r\n  ): void => {\r\n    if (!isComponentMounted) return;\r\n    \r\n    const finalCheck = entries[0]?.isIntersecting ?? true;\r\n    if (finalCheck === isNowVisible) {\r\n      applyVisibilityChange(isNowVisible, isComponentMounted);\r\n    } else {\r\n      console.log(\"[NarramorphRenderer] Visibility state inconsistent - ignoring change\");\r\n    }\r\n  }, [applyVisibilityChange]);\r\n\r\n  // Helper function for the debounced visibility update\r\n  const handleDebouncedVisibilityUpdate = useCallback((\r\n    isNowVisible: boolean,\r\n    entries: IntersectionObserverEntry[],\r\n    isComponentMounted: boolean\r\n  ): void => {\r\n    if (!validateAndUpdateVisibility(isNowVisible, previousVisibilityRef.current, isComponentMounted)) {\r\n      return;\r\n    }\r\n    \r\n    // Schedule final validation check after a short delay\r\n    setTimeout(() => {\r\n      handleDelayedValidation(isNowVisible, entries, isComponentMounted);\r\n    }, 500);  }, [validateAndUpdateVisibility, handleDelayedValidation]);\r\n\r\n  // Helper function to apply animation classes to a single element\r\n  const applyElementAnimation = useCallback((\r\n    element: Element,\r\n    appliedTransformations: TextTransformation[],\r\n    newTransformations: string[]\r\n  ): void => {\r\n    const type = element.getAttribute('data-transform-type');\r\n    const text = element.textContent || '';\r\n    \r\n    // Only animate elements that match new transformations\r\n    const matchingTransformation = appliedTransformations.find(t =>\r\n      t.type === type &&\r\n      text.includes(t.selector || '') &&\r\n      newTransformations.includes(`${t.type}-${t.selector}`)\r\n    );\r\n    \r\n    if (!matchingTransformation) return;\r\n    \r\n    // Add all classes at once for better performance\r\n    element.classList.add('narramorph-transform-new');\r\n    \r\n    // Add appropriate effect class based on transformation type\r\n    const typeClassMap: Record<string, string> = {\r\n      'replace': 'narramorph-replaced',\r\n      'fragment': 'narramorph-fragmented', \r\n      'expand': 'narramorph-expanded',\r\n      'emphasize': `narramorph-emphasis-${matchingTransformation.emphasis || 'color'}`,\r\n      'metaComment': 'narramorph-commented'\r\n    };\r\n    \r\n    const className = typeClassMap[type as string];\r\n    if (className) {\r\n      element.classList.add(className);\r\n    }\r\n    \r\n    // Schedule class removal\r\n    setTimeout(() => {\r\n      element.classList.remove('narramorph-transform-new');\r\n    }, 2000);\r\n  }, []);\r\n\r\n  // Helper function to process a batch of elements\r\n  const processBatch = useCallback((\r\n    batch: Element[],\r\n    appliedTransformations: TextTransformation[],\r\n    newTransformations: string[]\r\n  ): void => {\r\n    batch.forEach(element => {\r\n      applyElementAnimation(element, appliedTransformations, newTransformations);\r\n    });\r\n  }, [applyElementAnimation]);\r\n\r\n  // Helper function to create batches from elements\r\n  const createBatches = useCallback((elements: Element[], batchSize: number = 5): Element[][] => {\r\n    const batches: Element[][] = [];\r\n    for (let i = 0; i < elements.length; i += batchSize) {\r\n      batches.push(Array.from(elements).slice(i, i + batchSize));\r\n    }\r\n    return batches;\r\n  }, []);\r\n\r\n  // Helper function to apply animations with staggered timing\r\n  const applyAnimationsWithStagger = useCallback((\r\n    elements: Element[],\r\n    appliedTransformations: TextTransformation[],\r\n    newTransformations: string[],\r\n    staggerDelay: number = 50\r\n  ): void => {\r\n    const batches = createBatches(elements, 5);\r\n    const batchSize = 5;\r\n    \r\n    // Process batches with staggered timing\r\n    batches.forEach((batch, batchIndex) => {\r\n      setTimeout(() => {\r\n        processBatch(batch, appliedTransformations, newTransformations);\r\n      }, batchIndex * staggerDelay * batchSize);\r\n    });\r\n  }, [createBatches, processBatch]);\r\n\r\n  // Setup intersection observer for visibility detection with guaranteed initial visibility\r\n  useEffect(() => {\r\n    if (!contentRef.current) {\r\n      return;\r\n    }\r\n    \r\n    // Clean up previous observer\r\n    if (observerRef.current) {\r\n      observerRef.current.disconnect();\r\n      observerRef.current = null;\r\n    }\r\n    \r\n    // Set initial visibility only when node changes\r\n    if (!observerRef.current) {\r\n      setIsVisible(true);\r\n      if (onVisibilityChange) {\r\n        onVisibilityChange(true);\r\n      }\r\n    }\r\n      // Create observer with enhanced debouncing to prevent too many updates\r\n    let visibilityTimeout: number | null = null;\r\n    let validationTimeout: number | null = null;\r\n    let isComponentMounted = true;\r\n    \r\n    observerRef.current = new IntersectionObserver(\r\n      (entries) => {\r\n        // Early exit if component is unmounted\r\n        if (!isComponentMounted || !contentRef.current) {\r\n          return;\r\n        }\r\n        \r\n        const isNowVisible = entries[0]?.isIntersecting ?? true;\r\n        \r\n        // Store previous visibility for validation\r\n        previousVisibilityRef.current = isVisible;\r\n        \r\n        if (!validateAndUpdateVisibility(isNowVisible, previousVisibilityRef.current, isComponentMounted)) {\r\n          return;\r\n        }\r\n        \r\n        // Cancel any pending visibility updates\r\n        if (visibilityTimeout) {\r\n          window.clearTimeout(visibilityTimeout);\r\n        }\r\n        if (validationTimeout) {\r\n          window.clearTimeout(validationTimeout);\r\n        }\r\n        \r\n        // Log potential visibility change\r\n        console.log(`[NarramorphRenderer] Potential visibility change detected: ${isVisible} -> ${isNowVisible}`);\r\n        \r\n        // Use a longer debounce time to prevent rapid cycling (increased to 1200ms)\r\n        visibilityTimeout = window.setTimeout(() => {\r\n          handleDebouncedVisibilityUpdate(isNowVisible, entries, isComponentMounted);\r\n          visibilityTimeout = null;\r\n        }, 1200);\r\n      },\r\n      {\r\n        root: null,\r\n        rootMargin: '500px',\r\n        threshold: 0.01\r\n      }\r\n    );\r\n    \r\n    // Start observing\r\n    if (contentRef.current && isComponentMounted) {\r\n      observerRef.current.observe(contentRef.current);\r\n    }\r\n    \r\n    // Enhanced cleanup\r\n    return () => {\r\n      isComponentMounted = false;\r\n      \r\n      if (visibilityTimeout) {\r\n        window.clearTimeout(visibilityTimeout);\r\n        visibilityTimeout = null;\r\n      }\r\n      if (validationTimeout) {\r\n        window.clearTimeout(validationTimeout);\r\n        validationTimeout = null;\r\n      }\r\n      \r\n      if (observerRef.current) {\r\n        try {\r\n          observerRef.current.disconnect();\r\n          console.log('[NarramorphRenderer] Intersection observer disconnected cleanly');\r\n        } catch (error) {\r\n          console.warn('[NarramorphRenderer] Error disconnecting observer:', error);\r\n        }\r\n        observerRef.current = null;\r\n      }\r\n    };\r\n  }, [node?.id, nodeId, isVisible, onVisibilityChange, handleDebouncedVisibilityUpdate, validateAndUpdateVisibility]);\r\n  \r\n  // Prioritize transformations based on visibility and importance\r\n  const prioritizedTransformations = useMemo(() => {\r\n    if (!appliedTransformations.length) return [];\r\n    \r\n    // If content is visible, apply all transformations\r\n    if (isVisible) {\r\n      return appliedTransformations;\r\n    }\r\n    \r\n    // If not visible, only apply high priority transformations\r\n    const highPriorityTransformations = appliedTransformations.filter(t =>\r\n      t.priority === 'high' || t.applyImmediately === true\r\n    );\r\n    \r\n    setMetrics(prev => ({\r\n      ...prev,\r\n      deferredTransformations: appliedTransformations.length - highPriorityTransformations.length\r\n    }));\r\n    \r\n    return highPriorityTransformations;\r\n  }, [appliedTransformations, isVisible]);\r\n  \r\n  // When transformations occur, trigger animations with sequenced timing\r\n  // Optimized version with debounced and batched updates\r\n  useEffect(() => {\r\n    if (!newlyTransformed || !contentRef.current || !isVisible) {\r\n      return; // Skip if not visible or no new transformations\r\n    }\r\n    \r\n    const startTime = performance.now();\r\n    \r\n    // Force re-render to apply new transformations with animation\r\n    setRenderKey(prev => prev + 1);\r\n    \r\n    // Use requestAnimationFrame to sync with browser rendering cycle\r\n    requestAnimationFrame(() => {\r\n      // Get all elements with transformation classes - use a more efficient selector\r\n      const transformedElements = contentRef.current?.querySelectorAll('[data-transform-type]');\r\n      if (!transformedElements || transformedElements.length === 0) return;\r\n      \r\n      // Calculate which transformations are new\r\n      const transformationKeys = appliedTransformations.map(\r\n        (t: TextTransformation) => `${t.type}-${t.selector}`\r\n      );\r\n      const newTransformations = transformationKeys.filter(\r\n        key => !animatedTransformations.includes(key)\r\n      );\r\n      \r\n      if (newTransformations.length === 0) return;\r\n      \r\n      // Get transformation groups for staggered animations\r\n      const transformGroups: Record<string, Element[]> = {\r\n        'replace': [],\r\n        'fragment': [],\r\n        'expand': [],\r\n        'emphasize': [],\r\n        'metaComment': []\r\n      };\r\n      \r\n      // Group elements by transformation type\r\n      transformedElements.forEach(element => {\r\n        const type = element.getAttribute('data-transform-type');\r\n        if (type && type in transformGroups) {\r\n          transformGroups[type].push(element);\r\n        }\r\n      });\r\n      \r\n      // Apply animations with staggered timing for each group\r\n      Object.values(transformGroups).forEach(group => {\r\n        applyAnimationsWithStagger(group, appliedTransformations, newTransformations);\r\n      });\r\n      \r\n      // Update animated transformations list\r\n      setAnimatedTransformations(transformationKeys);\r\n      \r\n      // Update performance metrics\r\n      const endTime = performance.now();\r\n      setMetrics(prev => ({\r\n        ...prev,\r\n        renderTime: endTime - startTime,\r\n        transformationsCount: appliedTransformations.length\r\n      }));\r\n    });\r\n  }, [newlyTransformed, appliedTransformations, animatedTransformations, isVisible, applyAnimationsWithStagger]);\r\n  \r\n  // When node changes, reset animation state and update visibility tracking\r\n  useEffect(() => {\r\n    if (node?.id) {\r\n      setAnimatedTransformations([]);\r\n      \r\n      // Reset metrics for new node\r\n      setMetrics({\r\n        renderTime: 0,\r\n        transformationsCount: 0,\r\n        visibilityChanges: 0,\r\n        deferredTransformations: 0      });\r\n    }\r\n  }, [node?.id]);\r\n  \r\n  // Show error state if WebGL context was lost\r\n  if (webGLError) {\r\n    console.error('[NarramorphRenderer] Rendering in error state due to WebGL issue');\r\n    return (      <div className=\"narramorph-error\">\r\n        <p>Advanced rendering unavailable</p>\r\n        <div dangerouslySetInnerHTML={{ __html: cleanFallbackContent }} />\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  // Show loading state if content isn't available\r\n  if (!node || !transformedContent) {\r\n    // No longer logging this repeatedly\r\n    return <div className=\"narramorph-loading\">Loading content...</div>;\r\n  }\r\n  \r\n  // Render the transformed content with animation container and enhanced visibility tracking\r\n  // Only log in development mode\r\n  if (process.env.NODE_ENV === 'development') {\r\n    // Limit logging frequency with a timestamp check\r\n    const now = Date.now();\r\n    if (!lastLogTimestamp.current || now - lastLogTimestamp.current > 5000) {\r\n      console.log(`[NarramorphRenderer] Rendering content for node: ${node.id}, visible: ${isVisible}`);\r\n      lastLogTimestamp.current = now;\r\n    }\r\n  }\r\n  return (\r\n    <div\r\n      className={`narramorph-container ${isVisible ? 'is-visible' : 'is-hidden'}`}\r\n      key={renderKey}\r\n      data-node-id={node.id}\r\n      data-visibility={isVisible ? 'visible' : 'hidden'}\r\n      style={{\r\n        display: 'block',\r\n        visibility: 'visible',\r\n        position: 'relative',\r\n        minHeight: '200px'\r\n      }}\r\n    >\r\n      <TransformationAnimationContainer\r\n        transformations={prioritizedTransformations}\r\n        isNewlyTransformed={newlyTransformed}\r\n        nodeId={node.id}\r\n      >\r\n        <div\r\n          ref={contentRef}\r\n          className={`narramorph-content ${isVisible ? 'is-visible' : 'is-hidden'}`}\r\n          data-transformations-count={prioritizedTransformations.length}\r\n          data-node-id={node.id}\r\n          data-visit-count={node.visitCount}\r\n          style={{\r\n            display: 'block',\r\n            visibility: 'visible',\r\n            position: 'relative'\r\n          }}\r\n        >\r\n          {/* Show loading indicator before content is ready */}\r\n          {!cleanContent && (\r\n            <div className=\"narramorph-loading-indicator\" style={{margin: '20px 0'}}>\r\n              <div className=\"loading-spinner\"></div>\r\n              <p>Preparing narrative transformations...</p>\r\n            </div>\r\n          )}\r\n            {/* Render content directly without virtualization */}\r\n          {cleanContent && (\r\n            <div\r\n              dangerouslySetInnerHTML={{ __html: cleanContent }}\r\n              style={{\r\n                opacity: isVisible ? 1 : 0.99, // Force visibility while maintaining transitions\r\n                transition: 'opacity 0.3s ease-in'\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      </TransformationAnimationContainer>\r\n        {/* Optional debugging panel for tracking applied transformations */}\r\n      {process.env.NODE_ENV === 'development' && (\r\n        <div className=\"narramorph-debug\">\r\n          <h4>Applied Transformations {isVisible ? '(Visible)' : '(Hidden)'}</h4>\r\n          <ul>\r\n            {prioritizedTransformations.map((t: TextTransformation, idx: number) => (\r\n              <li key={idx}>\r\n                {t.type}: {t.selector?.substring(0, 20)}... {t.priority && `(${t.priority})`}\r\n              </li>\r\n            ))}\r\n          </ul>\r\n          <p>Path Length: {readingPath.sequence.length}</p>\r\n          <p>Visit Count: {node.visitCount}</p>\r\n          <p>Journey Context: {node.journeyContext ? 'Active' : 'None'}</p>\r\n          {node.journeyContext && (\r\n            <div>\r\n              <p>Last Character: {node.journeyContext.lastVisitedCharacter || 'None'}</p>\r\n              <p>Recursive Awareness: {(node.journeyContext.recursiveAwareness * 100).toFixed(1)}%</p>\r\n              <p>Temporal Displacement: {node.journeyContext.temporalDisplacement ? 'Yes' : 'No'}</p>\r\n            </div>\r\n          )}\r\n          <p>Performance: {metrics.renderTime.toFixed(2)}ms for {metrics.transformationsCount} transformations</p>\r\n          <p>Deferred: {metrics.deferredTransformations} transformations</p>\r\n          <p>Visibility Changes: {metrics.visibilityChanges}</p>\r\n          <p>Character Bleed Detected: {\r\n            prioritizedTransformations.some(t => \r\n              t.type === 'fragment' || t.type === 'emphasize' && t.intensity && t.intensity > 3\r\n            ) ? 'Yes' : 'No'\r\n          }</p>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default NarramorphRenderer;\r\n"],"names":["NarramorphRenderer","memo","nodeId","onVisibilityChange","node","transformedContent","newlyTransformed","appliedTransformations","useNodeState","contentRef","useRef","observerRef","lastVisibilityChangeRef","visibilityChangeCountRef","previousVisibilityRef","renderKey","setRenderKey","useState","isVisible","setIsVisible","webGLError","setWebGLError","metrics","setMetrics","animatedTransformations","setAnimatedTransformations","cleanContent","useMemo","finalTextCleanup","cleanFallbackContent","useSelector","state","useEffect","handleWebGLError","event","validateAndUpdateVisibility","useCallback","isNowVisible","previousVisibility","isComponentMounted","timeSinceLastChange","tooManyChanges","applyVisibilityChange","prev","transformationService","handleDelayedValidation","entries","_a","handleDebouncedVisibilityUpdate","applyElementAnimation","element","newTransformations","type","text","matchingTransformation","t","className","processBatch","batch","createBatches","elements","batchSize","batches","i","applyAnimationsWithStagger","staggerDelay","batchIndex","visibilityTimeout","error","prioritizedTransformations","highPriorityTransformations","startTime","transformedElements","transformationKeys","key","transformGroups","group","endTime","jsxs","jsx","TransformationAnimationContainer"],"mappings":"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"}