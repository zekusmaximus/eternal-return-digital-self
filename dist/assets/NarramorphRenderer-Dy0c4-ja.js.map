{"version":3,"file":"NarramorphRenderer-Dy0c4-ja.js","sources":["../../src/components/NodeView/NarramorphRenderer.tsx"],"sourcesContent":["/**\r\n * NarramorphRenderer Component\r\n *\r\n * Renders node content with Narramorph transformations applied.\r\n * This component handles the transformation application logic and visual transitions\r\n * for content transformations based on reader patterns.\r\n *\r\n * Performance optimized with:\r\n * - Lazy loading for content that's not in viewport\r\n * - Memoized transformations\r\n * - Prioritized transformation application\r\n * - Intersection Observer for viewport detection\r\n */\r\n\r\nimport React, { useEffect, useState, useRef, useMemo, memo } from 'react';\r\nimport { useNodeState } from '../../hooks/useNodeState';\r\nimport { TextTransformation } from '../../types';\r\nimport { useSelector } from 'react-redux';\r\nimport { RootState } from '../../store/types';\r\nimport TransformationAnimationContainer from './TransformationAnimationContainer';\r\nimport '../../styles/NarramorphTransformations.css';\r\nimport { transformationService } from '../../services/TransformationService';\r\n// Note: Install these packages if needed\r\n// import { FixedSizeList as List } from 'react-window';\r\n// import AutoSizer from 'react-virtualized-auto-sizer';\r\n\r\ninterface NarramorphRendererProps {\r\n  nodeId?: string; // Optional - if not provided, uses current node\r\n  onVisibilityChange?: (isVisible: boolean) => void; // Callback for visibility changes\r\n}\r\n\r\ninterface PerformanceMetrics {\r\n  renderTime: number;\r\n  transformationsCount: number;\r\n  visibilityChanges: number;\r\n  deferredTransformations: number;\r\n}\r\n\r\n\r\n\r\n// Main NarramorphRenderer component with React.memo for better performance\r\nconst NarramorphRenderer: React.FC<NarramorphRendererProps> = memo(({ nodeId, onVisibilityChange }) => {\r\n  const {\r\n    node,\r\n    transformedContent,\r\n    newlyTransformed,\r\n    appliedTransformations\r\n  } = useNodeState(nodeId);\r\n  \r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const observerRef = useRef<IntersectionObserver | null>(null);\r\n  const lastLogTimestamp = useRef<number | null>(null);\r\n  // Enhanced throttling: track both timestamp and count of visibility changes\r\n  const lastVisibilityChangeRef = useRef<number>(Date.now());\r\n  const visibilityChangeCountRef = useRef<number>(0);\r\n  // Store previous visibility state for validation\r\n  const previousVisibilityRef = useRef<boolean>(true);\r\n  const [renderKey, setRenderKey] = useState(0);\r\n  const [isVisible, setIsVisible] = useState(true);\r\n  const [webGLError, setWebGLError] = useState<Error | null>(null);\r\n  \r\n  // Performance metrics\r\n  const [metrics, setMetrics] = useState<PerformanceMetrics>({\r\n    renderTime: 0,\r\n    transformationsCount: 0,\r\n    visibilityChanges: 0,\r\n    deferredTransformations: 0\r\n  });\r\n  \r\n  // Track which transformations have been animated already\r\n  const [animatedTransformations, setAnimatedTransformations] = useState<string[]>([]);\r\n  \r\n  // Get reading path from reader state\r\n  const readingPath = useSelector((state: RootState) => state.reader.path);\r\n  \r\n  // Effect to monitor for WebGL context loss errors\r\n  useEffect(() => {\r\n    const handleWebGLError = (event: ErrorEvent) => {\r\n      // Check if this is a WebGL context loss error\r\n      if (event.message &&\r\n         (event.message.includes('WebGL context lost') ||\r\n          event.message.includes('THREE.WebGLRenderer'))) {\r\n        console.error('[NarramorphRenderer] WebGL context loss detected!', event.message);\r\n        setWebGLError(new Error(event.message));\r\n      }\r\n    };\r\n    \r\n    window.addEventListener('error', handleWebGLError);\r\n    \r\n    return () => {\r\n      window.removeEventListener('error', handleWebGLError);\r\n    };\r\n  }, [isVisible, onVisibilityChange]);\r\n\r\n  // Setup intersection observer for visibility detection with guaranteed initial visibility\r\n  useEffect(() => {\r\n    if (!contentRef.current) {\r\n      return;\r\n    }\r\n    \r\n    // Clean up previous observer\r\n    if (observerRef.current) {\r\n      observerRef.current.disconnect();\r\n      observerRef.current = null;\r\n    }\r\n    \r\n    // Set initial visibility only when node changes\r\n    if (!observerRef.current) {\r\n      setIsVisible(true);\r\n      if (onVisibilityChange) {\r\n        onVisibilityChange(true);\r\n      }\r\n    }\r\n    \r\n    // Create observer with enhanced debouncing to prevent too many updates\r\n    let visibilityTimeout: number | null = null;\r\n    let validationTimeout: number | null = null;\r\n    let isComponentMounted = true;\r\n    \r\n    observerRef.current = new IntersectionObserver(\r\n      (entries) => {\r\n        // Early exit if component is unmounted\r\n        if (!isComponentMounted || !contentRef.current) {\r\n          return;\r\n        }\r\n        \r\n        const isNowVisible = entries[0]?.isIntersecting ?? true;\r\n        const now = Date.now();\r\n        \r\n        // Store previous visibility for validation\r\n        previousVisibilityRef.current = isVisible;\r\n        \r\n        // Enhanced throttling with multiple validation checks\r\n        // 1. Visibility must have truly changed\r\n        // 2. Sufficient time must have passed since last change (3 seconds minimum)\r\n        // 3. Cannot have more than 3 visibility changes in 15 seconds\r\n        const timeSinceLastChange = now - lastVisibilityChangeRef.current;\r\n        const tooManyChanges = visibilityChangeCountRef.current > 3 && timeSinceLastChange < 15000;\r\n        \r\n        if (isVisible !== isNowVisible &&\r\n            contentRef.current &&\r\n            timeSinceLastChange > 3000 && // Increased from 2s to 3s\r\n            !tooManyChanges &&\r\n            isComponentMounted) {\r\n            \r\n          // Cancel any pending visibility updates\r\n          if (visibilityTimeout) {\r\n            window.clearTimeout(visibilityTimeout);\r\n          }\r\n          if (validationTimeout) {\r\n            window.clearTimeout(validationTimeout);\r\n          }\r\n          \r\n          // Log potential visibility change\r\n          console.log(`[NarramorphRenderer] Potential visibility change detected: ${isVisible} -> ${isNowVisible}`);\r\n          \r\n          // Use a longer debounce time to prevent rapid cycling (increased to 1200ms)\r\n          visibilityTimeout = window.setTimeout(() => {\r\n            // Double-check that visibility truly changed and element still exists\r\n            if (isVisible !== isNowVisible &&\r\n                contentRef.current &&\r\n                previousVisibilityRef.current === isVisible &&\r\n                isComponentMounted) {\r\n                \r\n              // Schedule final validation check after a short delay\r\n              validationTimeout = window.setTimeout(() => {\r\n                // Final verification that visibility state is consistent\r\n                if (!isComponentMounted) return;\r\n                \r\n                const finalCheck = entries[0]?.isIntersecting ?? true;\r\n                if (finalCheck === isNowVisible) {\r\n                  // Update timestamp and count\r\n                  lastVisibilityChangeRef.current = Date.now();\r\n                  visibilityChangeCountRef.current += 1;\r\n                  \r\n                  // Update state only after multiple validations\r\n                  if (isComponentMounted) {\r\n                    setIsVisible(isNowVisible);\r\n                  }\r\n                  \r\n                  // Reset change counter after 15 seconds of stability\r\n                  setTimeout(() => {\r\n                    if (isComponentMounted) {\r\n                      visibilityChangeCountRef.current = 0;\r\n                    }\r\n                  }, 15000);\r\n                  \r\n                  // Call the visibility change callback if provided\r\n                  if (onVisibilityChange && isComponentMounted) {\r\n                    console.log(\"[NarramorphRenderer] Calling onVisibilityChange:\", isNowVisible, \"Previous:\", isVisible);\r\n                    onVisibilityChange(isNowVisible);\r\n                  }\r\n                } else {\r\n                  console.log(\"[NarramorphRenderer] Visibility state inconsistent - ignoring change\");\r\n                }\r\n                validationTimeout = null;\r\n              }, 500); // Increased validation delay\r\n            }\r\n            \r\n            if (isComponentMounted) {\r\n              setMetrics(prev => ({\r\n                ...prev,\r\n                visibilityChanges: prev.visibilityChanges + 1\r\n              }));\r\n              \r\n              // Inform the transformation service about visibility changes\r\n              // But only after validation checks pass\r\n              if (node?.id) {\r\n                transformationService.setContentVisibility(\r\n                  node.id,\r\n                  isNowVisible,\r\n                  node.id === nodeId ? 2 : 1\r\n                );\r\n              }\r\n              \r\n              // Force a re-render when becoming visible again\r\n              // But only when state is stable\r\n              if (isNowVisible) {\r\n                setRenderKey(prev => prev + 1);\r\n              }\r\n            }\r\n            \r\n            visibilityTimeout = null;\r\n          }, 1200); // Increased debounce time to prevent cascading updates\r\n        }\r\n      },\r\n      {\r\n        root: null,\r\n        rootMargin: '500px',\r\n        threshold: 0.01\r\n      }\r\n    );\r\n    \r\n    // Start observing\r\n    if (contentRef.current && isComponentMounted) {\r\n      observerRef.current.observe(contentRef.current);\r\n    }\r\n    \r\n    // Enhanced cleanup\r\n    return () => {\r\n      isComponentMounted = false;\r\n      \r\n      if (visibilityTimeout) {\r\n        window.clearTimeout(visibilityTimeout);\r\n        visibilityTimeout = null;\r\n      }\r\n      if (validationTimeout) {\r\n        window.clearTimeout(validationTimeout);\r\n        validationTimeout = null;\r\n      }\r\n      \r\n      if (observerRef.current) {\r\n        try {\r\n          observerRef.current.disconnect();\r\n          console.log('[NarramorphRenderer] Intersection observer disconnected cleanly');\r\n        } catch (error) {\r\n          console.warn('[NarramorphRenderer] Error disconnecting observer:', error);\r\n        }\r\n        observerRef.current = null;\r\n      }\r\n    };\r\n  }, [node?.id, nodeId, isVisible, onVisibilityChange]); // Added isVisible and onVisibilityChange to deps\r\n  \r\n  // Prioritize transformations based on visibility and importance\r\n  const prioritizedTransformations = useMemo(() => {\r\n    if (!appliedTransformations.length) return [];\r\n    \r\n    // If content is visible, apply all transformations\r\n    if (isVisible) {\r\n      return appliedTransformations;\r\n    }\r\n    \r\n    // If not visible, only apply high priority transformations\r\n    const highPriorityTransformations = appliedTransformations.filter(t =>\r\n      t.priority === 'high' || t.applyImmediately === true\r\n    );\r\n    \r\n    setMetrics(prev => ({\r\n      ...prev,\r\n      deferredTransformations: appliedTransformations.length - highPriorityTransformations.length\r\n    }));\r\n    \r\n    return highPriorityTransformations;\r\n  }, [appliedTransformations, isVisible]);\r\n  \r\n  // When transformations occur, trigger animations with sequenced timing\r\n  // Optimized version with debounced and batched updates\r\n  useEffect(() => {\r\n    if (!newlyTransformed || !contentRef.current || !isVisible) {\r\n      return; // Skip if not visible or no new transformations\r\n    }\r\n    \r\n    const startTime = performance.now();\r\n    \r\n    // Force re-render to apply new transformations with animation\r\n    setRenderKey(prev => prev + 1);\r\n    \r\n    // Use requestAnimationFrame to sync with browser rendering cycle\r\n    requestAnimationFrame(() => {\r\n      // Get all elements with transformation classes - use a more efficient selector\r\n      const transformedElements = contentRef.current?.querySelectorAll('[data-transform-type]');\r\n      if (!transformedElements || transformedElements.length === 0) return;\r\n      \r\n      // Calculate which transformations are new\r\n      const transformationKeys = appliedTransformations.map(\r\n        (t: TextTransformation) => `${t.type}-${t.selector}`\r\n      );\r\n      const newTransformations = transformationKeys.filter(\r\n        key => !animatedTransformations.includes(key)\r\n      );\r\n      \r\n      if (newTransformations.length === 0) return;\r\n      \r\n      // Get transformation groups for staggered animations\r\n      const transformGroups: Record<string, Element[]> = {\r\n        'replace': [],\r\n        'fragment': [],\r\n        'expand': [],\r\n        'emphasize': [],\r\n        'metaComment': []\r\n      };\r\n      \r\n      // Group elements by transformation type\r\n      transformedElements.forEach(element => {\r\n        const type = element.getAttribute('data-transform-type');\r\n        if (type && type in transformGroups) {\r\n          transformGroups[type].push(element);\r\n        }\r\n      });\r\n      \r\n      // Apply animation class to new transformations with staggered timing\r\n      // Optimize by using a single setTimeout callback for each batch\r\n      const applyAnimationsWithStagger = (elements: Element[], staggerDelay: number = 50) => {\r\n        const batches: Element[][] = [];\r\n        const batchSize = 5; // Process 5 elements per batch for better performance\r\n        \r\n        // Create batches\r\n        for (let i = 0; i < elements.length; i += batchSize) {\r\n          batches.push(Array.from(elements).slice(i, i + batchSize));\r\n        }\r\n        \r\n        // Process batches with staggered timing\r\n        batches.forEach((batch, batchIndex) => {\r\n          setTimeout(() => {\r\n            batch.forEach(element => {\r\n              const type = element.getAttribute('data-transform-type');\r\n              const text = element.textContent || '';\r\n              \r\n              // Only animate elements that match new transformations\r\n              const matchingTransformation = appliedTransformations.find(t =>\r\n                t.type === type &&\r\n                text.includes(t.selector || '') &&\r\n                newTransformations.includes(`${t.type}-${t.selector}`)\r\n              );\r\n              \r\n              if (matchingTransformation) {\r\n                // Add all classes at once for better performance\r\n                element.classList.add('narramorph-transform-new');\r\n                \r\n                // Add appropriate effect class based on transformation type\r\n                switch(type) {\r\n                  case 'replace':\r\n                    element.classList.add('narramorph-replaced');\r\n                    break;\r\n                  case 'fragment':\r\n                    element.classList.add('narramorph-fragmented');\r\n                    break;\r\n                  case 'expand':\r\n                    element.classList.add('narramorph-expanded');\r\n                    break;\r\n                  case 'emphasize':\r\n                    element.classList.add(`narramorph-emphasis-${matchingTransformation.emphasis || 'color'}`);\r\n                    break;\r\n                  case 'metaComment':\r\n                    element.classList.add('narramorph-commented');\r\n                    break;\r\n                }\r\n                \r\n                // Schedule class removal in one batch\r\n                setTimeout(() => {\r\n                  element.classList.remove('narramorph-transform-new');\r\n                }, 2000);\r\n              }\r\n            });\r\n          }, batchIndex * staggerDelay * batchSize);\r\n        });\r\n      };\r\n      \r\n      // Apply animations with staggered timing for each group\r\n      Object.values(transformGroups).forEach(group => {\r\n        applyAnimationsWithStagger(group);\r\n      });\r\n      \r\n      // Update animated transformations list\r\n      setAnimatedTransformations(transformationKeys);\r\n      \r\n      // Update performance metrics\r\n      const endTime = performance.now();\r\n      setMetrics(prev => ({\r\n        ...prev,\r\n        renderTime: endTime - startTime,\r\n        transformationsCount: appliedTransformations.length\r\n      }));\r\n    });\r\n  }, [newlyTransformed, appliedTransformations, animatedTransformations, isVisible]);\r\n  \r\n  // When node changes, reset animation state and update visibility tracking\r\n  useEffect(() => {\r\n    if (node?.id) {\r\n      setAnimatedTransformations([]);\r\n      \r\n      // Reset metrics for new node\r\n      setMetrics({\r\n        renderTime: 0,\r\n        transformationsCount: 0,\r\n        visibilityChanges: 0,\r\n        deferredTransformations: 0\r\n      });\r\n    }\r\n  }, [node?.id]);\r\n  \r\n  \r\n  // Show error state if WebGL context was lost\r\n  if (webGLError) {\r\n    console.error('[NarramorphRenderer] Rendering in error state due to WebGL issue');\r\n    return (\r\n      <div className=\"narramorph-error\">\r\n        <p>Advanced rendering unavailable</p>\r\n        <div dangerouslySetInnerHTML={{ __html: node?.currentContent || 'Content unavailable' }} />\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  // Show loading state if content isn't available\r\n  if (!node || !transformedContent) {\r\n    // No longer logging this repeatedly\r\n    return <div className=\"narramorph-loading\">Loading content...</div>;\r\n  }\r\n  \r\n  // Render the transformed content with animation container and enhanced visibility tracking\r\n  // Only log in development mode\r\n  if (process.env.NODE_ENV === 'development') {\r\n    // Limit logging frequency with a timestamp check\r\n    const now = Date.now();\r\n    if (!lastLogTimestamp.current || now - lastLogTimestamp.current > 5000) {\r\n      console.log(`[NarramorphRenderer] Rendering content for node: ${node.id}, visible: ${isVisible}`);\r\n      lastLogTimestamp.current = now;\r\n    }\r\n  }\r\n  return (\r\n    <div\r\n      className={`narramorph-container ${isVisible ? 'is-visible' : 'is-hidden'}`}\r\n      key={renderKey}\r\n      data-node-id={node.id}\r\n      data-visibility={isVisible ? 'visible' : 'hidden'}\r\n      style={{\r\n        display: 'block',\r\n        visibility: 'visible',\r\n        position: 'relative',\r\n        minHeight: '200px'\r\n      }}\r\n    >\r\n      <TransformationAnimationContainer\r\n        transformations={prioritizedTransformations}\r\n        isNewlyTransformed={newlyTransformed}\r\n        nodeId={node.id}\r\n      >\r\n        <div\r\n          ref={contentRef}\r\n          className={`narramorph-content ${isVisible ? 'is-visible' : 'is-hidden'}`}\r\n          data-transformations-count={prioritizedTransformations.length}\r\n          data-node-id={node.id}\r\n          data-visit-count={node.visitCount}\r\n          style={{\r\n            display: 'block',\r\n            visibility: 'visible',\r\n            position: 'relative'\r\n          }}\r\n        >\r\n          {/* Show loading indicator before content is ready */}\r\n          {!transformedContent && (\r\n            <div className=\"narramorph-loading-indicator\" style={{margin: '20px 0'}}>\r\n              <div className=\"loading-spinner\"></div>\r\n              <p>Preparing narrative transformations...</p>\r\n            </div>\r\n          )}\r\n          \r\n          {/* Render content directly without virtualization */}\r\n          {transformedContent && (\r\n            <div\r\n              dangerouslySetInnerHTML={{ __html: transformedContent }}\r\n              style={{\r\n                opacity: isVisible ? 1 : 0.99, // Force visibility while maintaining transitions\r\n                transition: 'opacity 0.3s ease-in'\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      </TransformationAnimationContainer>\r\n        {/* Optional debugging panel for tracking applied transformations */}\r\n      {process.env.NODE_ENV === 'development' && (\r\n        <div className=\"narramorph-debug\">\r\n          <h4>Applied Transformations {isVisible ? '(Visible)' : '(Hidden)'}</h4>\r\n          <ul>\r\n            {prioritizedTransformations.map((t: TextTransformation, idx: number) => (\r\n              <li key={idx}>\r\n                {t.type}: {t.selector?.substring(0, 20)}... {t.priority && `(${t.priority})`}\r\n              </li>\r\n            ))}\r\n          </ul>\r\n          <p>Path Length: {readingPath.sequence.length}</p>\r\n          <p>Visit Count: {node.visitCount}</p>\r\n          <p>Journey Context: {node.journeyContext ? 'Active' : 'None'}</p>\r\n          {node.journeyContext && (\r\n            <div>\r\n              <p>Last Character: {node.journeyContext.lastVisitedCharacter || 'None'}</p>\r\n              <p>Recursive Awareness: {(node.journeyContext.recursiveAwareness * 100).toFixed(1)}%</p>\r\n              <p>Temporal Displacement: {node.journeyContext.temporalDisplacement ? 'Yes' : 'No'}</p>\r\n            </div>\r\n          )}\r\n          <p>Performance: {metrics.renderTime.toFixed(2)}ms for {metrics.transformationsCount} transformations</p>\r\n          <p>Deferred: {metrics.deferredTransformations} transformations</p>\r\n          <p>Visibility Changes: {metrics.visibilityChanges}</p>\r\n          <p>Character Bleed Detected: {\r\n            prioritizedTransformations.some(t => \r\n              t.type === 'fragment' || t.type === 'emphasize' && t.intensity && t.intensity > 3\r\n            ) ? 'Yes' : 'No'\r\n          }</p>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default NarramorphRenderer;\r\n"],"names":["NarramorphRenderer","memo","nodeId","onVisibilityChange","node","transformedContent","newlyTransformed","appliedTransformations","useNodeState","contentRef","useRef","observerRef","lastVisibilityChangeRef","visibilityChangeCountRef","previousVisibilityRef","renderKey","setRenderKey","useState","isVisible","setIsVisible","webGLError","setWebGLError","metrics","setMetrics","animatedTransformations","setAnimatedTransformations","useSelector","state","useEffect","handleWebGLError","event","visibilityTimeout","validationTimeout","isComponentMounted","entries","isNowVisible","_a","now","timeSinceLastChange","tooManyChanges","prev","transformationService","error","prioritizedTransformations","useMemo","highPriorityTransformations","t","startTime","transformedElements","transformationKeys","newTransformations","key","transformGroups","element","type","applyAnimationsWithStagger","elements","staggerDelay","batches","i","batch","batchIndex","text","matchingTransformation","group","endTime","jsxs","jsx","TransformationAnimationContainer"],"mappings":"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"}