{"version":3,"file":"node-view-BVBDDUA3.js","sources":["../../src/components/Constellation/NodesInstanced.tsx","../../src/components/Constellation/ConnectionsBatched.tsx"],"sourcesContent":["import { useDispatch, useSelector } from 'react-redux';\r\nimport {\r\n  nodeHovered,\r\n  nodeUnhovered,\r\n  selectHoveredNodeId,\r\n  selectSelectedNodeId,\r\n  nodeSelected,\r\n  setViewMode,\r\n} from '../../store/slices/interfaceSlice';\r\nimport { navigateToNode } from '../../store/slices/readerSlice';\r\nimport { visitNode } from '../../store/slices/nodesSlice';\r\nimport { AppDispatch } from '../../store';\r\nimport { ConstellationNode, NodePositions } from '../../types';\r\nimport { forwardRef, useMemo, useRef, useEffect } from 'react';\r\nimport { Color, InstancedMesh, ShaderMaterial, Frustum, Matrix4, Vector3 } from 'three';\r\nimport * as THREE from 'three';\r\nimport { useFrame, useThree } from '@react-three/fiber';\r\n\r\n// Cached simple noise function implementation\r\n// Using a more optimized approach with pre-computed values\r\nconst noise3D = (() => {\r\n  // Pre-compute some frequency values\r\n  const freqX = 0.3;\r\n  const freqY = 0.5;\r\n  const freqZ = 0.2;\r\n  const timeScaleX = 0.7;\r\n  const timeScaleY = 0.3;\r\n  const timeScaleZ = 0.5;\r\n  const amplitude = 0.3;\r\n  \r\n  // Create lookup tables for sin values to reduce calculations\r\n  const LOOKUP_SIZE = 256;\r\n  const sinLookup = new Float32Array(LOOKUP_SIZE);\r\n  for (let i = 0; i < LOOKUP_SIZE; i++) {\r\n    sinLookup[i] = Math.sin((i / LOOKUP_SIZE) * Math.PI * 2);\r\n  }\r\n  \r\n  // Get sin value from lookup table\r\n  const fastSin = (val: number): number => {\r\n    // Normalize value to 0-1 range\r\n    const idx = Math.floor((val % (Math.PI * 2)) / (Math.PI * 2) * LOOKUP_SIZE) & (LOOKUP_SIZE - 1);\r\n    return sinLookup[idx];\r\n  };\r\n  \r\n  return (x: number, y: number, z: number, time: number): number => {\r\n    // Using faster calculation with lookup\r\n    return fastSin(x * freqX + time * timeScaleX) * amplitude +\r\n           fastSin(y * freqY + time * timeScaleY) * amplitude +\r\n           fastSin(z * freqZ + time * timeScaleZ) * amplitude;\r\n  };\r\n})();\r\n\r\n// Circuit pattern vertex shader\r\nconst circuitVertexShader = `\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\n// Circuit pattern fragment shader\r\nconst circuitFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  \r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  varying vec2 vUv;\r\n  \r\n  // Simple hash function\r\n  float hash(vec2 p) {\r\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\r\n  }\r\n  \r\n  void main() {\r\n    // Basic circuit pattern\r\n    vec2 gridPos = floor(vPosition.xy * 10.0);\r\n    float circuit = hash(gridPos) > 0.7 ? 1.0 : 0.0;\r\n    \r\n    // Circuit lines\r\n    vec2 grid = fract(vPosition.xy * 10.0);\r\n    float line = smoothstep(0.95, 0.98, max(grid.x, grid.y));\r\n    \r\n    // Flowing effect on circuit lines\r\n    float flow = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Combine effects\r\n    vec3 finalColor = color * (0.5 + 0.5 * circuit + line * flow);\r\n    \r\n    // Add rim lighting\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    finalColor += color * rim * 0.5;\r\n    \r\n    gl_FragColor = vec4(finalColor, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field vertex shader for hover effect\r\nconst forceFieldVertexShader = `\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    vPosition = position;\r\n    vNormal = normalize(normalMatrix * normal);\r\n    \r\n    // Add subtle pulsating effect\r\n    float pulse = sin(time * 2.0) * 0.05 + 1.05;\r\n    vec3 newPosition = position * pulse;\r\n    \r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n  }\r\n`;\r\n\r\n// Force field fragment shader for hover effect\r\nconst forceFieldFragmentShader = `\r\n  uniform vec3 color;\r\n  uniform float time;\r\n  varying vec3 vPosition;\r\n  varying vec3 vNormal;\r\n  \r\n  void main() {\r\n    // Create flowing wave pattern\r\n    float wave = sin(vPosition.x * 5.0 + vPosition.y * 3.0 + time * 2.0) * 0.5 + 0.5;\r\n    \r\n    // Rim effect for sphere edge glow\r\n    float rim = 1.0 - max(0.0, dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 3.0);\r\n    \r\n    // Transparency based on rim and wave pattern\r\n    float alpha = rim * 0.7 * wave;\r\n    \r\n    // Final color with slight pulsation\r\n    float pulse = sin(time * 3.0) * 0.2 + 0.8;\r\n    vec3 finalColor = color * pulse * (0.5 + wave * 0.5);\r\n    \r\n    gl_FragColor = vec4(finalColor, alpha);\r\n  }\r\n`;\r\n\r\ninterface NodesInstancedProps {\r\n  nodes: ConstellationNode[];\r\n  nodePositions: NodePositions;\r\n  connections: { start: string; end: string }[];\r\n  overrideSelectedNodeId?: string;\r\n  onNodeClick?: (nodeId: string) => void;\r\n  clickableNodeIds?: string[];\r\n}\r\n\r\n// Define base colors for each triad - match exact character names from nodesSlice.ts\r\nconst triadColors = {\r\n  LastHuman: new Color('#ff6666'), // Reddish\r\n  Archaeologist: new Color('#66ff66'), // Greenish\r\n  Algorithm: new Color('#6666ff'), // Bluish\r\n};\r\n\r\n// Create a more permissive lookup that doesn't rely on exact matching\r\n// Helper to get color for node based on character with proper type safety\r\nconst getNodeColor = (character: string | undefined): Color => {\r\n  if (!character) return new Color('#ffffff');\r\n  \r\n  // Direct lookup with type safety\r\n  if (character === 'LastHuman') return triadColors.LastHuman;\r\n  if (character === 'Archaeologist') return triadColors.Archaeologist;\r\n  if (character === 'Algorithm') return triadColors.Algorithm;\r\n  \r\n  // Case-insensitive lookup as fallback\r\n  const lowerChar = character.toLowerCase();\r\n  if (lowerChar.includes('human')) return triadColors.LastHuman;\r\n  if (lowerChar.includes('arch')) return triadColors.Archaeologist;\r\n  if (lowerChar.includes('algo')) return triadColors.Algorithm;\r\n  \r\n  // Default\r\n  console.warn(`Unknown character type: ${character}, using default color`);\r\n  return new Color('#ffffff');\r\n};\r\n\r\n// We've fixed node visibility by:\r\n// 1. Using larger distance thresholds to prevent aggressive culling\r\n// 2. Implementing proper hover/unhover event handling\r\n// 3. Using direct position updates instead of matrix manipulation\r\n// 4. Ensuring proper color assignment for all character types\r\n\r\n// Create a class for managing node visibility and LOD\r\nclass NodeVisibilityManager {\r\n  private frustum: Frustum;\r\n  private matrix: Matrix4;\r\n  private camera: THREE.Camera;\r\n  private visibleNodes: Set<string>;\r\n  private distanceThresholds: { [key: string]: number };\r\n  private lastUpdateTime: number;\r\n  private updateInterval: number;\r\n  \r\n  constructor(camera: THREE.Camera) {\r\n    this.frustum = new Frustum();\r\n    this.matrix = new Matrix4();\r\n    this.camera = camera;\r\n    this.visibleNodes = new Set();\r\n    this.distanceThresholds = {\r\n      high: 60,   // High detail within 60 units (increased from 50)\r\n      medium: 90,  // Medium detail within 90 units (increased from 70)\r\n      low: 120     // Low detail within 120 units (increased from 90)\r\n    };\r\n    this.lastUpdateTime = 0;\r\n    this.updateInterval = 150; // Update visibility more frequently (was 250ms)\r\n  }\r\n  \r\n  updateFrustum() {\r\n    this.matrix.multiplyMatrices(\r\n      this.camera.projectionMatrix,\r\n      this.camera.matrixWorldInverse\r\n    );\r\n    this.frustum.setFromProjectionMatrix(this.matrix);\r\n  }\r\n  \r\n  shouldUpdate(time: number): boolean {\r\n    if (time - this.lastUpdateTime > this.updateInterval) {\r\n      this.lastUpdateTime = time;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  checkNodeVisibility(nodeId: string, position: Vector3): {\r\n    isVisible: boolean,\r\n    detailLevel: 'high' | 'medium' | 'low' | 'culled'\r\n  } {\r\n    // Track nodes that we've processed\r\n    if (this.visibleNodes.has(nodeId)) {\r\n      // Don't delete from visibleNodes here - we want to maintain the set\r\n    }\r\n    \r\n    // Calculate distance for LOD purposes\r\n    const distance = position.distanceTo(this.camera.position);\r\n    \r\n    // CRITICAL FIX: Always return nodes as visible, even if outside frustum\r\n    // This ensures all nodes are always visible, regardless of camera position\r\n    // We'll just use the distance for LOD purposes\r\n    \r\n    // Add to visible nodes set\r\n    this.visibleNodes.add(nodeId);\r\n    \r\n    // Distance already calculated above\r\n    \r\n    // Determine detail level based on distance\r\n    let detailLevel: 'high' | 'medium' | 'low' | 'culled';\r\n    if (distance <= this.distanceThresholds.high) {\r\n      detailLevel = 'high';\r\n    } else if (distance <= this.distanceThresholds.medium) {\r\n      detailLevel = 'medium';\r\n    } else if (distance <= this.distanceThresholds.low) {\r\n      detailLevel = 'low';\r\n    } else {\r\n      detailLevel = 'culled';\r\n    }\r\n    \r\n    // Add to visible nodes\r\n    this.visibleNodes.add(nodeId);\r\n    \r\n    return { isVisible: true, detailLevel };\r\n  }\r\n  \r\n  getVisibleNodeCount(): number {\r\n    return this.visibleNodes.size;\r\n  }\r\n}\r\n\r\nexport const NodesInstanced = forwardRef<InstancedMesh, NodesInstancedProps>(\r\n  (props, ref) => {\r\n  const {\r\n    nodes,\r\n    nodePositions,\r\n    connections,\r\n    overrideSelectedNodeId,\r\n    onNodeClick,\r\n    clickableNodeIds,\r\n  } = props;\r\n  const dispatch = useDispatch<AppDispatch>();\r\n  \r\n  const hoveredNodeId = useSelector(selectHoveredNodeId);\r\n  const reduxSelectedNodeId = useSelector(selectSelectedNodeId);\r\n  const selectedNodeId = overrideSelectedNodeId ?? reduxSelectedNodeId;\r\n  \r\n  // Get camera from Three.js context for visibility culling\r\n  const { camera } = useThree();\r\n  \r\n  // Create visibility manager\r\n  const visibilityManagerRef = useRef<NodeVisibilityManager | null>(null);\r\n  // Track nodes visibility\r\n  const forceUpdateCounter = useRef({ count: 0 });\r\n  \r\n  const connectedNodeIds = useMemo(() => {\r\n    if (!selectedNodeId) return new Set<string>();\r\n    const connected = new Set<string>();\r\n    connections.forEach((c) => {\r\n      if (c.start === selectedNodeId) connected.add(c.end);\r\n      if (c.end === selectedNodeId) connected.add(c.start);\r\n    });\r\n    return connected;\r\n  }, [selectedNodeId, connections]);\r\n\r\n  // Create refs for accessing objects in the scene\r\n  const materialRefs = useRef<ShaderMaterial[]>([]);\r\n  const forceFieldMaterialRefs = useRef<ShaderMaterial[]>([]);\r\n  const nodeMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  const forceFieldMeshRefs = useRef<THREE.Object3D[]>([]);\r\n  \r\n  // Store original positions for the noise animation\r\n  const originalPositions = useRef<{[key: string]: [number, number, number]}>({});\r\n  \r\n  // Initialize original positions\r\n  useMemo(() => {\r\n    nodes.forEach(node => {\r\n      const position = nodePositions[node.id] || [0, 0, 0];\r\n      originalPositions.current[node.id] = [...position];\r\n    });\r\n  }, [nodes, nodePositions]);\r\n  \r\n  // Create visibility manager on initialization\r\n  useEffect(() => {\r\n    if (!visibilityManagerRef.current) {\r\n      visibilityManagerRef.current = new NodeVisibilityManager(camera);\r\n    }\r\n  }, [camera]);\r\n  \r\n  // Update shader time uniform and apply noise movement with optimized LOD\r\n  // Frame counter for throttling updates\r\n  const frameCount = useRef(0);\r\n  const lastUpdatePositionsTime = useRef(0);\r\n  const lastUpdateMaterialsTime = useRef(0);\r\n  \r\n  // Enhanced optimization: Using variable update rates based on priority\r\n  useFrame((state) => {\r\n    const time = state.clock.elapsedTime;\r\n    frameCount.current += 1;\r\n    \r\n    // Initialize visibility manager if needed\r\n    if (!visibilityManagerRef.current) {\r\n      visibilityManagerRef.current = new NodeVisibilityManager(camera);\r\n    }\r\n    \r\n    // Update frustum for visibility checks (less frequently)\r\n    if (visibilityManagerRef.current.shouldUpdate(time)) {\r\n      visibilityManagerRef.current.updateFrustum();\r\n      \r\n      // Force occasional full visibility update to catch any missed nodes\r\n      forceUpdateCounter.current.count++;\r\n      \r\n      // More frequent checks (every second) to ensure nodes stay visible\r\n      if (forceUpdateCounter.current.count % 6 === 0) {\r\n        console.log(\"Performing visibility validation check...\");\r\n        let visibleCount = 0;\r\n        \r\n        // Every ~1 second, ensure all nodes have been evaluated\r\n        nodes.forEach(node => {\r\n          const mesh = nodeMeshRefs.current[nodes.indexOf(node)];\r\n          if (mesh) {\r\n            // Always ensure nodes are visible\r\n            const isImportant = node.id === selectedNodeId ||\r\n                             node.id === hoveredNodeId ||\r\n                             connectedNodeIds.has(node.id);\r\n            \r\n            if (mesh.visible === false) {\r\n              // Force important nodes to always be visible\r\n              if (isImportant) {\r\n                console.log(`Forcing visibility for important node: ${node.id}`);\r\n                mesh.visible = true;\r\n              }\r\n            }\r\n            \r\n            if (mesh.visible) {\r\n              visibleCount++;\r\n            }\r\n          }\r\n        });\r\n        \r\n        console.log(`Visible nodes: ${visibleCount} / ${nodes.length}`);\r\n        \r\n        // Emergency fallback - if too few nodes are visible, make all visible\r\n        if (visibleCount < nodes.length * 0.7) {\r\n          console.warn(\"Too few nodes visible, forcing all nodes to be visible\");\r\n          nodes.forEach((_, idx) => {\r\n            const mesh = nodeMeshRefs.current[idx];\r\n            if (mesh) {\r\n              mesh.visible = true;\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Time-based throttling for shader updates\r\n    const shouldUpdateMaterials = time - lastUpdateMaterialsTime.current > 0.05; // 50ms\r\n    if (shouldUpdateMaterials) {\r\n      lastUpdateMaterialsTime.current = time;\r\n      \r\n      // Update time uniforms on important materials only\r\n      const importantMaterials = materialRefs.current.filter((_, i) => {\r\n        const node = nodes[i];\r\n        return node && (\r\n          node.id === selectedNodeId ||\r\n          node.id === hoveredNodeId ||\r\n          connections.some(c => c.start === node.id || c.end === node.id)\r\n        );\r\n      });\r\n      \r\n      // Batch updates to reduce overhead\r\n      importantMaterials.forEach(material => {\r\n        if (material?.uniforms?.time) {\r\n          material.uniforms.time.value = time;\r\n        }\r\n      });\r\n      \r\n      // Update force field materials only for selected/hovered nodes\r\n      const importantForceFields = forceFieldMaterialRefs.current.filter((_, i) => {\r\n        const node = nodes[i];\r\n        return node && (node.id === selectedNodeId || node.id === hoveredNodeId);\r\n      });\r\n      \r\n      importantForceFields.forEach(material => {\r\n        if (material?.uniforms?.time) {\r\n          material.uniforms.time.value = time;\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Throttle the expensive noise-based position updates\r\n    // More aggressive throttling for nodes that are not important\r\n    const timeSinceLastPositionUpdate = time - lastUpdatePositionsTime.current;\r\n    const shouldUpdatePositions = timeSinceLastPositionUpdate > 0.1; // 100ms\r\n    \r\n    if (shouldUpdatePositions) {\r\n      lastUpdatePositionsTime.current = time;\r\n      \r\n      // Apply organic movement to nodes using noise - with optimized calculations\r\n      \r\n      for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        const nodeMesh = nodeMeshRefs.current[i];\r\n        \r\n        if (!nodeMesh) {\r\n          continue; // Skip if mesh doesn't exist\r\n        }\r\n        \r\n        const origPos = originalPositions.current[node.id];\r\n        if (!origPos) {\r\n          continue; // Skip if no original position\r\n        }\r\n        \r\n        // Create a Vector3 for position (reused for visibility check)\r\n        const position = new THREE.Vector3(origPos[0], origPos[1], origPos[2]);\r\n        \r\n        // Check visibility and LOD level\r\n        const { detailLevel } = visibilityManagerRef.current.checkNodeVisibility(\r\n          node.id,\r\n          position\r\n        );\r\n        \r\n        // Define isImportantNode once to avoid duplicates\r\n        const isImportantNode = node.id === selectedNodeId ||\r\n                               node.id === hoveredNodeId ||\r\n                               connectedNodeIds.has(node.id);\r\n                                \r\n        // Always show all nodes regardless of culling\r\n        // Forced visibility fix to prevent nodes from disappearing\r\n        nodeMesh.visible = true;\r\n        \r\n        // Only hide force field for non-important nodes\r\n        const forceMesh = forceFieldMeshRefs.current[i];\r\n        if (forceMesh) {\r\n          forceMesh.visible = isImportantNode;\r\n        }\r\n        \r\n        // Adjust noise amount based on detail level\r\n        let noiseAmount = 0.03; // Default\r\n        \r\n        switch (detailLevel) {\r\n          case 'high':\r\n            // Full detail for important nodes\r\n            noiseAmount = 0.03;\r\n            break;\r\n          case 'medium':\r\n            // Medium detail for medium distance\r\n            noiseAmount = 0.02;\r\n            break;\r\n          case 'low':\r\n            // Low detail for far distance\r\n            noiseAmount = 0.01;\r\n            break;\r\n        }\r\n        \r\n        // Special case for important nodes - always high detail\r\n        if (isImportantNode) {\r\n          noiseAmount = 0.03;\r\n        }\r\n        \r\n        // More consistent update frequency with prioritization for important nodes\r\n        // Always update important nodes and those in high/medium detail levels\r\n        const shouldUpdate =\r\n          isImportantNode || // Always update important nodes\r\n          detailLevel === 'high' || // Always update high detail nodes\r\n          (detailLevel === 'medium' && frameCount.current % 2 === 0) || // Medium every 2nd frame\r\n          (detailLevel === 'low' && frameCount.current % 3 === 0);  // Low every 3rd frame\r\n          \r\n        if (shouldUpdate) {\r\n          // Apply subtle noise-based movement - with adaptive amplitude\r\n          const nx = noise3D(origPos[0], origPos[1], origPos[2], time * 0.3);\r\n          const ny = noise3D(origPos[0] + 100, origPos[1] + 100, origPos[2] + 100, time * 0.25);\r\n          const nz = noise3D(origPos[0] + 200, origPos[1] + 200, origPos[2] + 200, time * 0.2);\r\n          \r\n          // CHANGE: Use direct position updates instead of matrix manipulation\r\n          // This is more compatible and reliable though less performant\r\n          nodeMesh.position.set(\r\n            origPos[0] + nx * noiseAmount,\r\n            origPos[1] + ny * noiseAmount,\r\n            origPos[2] + nz * noiseAmount\r\n          );\r\n          nodeMesh.matrixAutoUpdate = true;\r\n          \r\n          // Update force field position only if it exists and node is important\r\n          const forceMesh = forceFieldMeshRefs.current[i];\r\n          if (forceMesh && (isImportantNode || detailLevel === 'high')) {\r\n            forceMesh.visible = isImportantNode; // Only show for important nodes\r\n            forceMesh.position.copy(nodeMesh.position);\r\n          } else if (forceMesh) {\r\n            forceMesh.visible = false;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // No need to update visible node count since we removed the display\r\n    }\r\n  });\r\n  \r\n  // Create a dummy instanced mesh to maintain API compatibility with ref\r\n  // while still using individual meshes for better control\r\n  return (\r\n    <group>\r\n      {/* This invisible instanced mesh is just for ref compatibility */}\r\n      {ref && (\r\n        <instancedMesh\r\n          ref={ref}\r\n          args={[\r\n            new THREE.BufferGeometry(),\r\n            new THREE.MeshBasicMaterial(),\r\n            0\r\n          ]}\r\n          visible={false}\r\n        />\r\n      )}\r\n      {nodes.map((node, index) => {\r\n        const position = nodePositions[node.id] || [0, 0, 0];\r\n        const isSelected = selectedNodeId === node.id;\r\n        const isConnected = connectedNodeIds.has(node.id);\r\n        const isHovered = hoveredNodeId === node.id;\r\n        \r\n        // Calculate node color using our more permissive function\r\n        const nodeColor = getNodeColor(node.character).clone();\r\n        \r\n        // Apply color adjustments based on node state\r\n        if (isSelected) {\r\n          nodeColor.multiplyScalar(1.5); // Lighter shade\r\n        } else if (isConnected) {\r\n          nodeColor.multiplyScalar(0.5); // Darker shade\r\n        } else if (isHovered) {\r\n          nodeColor.multiplyScalar(1.2); // Slightly lighter for hover\r\n        }\r\n        \r\n        return (\r\n          <group key={node.id}>\r\n            {/* Force field effect (only visible when hovered or selected) */}\r\n            {(isHovered || isSelected) && (\r\n              <mesh\r\n                ref={(mesh) => {\r\n                  if (mesh) {\r\n                    forceFieldMeshRefs.current[index] = mesh;\r\n                  }\r\n                }}\r\n                position={[position[0], position[1], position[2]]}>\r\n                <sphereGeometry args={[0.7, 16, 16]} />\r\n                <shaderMaterial\r\n                  ref={(material) => {\r\n                    if (material) {\r\n                      forceFieldMaterialRefs.current[index] = material;\r\n                    }\r\n                  }}\r\n                  vertexShader={forceFieldVertexShader}\r\n                  fragmentShader={forceFieldFragmentShader}\r\n                  uniforms={{\r\n                    color: { value: nodeColor },\r\n                    time: { value: 0 }\r\n                  }}\r\n                  transparent={true}\r\n                  depthWrite={false}\r\n                />\r\n              </mesh>\r\n            )}\r\n            \r\n            {/* Main node mesh */}\r\n            <mesh\r\n              ref={(mesh) => {\r\n                if (mesh) {\r\n                  nodeMeshRefs.current[index] = mesh;\r\n                }\r\n              }}\r\n              position={[position[0], position[1], position[2]]}\r\n              onClick={(e) => {\r\n                e.stopPropagation();\r\n                \r\n                // Emit custom event to hide tooltip when a node is clicked\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n                \r\n                if (onNodeClick) {\r\n                  if (clickableNodeIds && !clickableNodeIds.includes(node.id)) {\r\n                    return;\r\n                  }\r\n                  onNodeClick(node.id);\r\n                } else {\r\n                  if (selectedNodeId === null) {\r\n                    dispatch(nodeSelected(node.id));\r\n                    dispatch(visitNode(node.id));\r\n                    dispatch(setViewMode('reading')); // Set view mode to reading\r\n                    dispatch(navigateToNode({\r\n                      nodeId: node.id,\r\n                      character: node.character,\r\n                      temporalValue: node.temporalValue,\r\n                      attractors: node.strangeAttractors\r\n                    }));\r\n                    return;\r\n                  }\r\n                  \r\n                  const isConnected = connections.some(\r\n                    (c) =>\r\n                      (c.start === selectedNodeId && c.end === node.id) ||\r\n                      (c.start === node.id && c.end === selectedNodeId)\r\n                  );\r\n                  \r\n                  if (isConnected) {\r\n                    dispatch(nodeSelected(node.id));\r\n                    dispatch(visitNode(node.id));\r\n                    dispatch(setViewMode('reading')); // Set view mode to reading\r\n                    dispatch(navigateToNode({\r\n                      nodeId: node.id,\r\n                      character: node.character,\r\n                      temporalValue: node.temporalValue,\r\n                      attractors: node.strangeAttractors\r\n                    }));\r\n                  }\r\n                }\r\n              }}\r\n              onPointerOver={(e) => {\r\n                e.stopPropagation();\r\n                if (node.id !== hoveredNodeId) {\r\n                  dispatch(nodeHovered(node.id));\r\n                  \r\n                  // Emit custom event for tooltip positioning\r\n                  // Just use client coordinates from the event directly\r\n                  const nodeHoverEvent = new CustomEvent('node-hover', {\r\n                    detail: {\r\n                      position: {\r\n                        x: e.clientX,\r\n                        y: e.clientY - 40 // Position tooltip 40px above cursor\r\n                      },\r\n                      nodeId: node.id\r\n                    }\r\n                  });\r\n                  window.dispatchEvent(nodeHoverEvent);\r\n                }\r\n              }}\r\n              onPointerOut={(e) => {\r\n                e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                \r\n                // Emit custom event for tooltip hiding\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n              }}\r\n              \r\n              // Fix for stuck hover: Add pointer leave event\r\n              onPointerLeave={(e) => {\r\n                e.stopPropagation();\r\n                dispatch(nodeUnhovered());\r\n                \r\n                // Emit custom event for tooltip hiding\r\n                const nodeUnhoverEvent = new CustomEvent('node-unhover');\r\n                window.dispatchEvent(nodeUnhoverEvent);\r\n              }}\r\n            >\r\n              {/* Use lower poly geometry for distant nodes */}\r\n              {/* Performance optimization: Use lower poly geometry for distant nodes */}\r\n              {!isSelected && !isHovered ? (\r\n                <octahedronGeometry args={[0.5, 0]} /> // Lower poly for distant nodes\r\n              ) : (\r\n                <sphereGeometry args={[0.5, 8, 8]} /> // Higher detail for selected/hovered\r\n              )}\r\n              <shaderMaterial\r\n                ref={(material) => {\r\n                  if (material) {\r\n                    // Store reference to this material\r\n                    materialRefs.current[index] = material;\r\n                  }\r\n                }}\r\n                vertexShader={circuitVertexShader}\r\n                fragmentShader={circuitFragmentShader}\r\n                uniforms={{\r\n                  color: { value: nodeColor },\r\n                  time: { value: 0 }\r\n                }}\r\n              />\r\n            </mesh>\r\n          </group>\r\n        );\r\n      })}\r\n      \r\n      {/* Performance display removed */}\r\n    </group>\r\n  );\r\n});","import React, { forwardRef, useEffect, useMemo, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { BufferGeometry, InstancedMesh, DoubleSide } from 'three';\r\nimport { useAppSelector } from '../../store/hooks';\r\nimport { Connection, NodePositions } from '../../types';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\ninterface ConnectionsBatchedProps {\r\n  connections: Connection[];\r\n  nodePositions: NodePositions;\r\n}\r\n\r\n// Connection line shader code for glowing effects\r\nconst connectionVertexShader = `\r\n  // Using the built-in 'color' attribute instead of redefining it\r\n  uniform float time;\r\n  varying vec3 vColor;\r\n  varying float vPosition;\r\n  \r\n  void main() {\r\n    vColor = color;\r\n    vPosition = position.y;\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n    gl_Position = projectedPosition;\r\n  }\r\n`;\r\n\r\nconst connectionFragmentShader = `\r\n  uniform float time;\r\n  varying vec3 vColor;\r\n  varying float vPosition;\r\n  \r\n  void main() {\r\n    // Create flowing effect along the connection\r\n    float flow = sin(vPosition * 10.0 + time * 3.0) * 0.5 + 0.5;\r\n    \r\n    // Create pulsating glow effect\r\n    float pulse = sin(time * 2.0) * 0.2 + 0.8;\r\n    \r\n    // Combine effects\r\n    vec3 finalColor = vColor * (1.0 + flow * 0.3) * pulse;\r\n    \r\n    // Add subtle variation based on time\r\n    finalColor += vec3(sin(time * 0.2) * 0.05, sin(time * 0.3) * 0.05, sin(time * 0.4) * 0.05);\r\n    \r\n    gl_FragColor = vec4(finalColor, 0.9);\r\n  }\r\n`;\r\n\r\n// Using forwardRef for API compatibility\r\nconst ConnectionsBatched = forwardRef<InstancedMesh, ConnectionsBatchedProps>(\r\n  (props, ref) => {\r\n    const { connections, nodePositions } = props;\r\n    console.log(\"ConnectionsBatched rendering with:\", {\r\n      connectionCount: connections.length,\r\n      nodePositionsCount: Object.keys(nodePositions).length\r\n    });\r\n    \r\n    // We use our own lineSegmentsRef since we're actually using LineSegments, not InstancedMesh\r\n    // The forwardRef is just for API compatibility\r\n    const lineSegmentsRef = useRef<THREE.LineSegments>(null!);\r\n    \r\n    // Acknowledge forwarded ref with null - we don't actually use an InstancedMesh\r\n    // This is a proper use of the ref parameter required by forwardRef\r\n    React.useImperativeHandle(ref, () => null!);\r\n  const geometryRef = useRef<BufferGeometry>(null!);\r\n  const selectedNodeId = useAppSelector((state) => state.interface.selectedNodeId);\r\n  // We're not using instancedMeshRef or nodeIndexMap anymore since we're using direct positions\r\n\r\n  // Create a reference for the custom shader material\r\n  const connectionMaterialRef = useRef<THREE.ShaderMaterial>(null);\r\n  const hoveredNodeId = useAppSelector(state => state.interface.hoveredNodeId);\r\n\r\n  const { positions, colors, lineCount } = useMemo(() => {\r\n    const positions = new Float32Array(connections.length * 2 * 3);\r\n    const colors = new Float32Array(connections.length * 2 * 3);\r\n    let lineCount = 0;\r\n\r\n    for (const connection of connections) {\r\n      const startNodePos = nodePositions[connection.source];\r\n      const endNodePos = nodePositions[connection.target];\r\n\r\n      if (startNodePos && endNodePos) {\r\n        positions.set(startNodePos, lineCount * 6);\r\n        positions.set(endNodePos, lineCount * 6 + 3);\r\n\r\n        const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n        const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n        \r\n        // Enhanced color logic\r\n        let color;\r\n        if (isSelected) {\r\n          color = new THREE.Color(0x00bfff); // Bright blue for selected\r\n        } else if (isHovered) {\r\n          color = new THREE.Color(0x88ccff); // Light blue for hovered\r\n        } else {\r\n          color = new THREE.Color(0x444444); // Default dark gray\r\n        }\r\n        \r\n        colors.set([color.r, color.g, color.b], lineCount * 6);\r\n        colors.set([color.r, color.g, color.b], lineCount * 6 + 3);\r\n\r\n        lineCount++;\r\n      }\r\n    }\r\n    return { positions, colors, lineCount };\r\n  }, [connections, nodePositions, selectedNodeId, hoveredNodeId]);\r\n\r\n  useEffect(() => {\r\n    console.log(\"ConnectionsBatched initializing geometry with:\", {\r\n      lineCount,\r\n      positionsLength: positions.length,\r\n      colorsLength: colors.length\r\n    });\r\n    \r\n    const geometry = geometryRef.current;\r\n    if (!geometry) {\r\n      console.warn(\"ConnectionsBatched: geometryRef.current is null\");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n      geometry.setDrawRange(0, lineCount * 2);\r\n\r\n      geometry.attributes.position.needsUpdate = true;\r\n      geometry.attributes.color.needsUpdate = true;\r\n      \r\n      console.log(\"ConnectionsBatched: Successfully initialized geometry attributes\");\r\n    } catch (error) {\r\n      console.error(\"Error initializing geometry attributes:\", error);\r\n    }\r\n  }, [positions, colors, lineCount]);\r\n\r\n  // Frame counter for throttling updates\r\n  const frameCount = useRef(0);\r\n\r\n  useFrame((state) => {\r\n    // Increment frame counter\r\n    frameCount.current += 1;\r\n    \r\n    // Skip if refs are not ready\r\n    if (!geometryRef.current) {\r\n      return;\r\n    }\r\n    \r\n    // Update shader time uniform - this is relatively inexpensive\r\n    if (connectionMaterialRef.current) {\r\n      connectionMaterialRef.current.uniforms.time.value = state.clock.elapsedTime;\r\n    }\r\n    \r\n    // Skip if attributes are not ready\r\n    if (!geometryRef.current.attributes.position || !geometryRef.current.attributes.color) {\r\n      return;\r\n    }\r\n    \r\n    // Only update positions every 2 frames to reduce GPU load\r\n    const shouldUpdatePositions = frameCount.current % 2 === 0;\r\n    // Only update colors every 3 frames (except for selected/hovered items)\r\n    const shouldUpdateColors = frameCount.current % 3 === 0;\r\n    \r\n    try {\r\n      const positionAttribute = geometryRef.current.attributes.position as THREE.BufferAttribute;\r\n      const colorAttribute = geometryRef.current.attributes.color as THREE.BufferAttribute;\r\n      \r\n      let positionsUpdated = false;\r\n      let colorsUpdated = false;\r\n      \r\n      // Update each connection\r\n      for (let i = 0; i < connections.length; i++) {\r\n        const connection = connections[i];\r\n        \r\n        // Use the nodePositions directly instead of trying to get from instancedMesh\r\n        const startPos = nodePositions[connection.source];\r\n        const endPos = nodePositions[connection.target];\r\n        \r\n        if (!startPos || !endPos) {\r\n          // Safety check for missing node positions - log for debugging\r\n          console.warn(`ConnectionsBatched: Missing position for connection ${connection.source} -> ${connection.target}`);\r\n          continue; // Skip if positions aren't available\r\n        }\r\n        \r\n        // Update positions less frequently to save resources\r\n        if (shouldUpdatePositions) {\r\n          positionAttribute.setXYZ(i * 2, startPos[0], startPos[1], startPos[2]);\r\n          positionAttribute.setXYZ(i * 2 + 1, endPos[0], endPos[1], endPos[2]);\r\n          positionsUpdated = true;\r\n        }\r\n        \r\n        // Check if this connection needs immediate color update (selected/hovered)\r\n        const isSelected = selectedNodeId === connection.source || selectedNodeId === connection.target;\r\n        const isHovered = hoveredNodeId === connection.source || hoveredNodeId === connection.target;\r\n        \r\n        // Always update colors for selected/hovered connections, otherwise throttle\r\n        if (isSelected || isHovered || shouldUpdateColors) {\r\n          let color;\r\n          if (isSelected) {\r\n            // Simplified color animation for selected connections\r\n            const pulse = Math.sin(state.clock.elapsedTime * 2) * 0.1 + 0.9;\r\n            color = new THREE.Color(0x00bfff).multiplyScalar(pulse);\r\n          } else if (isHovered) {\r\n            color = new THREE.Color(0x88ccff);\r\n          } else {\r\n            color = new THREE.Color(0x444444);\r\n          }\r\n          \r\n          colorAttribute.setXYZ(i * 2, color.r, color.g, color.b);\r\n          colorAttribute.setXYZ(i * 2 + 1, color.r, color.g, color.b);\r\n          colorsUpdated = true;\r\n        }\r\n      }\r\n      \r\n      // Only mark attributes as needing update if they changed\r\n      if (positionsUpdated) {\r\n        positionAttribute.needsUpdate = true;\r\n      }\r\n      if (colorsUpdated) {\r\n        colorAttribute.needsUpdate = true;\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error updating connection positions and colors:\", error);\r\n    }\r\n  });\r\n\r\n  // Create the shader material\r\n  useEffect(() => {\r\n    if (geometryRef.current) {\r\n      const material = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          time: { value: 0 }\r\n        },\r\n        vertexShader: connectionVertexShader,\r\n        fragmentShader: connectionFragmentShader,\r\n        vertexColors: true,\r\n        transparent: true,\r\n        side: DoubleSide,\r\n        depthWrite: false,\r\n      });\r\n      \r\n      if (lineSegmentsRef.current) {\r\n        lineSegmentsRef.current.material = material;\r\n        connectionMaterialRef.current = material;\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Always ensure lineCount is correct\r\n  useEffect(() => {\r\n    if (geometryRef.current && lineCount > 0) {\r\n      geometryRef.current.setDrawRange(0, lineCount * 2);\r\n    }\r\n  }, [lineCount]);\r\n\r\n  return (\r\n    <lineSegments ref={lineSegmentsRef} frustumCulled={false}>\r\n      <bufferGeometry ref={geometryRef} />\r\n    </lineSegments>\r\n  );\r\n});\r\n\r\nexport default ConnectionsBatched;"],"names":["noise3D","sinLookup","i","fastSin","val","idx","x","y","z","time","circuitVertexShader","circuitFragmentShader","forceFieldVertexShader","forceFieldFragmentShader","triadColors","Color","getNodeColor","character","lowerChar","NodeVisibilityManager","camera","__publicField","Frustum","Matrix4","nodeId","position","distance","detailLevel","NodesInstanced","forwardRef","props","ref","nodes","nodePositions","connections","overrideSelectedNodeId","onNodeClick","clickableNodeIds","dispatch","useDispatch","hoveredNodeId","useSelector","selectHoveredNodeId","reduxSelectedNodeId","selectSelectedNodeId","selectedNodeId","useThree","visibilityManagerRef","useRef","forceUpdateCounter","connectedNodeIds","useMemo","connected","c","materialRefs","forceFieldMaterialRefs","nodeMeshRefs","forceFieldMeshRefs","originalPositions","node","useEffect","frameCount","lastUpdatePositionsTime","lastUpdateMaterialsTime","useFrame","state","visibleCount","mesh","isImportant","_","material","_a","nodeMesh","origPos","THREE.Vector3","isImportantNode","forceMesh","noiseAmount","nx","ny","nz","jsx","THREE.BufferGeometry","THREE.MeshBasicMaterial","index","isSelected","isConnected","isHovered","nodeColor","jsxs","nodeUnhoverEvent","nodeSelected","visitNode","setViewMode","navigateToNode","nodeHovered","nodeHoverEvent","nodeUnhovered","connectionVertexShader","connectionFragmentShader","ConnectionsBatched","lineSegmentsRef","React","geometryRef","useAppSelector","connectionMaterialRef","positions","colors","lineCount","connection","startNodePos","endNodePos","color","THREE.Color","geometry","THREE.Float32BufferAttribute","error","shouldUpdatePositions","shouldUpdateColors","positionAttribute","colorAttribute","positionsUpdated","colorsUpdated","startPos","endPos","pulse","THREE.ShaderMaterial","DoubleSide"],"mappings":"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"}